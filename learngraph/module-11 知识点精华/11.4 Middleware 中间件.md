# Middleware 中间件：给你的 AI Agent 装上"安检门"

在构建 AI Agent 时，你是否遇到过这些问题？

- 想在 Agent 调用 LLM 之前检查一下输入是否合规
- 想在 Agent 执行工具之前让人工确认一下
- 想自动压缩过长的对话历史，避免超出 Token 限制
- 想记录 Agent 的每一步操作，方便调试

**Middleware（中间件）** 就是为解决这些问题而生的。

---

## 什么是中间件？一个生活中的比喻

想象你要进入一栋大楼：

```
你 → [安检门] → [前台登记] → [访客证发放] → 进入大楼
```

在这个过程中，安检门、前台登记、访客证发放都是"中间件"——它们：
1. **不改变你的最终目的**（进入大楼）
2. **在你到达目的地之前/之后执行额外的操作**
3. **可以灵活增减**（VIP 可能跳过安检，普通访客需要全部流程）

在 AI Agent 中，中间件的作用类似：

```
用户请求 → [日志记录] → [权限检查] → [内容审核] → LLM 处理 → [结果过滤] → 返回用户
```

每个方括号里的步骤都是一个中间件，它们可以：
- **拦截**：阻止不合规的请求
- **修改**：调整请求或响应的内容
- **记录**：保存执行过程供分析
- **增强**：添加额外的处理逻辑

---

## LangGraph 1.0 中的 Middleware

LangChain/LangGraph 1.0 版本引入了全新的 **Agent Middleware** 抽象，让你能够在 Agent 执行的每一步插入自定义逻辑。

![Middleware 概览](./images/11.4-middleware-overview.png)

### 中间件在 Agent 循环中的位置

一个标准的 Agent 循环是这样的：

![Agent 循环](./images/11.4-agent-loop.png)

```
START → 调用 LLM → 判断是否需要工具 → 执行工具 → 返回 LLM → ... → END
```

中间件可以在这个循环的**多个关键点**插入：

![中间件挂接点](./images/11.4-middleware-hooks.png)

---

## 三大核心钩子

LangGraph Middleware 提供了三个核心钩子函数：

### 1. `before_model` - 模型调用前

在 LLM 被调用之前执行，可以：
- 检查和修改输入状态
- 决定是否跳过模型调用
- 直接跳转到其他节点

```python
def before_model(state, config):
    """在模型调用前执行"""
    # 检查是否有敏感词
    if contains_sensitive_words(state["messages"]):
        # 可以选择跳过模型调用，直接返回预设回复
        return Command(goto=END, update={
            "messages": [AIMessage("抱歉，我无法处理这类请求")]
        })

    # 正常继续执行
    return state
```

**使用场景**：
- 内容审核
- 权限验证
- 请求预处理

### 2. `after_model` - 模型调用后

在 LLM 返回结果后执行，可以：
- 审核模型的输出
- 实现人工确认机制
- 添加保护机制

```python
def after_model(state, config):
    """在模型调用后执行"""
    last_message = state["messages"][-1]

    # 检查模型是否要执行危险操作
    if has_dangerous_tool_call(last_message):
        # 暂停执行，等待人工确认
        human_approved = interrupt({
            "question": "模型想要执行敏感操作，是否批准？",
            "action": last_message.tool_calls
        })

        if not human_approved:
            return Command(goto=END, update={
                "messages": [AIMessage("操作已被用户取消")]
            })

    return state
```

**使用场景**：
- Human-in-the-loop（人工审核）
- 输出过滤
- 结果增强

### 3. `modify_model_request` - 修改模型请求

在发送给 LLM 之前，修改请求的各个方面：
- 工具列表
- 提示词
- 消息历史
- 模型参数
- 输出格式

```python
def modify_model_request(state, config, request):
    """修改发送给模型的请求"""
    # 根据用户权限动态调整可用工具
    user_role = config.get("user_role", "guest")

    if user_role == "admin":
        # 管理员可以使用所有工具
        pass
    else:
        # 普通用户只能使用安全工具
        request.tools = [t for t in request.tools if t.name in SAFE_TOOLS]

    # 压缩过长的消息历史
    if len(request.messages) > 50:
        request.messages = summarize_messages(request.messages)

    return request
```

**使用场景**：
- 动态工具选择
- 消息历史压缩
- 提示词注入
- 模型参数调整

---

## 中间件执行顺序

中间件按照**洋葱模型**执行：

```
请求进入 → middleware_1 → middleware_2 → middleware_3 → LLM
                                                         ↓
响应返回 ← middleware_1 ← middleware_2 ← middleware_3 ← LLM
```

- **进入时**：按添加顺序执行（1 → 2 → 3）
- **返回时**：按相反顺序执行（3 → 2 → 1）

这和 Web 服务器的中间件模式完全一致。

---

## 三个内置中间件

LangGraph 提供了三个开箱即用的中间件：

### 1. Human-in-the-Loop（人工审核）

让用户可以批准、编辑或拒绝 Agent 的工具调用。

```python
from langchain.middleware import HumanApprovalMiddleware

middleware = HumanApprovalMiddleware(
    # 只对特定工具要求人工审核
    tools_requiring_approval=["send_email", "delete_file", "transfer_money"]
)

agent = create_react_agent(
    model=llm,
    tools=tools,
    middleware=[middleware]
)
```

**适用场景**：
- 涉及外部系统的操作
- 金融交易
- 数据删除
- 发送通知

### 2. Summarization（消息摘要）

当消息历史接近上下文限制时，自动压缩早期对话。

```python
from langchain.middleware import SummarizationMiddleware

middleware = SummarizationMiddleware(
    max_messages=100,          # 超过 100 条消息时触发
    summary_model=llm,         # 用于生成摘要的模型
    preserve_recent=10         # 保留最近 10 条原始消息
)

agent = create_react_agent(
    model=llm,
    tools=tools,
    middleware=[middleware]
)
```

**适用场景**：
- 长对话场景
- 复杂任务执行
- 防止 Token 溢出

### 3. PII Redaction（隐私信息脱敏）

自动识别和脱敏敏感信息，如邮箱、电话号码、身份证号等。

```python
from langchain.middleware import PIIRedactionMiddleware

middleware = PIIRedactionMiddleware(
    patterns=[
        r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',  # 邮箱
        r'\b1[3-9]\d{9}\b',  # 中国手机号
        r'\b\d{17}[\dXx]\b',  # 身份证号
    ],
    replacement="[已脱敏]"
)

agent = create_react_agent(
    model=llm,
    tools=tools,
    middleware=[middleware]
)
```

**适用场景**：
- 客服系统
- 医疗健康应用
- 金融服务
- GDPR/隐私合规

---

## 自定义中间件

除了内置中间件，你可以轻松创建自己的中间件：

```python
from langchain.middleware import BaseMiddleware

class LoggingMiddleware(BaseMiddleware):
    """记录 Agent 每一步操作的中间件"""

    def before_model(self, state, config):
        print(f"[LOG] 即将调用 LLM，当前消息数: {len(state['messages'])}")
        return state

    def after_model(self, state, config):
        last_msg = state["messages"][-1]
        if hasattr(last_msg, 'tool_calls') and last_msg.tool_calls:
            print(f"[LOG] LLM 决定调用工具: {[tc['name'] for tc in last_msg.tool_calls]}")
        else:
            print(f"[LOG] LLM 生成了最终回复")
        return state


class CostTrackingMiddleware(BaseMiddleware):
    """追踪 Token 消耗的中间件"""

    def __init__(self):
        self.total_tokens = 0

    def after_model(self, state, config):
        # 从响应中提取 Token 使用量
        last_msg = state["messages"][-1]
        if hasattr(last_msg, 'response_metadata'):
            usage = last_msg.response_metadata.get('token_usage', {})
            self.total_tokens += usage.get('total_tokens', 0)
            print(f"[COST] 本次消耗: {usage.get('total_tokens', 0)} tokens")
            print(f"[COST] 累计消耗: {self.total_tokens} tokens")
        return state


# 使用自定义中间件
agent = create_react_agent(
    model=llm,
    tools=tools,
    middleware=[
        LoggingMiddleware(),
        CostTrackingMiddleware(),
        HumanApprovalMiddleware(tools_requiring_approval=["send_email"])
    ]
)
```

---

## 完整示例：构建一个安全的客服 Agent

下面是一个综合示例，展示如何使用多个中间件构建一个安全、可控的客服 Agent：

```python
from langchain_openai import ChatOpenAI
from langchain.agents import create_react_agent
from langchain.middleware import (
    HumanApprovalMiddleware,
    SummarizationMiddleware,
    PIIRedactionMiddleware
)

# 定义工具
tools = [
    query_order_status,      # 查询订单状态
    update_shipping_address, # 修改收货地址（需要确认）
    process_refund,          # 处理退款（需要确认）
    send_notification        # 发送通知（需要确认）
]

# 配置中间件
middlewares = [
    # 1. 隐私信息脱敏
    PIIRedactionMiddleware(
        patterns=[
            r'\b1[3-9]\d{9}\b',     # 手机号
            r'\b\d{17}[\dXx]\b',    # 身份证
        ]
    ),

    # 2. 消息摘要（长对话自动压缩）
    SummarizationMiddleware(
        max_messages=50,
        preserve_recent=5
    ),

    # 3. 敏感操作需人工确认
    HumanApprovalMiddleware(
        tools_requiring_approval=[
            "update_shipping_address",
            "process_refund",
            "send_notification"
        ]
    )
]

# 创建 Agent
llm = ChatOpenAI(model="gpt-4o", temperature=0)

agent = create_react_agent(
    model=llm,
    tools=tools,
    middleware=middlewares,
    prompt="你是一个专业的电商客服助手..."
)

# 运行
result = agent.invoke({
    "messages": [{"role": "user", "content": "我想修改订单 12345 的收货地址"}]
})
```

---

## 中间件 vs 其他方案

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **中间件** | 解耦、可复用、易测试 | 需要学习新概念 | 通用的横切关注点 |
| **直接修改节点** | 简单直接 | 代码耦合度高 | 一次性的特殊逻辑 |
| **条件边** | 灵活控制流程 | 图结构变复杂 | 流程分支决策 |
| **Subgraph** | 模块化封装 | 状态传递麻烦 | 复杂子流程 |

---

## 最佳实践

### 1. 中间件职责单一

每个中间件只做一件事：

```python
# 好的做法：职责单一
LoggingMiddleware()      # 只负责日志
CostMiddleware()         # 只负责成本追踪
PIIMiddleware()          # 只负责脱敏

# 不好的做法：职责混乱
class DoEverythingMiddleware:  # 一个中间件做所有事情
    def before_model(self, state, config):
        self.log_input()
        self.check_pii()
        self.validate_permission()
        self.track_cost()
        ...
```

### 2. 注意执行顺序

中间件的顺序很重要：

```python
# 推荐顺序
middlewares = [
    PIIRedactionMiddleware(),     # 1. 先脱敏
    LoggingMiddleware(),          # 2. 再记录（记录的是脱敏后的数据）
    SummarizationMiddleware(),    # 3. 然后压缩
    HumanApprovalMiddleware()     # 4. 最后人工确认
]
```

### 3. 错误处理

中间件中的错误应该优雅处理：

```python
class SafeMiddleware(BaseMiddleware):
    def before_model(self, state, config):
        try:
            # 你的逻辑
            pass
        except Exception as e:
            # 记录错误但不影响主流程
            logger.error(f"Middleware error: {e}")
        return state  # 确保总是返回 state
```

---

## 总结

Middleware 是 LangGraph 1.0 中一个强大的抽象，它让你能够：

| 功能 | 钩子 | 典型用途 |
|------|------|----------|
| **预处理** | `before_model` | 内容审核、权限检查、输入验证 |
| **后处理** | `after_model` | 人工审核、输出过滤、结果增强 |
| **请求修改** | `modify_model_request` | 动态工具、消息压缩、提示注入 |

通过合理使用中间件，你可以构建出**安全、可控、可观测**的 AI Agent 系统。

---

## 参考资源

- [LangChain 官方博客：Agent Middleware](https://blog.langchain.com/agent-middleware/)
- [LangChain/LangGraph 1.0 发布说明](https://blog.langchain.com/langchain-langgraph-1dot0/)
- [LangGraph 中间件文档](https://langchain-ai.github.io/langgraph/concepts/middleware/)
