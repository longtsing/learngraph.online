# LangGraph 两种循环模式对比：自修正 vs 工具调用

> 在构建 AI Agent 时，循环（Loop）是最常见的设计模式。但不是所有的循环都是一样的！本节将深入解析两种核心循环模式，帮助你选择正确的架构。

---

## 一、为什么理解循环模式很重要？

当你用 LangGraph 构建 Agent 时，你会发现很多场景都需要"回头"——但回头的原因可能完全不同：

| 场景 | 回头的原因 | 心态 |
|:---|:---|:---|
| 代码生成器 | 代码报错了，需要修复 | "我做错了，要重做" |
| 数据分析师 | 需要查询外部 API | "我缺东西，去拿一下" |
| 对话助手 | 用户信息不完整 | "问题不清，再问一遍" |
| 交易 Agent | 需要获取最新股价 | "我要更新数据" |

表面上看都是"循环"，但底层逻辑完全不同。理解这个区别，是写出优雅 LangGraph 代码的关键。

---

## 二、两种循环模式图解

### 模式一：自修正循环（Self-Correction Loop）

![自修正循环示意图](./1.png)

**特点**：
- 节点之间有**双向箭头**（虚线表示条件跳转）
- 流程可能**逆流回退**
- 目的是**质量控制**——"不合格就重做"

**典型场景**：
- ✍️ 代码生成：生成 → 测试 → 报错 → 重新生成
- 📝 写作助手：写稿 → 审核 → 不满意 → 重写
- 🎯 信息收集：问问题 → 处理回答 → 信息不全 → 继续追问

### 模式二：工具调用循环（Tool-Calling Loop）

![工具调用循环示意图](./2.png)

**特点**：
- Agent 节点连接到工具节点，工具**返回到同一个 Agent**
- 整体流向是**向前的**
- 目的是**数据获取**——"拿东西继续干活"

**典型场景**：
- 📊 市场分析：分析师 → 调用股价工具 → 拿到数据 → 继续分析
- 🔍 RAG 检索：Agent → 向量库查询 → 获取上下文 → 生成回答
- 🤖 函数调用：LLM → 调用 API → 处理返回值 → 下一步

---

## 三、核心区别一句话总结

```
┌─────────────────────────────────────────────────────────────────┐
│  自修正循环：🔧 "刚才做错了，我要重做"  ── 纠错导向          │
│  工具调用循环：📦 "缺个材料，拿完继续"  ── 数据导向          │
└─────────────────────────────────────────────────────────────────┘
```

更形象地说：
- **自修正循环** 像是一个**工匠**：在一个环节没做好之前，绝不进入下一个环节
- **工具调用循环** 像是一条**装配线**：每个工人调用工具干完活，就把结果传给下一个人

---

## 四、代码实战：自修正循环

**场景**：写代码 → 测试 → 报错就重写 → 直到通过

```python
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

# 1. 定义状态：我们需要追踪代码质量和重试次数
class AgentState(TypedDict):
    code: str
    error: bool      # 标记是否有错误
    attempts: int    # 记录重试次数

# 2. 定义节点
def generate_code(state: AgentState):
    """生成代码的节点"""
    print(f"✍️ [第 {state['attempts'] + 1} 次尝试] 正在写代码...")
    return {"code": "print('Hello World')", "attempts": state['attempts'] + 1}

def check_code(state: AgentState):
    """测试代码的节点"""
    # 模拟：前 2 次失败，第 3 次成功
    is_error = state['attempts'] < 3
    if is_error:
        print("❌ 测试失败：代码有 Bug！")
    else:
        print("✅ 测试通过：代码完美！")
    return {"error": is_error}

# 3. 定义条件判断逻辑（核心！）
def should_continue(state: AgentState):
    """决定是重试还是结束"""
    if state["error"]:
        return "retry"   # 🔙 有错误，返回上一步重做
    else:
        return "finish"  # 🚀 没错误，流程结束

# 4. 构建图
workflow = StateGraph(AgentState)

workflow.add_node("coder", generate_code)
workflow.add_node("tester", check_code)

workflow.add_edge(START, "coder")
workflow.add_edge("coder", "tester")

# 关键：条件边决定是否回退
workflow.add_conditional_edges(
    "tester",
    should_continue,
    {
        "retry": "coder",  # ← 指回上一个节点（形成闭环）
        "finish": END
    }
)

app = workflow.compile()

# 运行
print("--- 自修正循环演示 ---")
app.invoke({"attempts": 0, "error": False})
```

**运行结果**：

```text
--- 自修正循环演示 ---
✍️ [第 1 次尝试] 正在写代码...
❌ 测试失败：代码有 Bug！
✍️ [第 2 次尝试] 正在写代码...   ← 被打回重做
❌ 测试失败：代码有 Bug！
✍️ [第 3 次尝试] 正在写代码...   ← 又被打回
✅ 测试通过：代码完美！           ← 终于通过，结束
```

### 关键代码解读

```python
# 条件边的 mapping 决定了图的走向
workflow.add_conditional_edges(
    "tester",           # 从 tester 节点出发
    should_continue,    # 调用这个函数判断
    {
        "retry": "coder",  # 返回 "retry" → 回到 coder
        "finish": END      # 返回 "finish" → 结束
    }
)
```

**设计要点**：
- `should_continue` 函数检查 `state["error"]`
- 只要有错误，就返回 `"retry"`，指向前面的节点
- 这就形成了"死磕型"循环

---

## 五、代码实战：工具调用循环

**场景**：分析师需要查股价 → 调用工具 → 拿到数据继续分析 → 传给下一个人

```python
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

# 1. 定义状态：重点是数据是否已获取
class AgentState(TypedDict):
    messages: list
    data_collected: bool
    action: str

# 2. 定义节点
def market_analyst(state: AgentState):
    """市场分析师节点"""
    if not state.get("data_collected"):
        print("🤔 分析师：我需要查一下最新股价...")
        return {"action": "call_tool"}
    else:
        print("📝 分析师：拿到数据了，正在写报告，准备发给下一个人。")
        return {"action": "pass_to_next"}

def stock_tool(state: AgentState):
    """股价查询工具"""
    print("🛠️ 工具箱：正在查询 Google 股价... done。")
    return {"data_collected": True}  # 标记数据已获取

def news_analyst(state: AgentState):
    """新闻分析师节点"""
    print("📰 新闻分析师：收到报告，我开始分析新闻...")
    return {}

# 3. 定义路由逻辑
def router(state: AgentState):
    """决定去调用工具还是传给下一个人"""
    if state.get("action") == "call_tool":
        return "tool"
    else:
        return "next_person"

# 4. 构建图
workflow = StateGraph(AgentState)

workflow.add_node("analyst_1", market_analyst)
workflow.add_node("tools", stock_tool)
workflow.add_node("analyst_2", news_analyst)

workflow.add_edge(START, "analyst_1")

# 条件边：决定去工具还是下一个人
workflow.add_conditional_edges(
    "analyst_1",
    router,
    {
        "tool": "tools",            # 去工具节点
        "next_person": "analyst_2"  # 往下流转
    }
)

# 关键：工具用完后，无条件回到调用者
workflow.add_edge("tools", "analyst_1")
workflow.add_edge("analyst_2", END)

app = workflow.compile()

# 运行
print("--- 工具调用循环演示 ---")
app.invoke({"data_collected": False, "messages": []})
```

**运行结果**：

```text
--- 工具调用循环演示 ---
🤔 分析师：我需要查一下最新股价...
🛠️ 工具箱：正在查询 Google 股价... done。
📝 分析师：拿到数据了，正在写报告，准备发给下一个人。  ← 回来是为了完成工作
📰 新闻分析师：收到报告，我开始分析新闻...           ← 流水线继续向下
```

### 关键代码解读

```python
# 工具调用后，无条件返回调用者
workflow.add_edge("tools", "analyst_1")  # ← 这不是条件边！
```

**设计要点**：
- 工具节点用完后，**固定返回**到 Agent
- Agent 再次运行时，发现 `data_collected=True`，决定向下走
- 这是"拿东西回来"的模式，不是"重做"

---

## 六、两种模式对比总结

| 特征 | 自修正循环 | 工具调用循环 |
|:---|:---|:---|
| **循环目的** | 纠错（Fixing） | 采集（Fetching） |
| **心态** | "刚才做错了，我要重做" | "缺个材料，我去拿一下" |
| **流向** | 经常**逆流** (Backtrack) | 主要是**顺流**，偶有旁路 |
| **条件判断** | `if error: return "retry"` | `if need_tool: return "tool"` |
| **边类型** | 条件边指向**之前**的节点 | 固定边从工具**返回**调用者 |
| **典型应用** | 代码生成、写作、对话 | API 调用、RAG、数据分析 |

---

## 七、实际应用建议

### 何时使用自修正循环？

- ✅ 输出质量要求高，需要多次迭代
- ✅ 有明确的"成功/失败"判断标准
- ✅ Human-in-the-loop 场景
- ✅ 代码执行、测试驱动开发

### 何时使用工具调用循环？

- ✅ 需要调用外部 API 或工具
- ✅ RAG（检索增强生成）场景
- ✅ 多 Agent 协作流水线
- ✅ 数据采集和处理

### 可以混合使用吗？

当然可以！很多复杂 Agent 同时包含两种模式：

```
┌─────────────────────────────────────────────────────────────────┐
│                    混合模式示例                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ┌──────────┐     ┌──────────┐     ┌──────────┐               │
│    │  Coder   │────►│  Tester  │────►│ Reviewer │               │
│    └────┬─────┘     └────┬─────┘     └──────────┘               │
│         │                │                                       │
│         │                │ ← 自修正循环（测试失败就重写）        │
│         │                │                                       │
│         ▼                │                                       │
│    ┌──────────┐          │                                       │
│    │  Tools   │──────────┘ ← 工具调用循环（查文档、运行代码）    │
│    └──────────┘                                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 八、本节小结

1. **自修正循环**：用于质量控制，"做错就重来"
2. **工具调用循环**：用于数据获取，"拿完东西继续"
3. 两者在代码上的区别主要体现在**条件边的判断逻辑**
4. 实际应用中，两种模式经常**组合使用**

理解这两种基础模式，你就能设计出更清晰、更高效的 LangGraph 工作流！

---

> 💡 **下一步**：尝试修改上面的代码，添加最大重试次数限制，或者让工具调用支持多个工具的串联调用。
