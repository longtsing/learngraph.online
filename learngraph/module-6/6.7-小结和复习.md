# Module-6: è®°å¿†ç³»ç»Ÿ - å°ç»“å’Œå¤ä¹ 

> **å›é¡¾ä¸å±•æœ›**
>
> æ­å–œä½ å®Œæˆäº† Module-6 çš„å­¦ä¹ ï¼å¦‚æœè¯´å‰é¢çš„ç« èŠ‚è®©ä½ å­¦ä¼šäº†å¦‚ä½•æ„å»ºæ™ºèƒ½çš„å·¥ä½œæµï¼Œé‚£ä¹ˆæœ¬ç« åˆ™èµ‹äºˆäº†ä½ çš„ Agent **è®°å¿†å’Œç†è§£**çš„èƒ½åŠ›ã€‚
>
> åœ¨è¿™ä¸ªç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä»è®¤çŸ¥ç§‘å­¦çš„è§’åº¦å‡ºå‘ï¼Œç³»ç»Ÿåœ°å­¦ä¹ äº†å¦‚ä½•ä¸º LangGraph Agent æ„å»ºçŸ­æœŸè®°å¿†å’Œé•¿æœŸè®°å¿†ç³»ç»Ÿã€‚ä½ å·²ç»æŒæ¡äº† Store çš„ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µã€Profile ä¸ Collection çš„æ¶æ„å†³ç­–ã€Trustcall çš„å¢é‡æ›´æ–°æœºåˆ¶ï¼Œä»¥åŠå¦‚ä½•æ„å»ºèƒ½å¤Ÿè·¨ä¼šè¯è®°ä½ç”¨æˆ·ä¿¡æ¯çš„æ™ºèƒ½ Agentã€‚
>
> ä½†å­¦ä¹ æ°¸æ— æ­¢å¢ƒã€‚æœ¬ç« çš„çŸ¥è¯†å°†æˆä¸ºä½ æœªæ¥æ„å»ºæ›´å¤æ‚ AI ç³»ç»Ÿçš„åŸºçŸ³ã€‚è®©æˆ‘ä»¬é€šè¿‡ç³»ç»Ÿçš„å¤ä¹ å’Œå®è·µï¼Œå°†è¿™äº›çŸ¥è¯†å†…åŒ–ä¸ºä½ çš„æŠ€èƒ½ã€‚
>
> â€”â€” ä½ çš„ LangGraph å¯¼å¸ˆ

---

## ä¸€ã€å­¦ä¹ åœ°å›¾

è®©æˆ‘ä»¬é€šè¿‡ä¸€å¼ å®Œæ•´çš„çŸ¥è¯†åœ°å›¾ï¼Œå›é¡¾æœ¬ç« çš„æ ¸å¿ƒå†…å®¹ï¼š

```mermaid
graph TB
    A[Module-6: è®°å¿†ç³»ç»Ÿ] --> B[æ ¸å¿ƒæ¦‚å¿µ]
    A --> C[æŠ€æœ¯ç»„ä»¶]
    A --> D[æ¶æ„æ¨¡å¼]
    A --> E[å®æˆ˜åº”ç”¨]
    
    B --> B1[è®¤çŸ¥ç§‘å­¦åŸºç¡€]
    B --> B2[çŸ­æœŸ vs é•¿æœŸè®°å¿†]
    B --> B3[è®°å¿†ç±»å‹åˆ†ç±»]
    
    B1 --> B1a[è¯­ä¹‰è®°å¿†<br/>Semantic]
    B1 --> B1b[æƒ…èŠ‚è®°å¿†<br/>Episodic]
    B1 --> B1c[ç¨‹åºæ€§è®°å¿†<br/>Procedural]
    
    B2 --> B2a[Checkpointer<br/>ä¼šè¯å†…]
    B2 --> B2b[Store<br/>è·¨ä¼šè¯]
    
    C --> C1[LangGraph Store]
    C --> C2[Trustcall]
    C --> C3[Pydantic]
    
    C1 --> C1a[Namespace<br/>å‘½åç©ºé—´]
    C1 --> C1b[Key<br/>é”®]
    C1 --> C1c[Value<br/>å€¼å­—å…¸]
    C1 --> C1d[put/get/search<br/>åŸºæœ¬æ“ä½œ]
    
    C2 --> C2a[ç»“æ„åŒ–æå–]
    C2 --> C2b[JSON Patch<br/>å¢é‡æ›´æ–°]
    C2 --> C2c[enable_inserts<br/>æ’å…¥æ§åˆ¶]
    
    C3 --> C3a[BaseModel<br/>Schemaå®šä¹‰]
    C3 --> C3b[Field<br/>å­—æ®µæè¿°]
    C3 --> C3c[æ•°æ®éªŒè¯]
    
    D --> D1[Profileæ¨¡å¼]
    D --> D2[Collectionæ¨¡å¼]
    D --> D3[æ··åˆæ¶æ„]
    
    D1 --> D1a[å•ä¸€å¯¹è±¡<br/>å›ºå®šç»“æ„]
    D1 --> D1b[å¢é‡æ›´æ–°<br/>JSON Patch]
    D1 --> D1c[é€‚ç”¨åœºæ™¯<br/>ç”¨æˆ·èµ„æ–™/é…ç½®]
    
    D2 --> D2a[å¤šä¸ªç‹¬ç«‹é¡¹<br/>çµæ´»ç»“æ„]
    D2 --> D2b[UUIDé”®ç®¡ç†]
    D2 --> D2c[é€‚ç”¨åœºæ™¯<br/>ç¬”è®°/ä»»åŠ¡/äº‹ä»¶]
    
    E --> E1[è®°å¿†èŠå¤©æœºå™¨äºº]
    E --> E2[task_mAIstro Agent]
    E --> E3[å¤šç±»å‹è®°å¿†ååŒ]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
    style E fill:#f5e1ff
```

---

## äºŒã€æ ¸å¿ƒæŠ€æœ¯å¯¹æ¯”è¡¨

### 2.1 è®°å¿†ç³»ç»Ÿå…¨æ™¯å¯¹æ¯”

| ç»´åº¦ | çŸ­æœŸè®°å¿† | é•¿æœŸè®°å¿†ï¼ˆProfileï¼‰ | é•¿æœŸè®°å¿†ï¼ˆCollectionï¼‰ |
|------|---------|-------------------|---------------------|
| **æŠ€æœ¯ç»„ä»¶** | MemorySaver (Checkpointer) | InMemoryStore / PostgresStore | InMemoryStore / PostgresStore |
| **æ•°æ®ç»“æ„** | Graph State (TypedDict) | å•ä¸€ç»“æ„åŒ–å¯¹è±¡ | ç‹¬ç«‹é¡¹ç›®é›†åˆ |
| **å­˜å‚¨æ–¹å¼** | é€šè¿‡ thread_id | é€šè¿‡ namespace + å›ºå®škey | é€šè¿‡ namespace + UUID key |
| **ç”Ÿå‘½å‘¨æœŸ** | å•æ¬¡ä¼šè¯ | æŒä¹…åŒ–ï¼ˆè·¨ä¼šè¯ï¼‰ | æŒä¹…åŒ–ï¼ˆè·¨ä¼šè¯ï¼‰ |
| **å…¸å‹å†…å®¹** | å¯¹è¯å†å²ã€ä¸­é—´çŠ¶æ€ | ç”¨æˆ·èµ„æ–™ã€ç³»ç»Ÿé…ç½® | ç¬”è®°ã€ä»»åŠ¡ã€äº‹ä»¶è®°å½• |
| **æ›´æ–°æ–¹å¼** | è¿½åŠ æ¶ˆæ¯ | JSON Patch å¢é‡æ›´æ–° | æ–°å¢/ä¿®æ”¹/åˆ é™¤ç‹¬ç«‹é¡¹ |
| **Schemaè¦æ±‚** | TypedDict | Pydantic BaseModel | Pydantic BaseModel |
| **Trustcallå‚æ•°** | N/A | enable_inserts=False | enable_inserts=True |
| **é”®ç­–ç•¥** | N/A | å›ºå®šé”®ï¼ˆå¦‚ "user_profile"ï¼‰ | UUID é”® |
| **æ‰©å±•æ€§** | å— Graph State é™åˆ¶ | éœ€ä¿®æ”¹ Schema | æ— é™æ‰©å±• |
| **æŸ¥è¯¢å¤æ‚åº¦** | O(1) é€šè¿‡ thread_id | O(1) é€šè¿‡ key | O(n) search éå† |
| **é€‚ç”¨åœºæ™¯** | å•æ¬¡å¯¹è¯ä¸Šä¸‹æ–‡ | ç»“æ„åŒ–ä¸ªäººä¿¡æ¯ | å¼€æ”¾å¼ä¿¡æ¯æ”¶é›† |

### 2.2 æ•°æ®æå–æ–¹æ³•å¯¹æ¯”

| ç‰¹æ€§ | with_structured_output() | Trustcall (Profile) | Trustcall (Collection) |
|------|-------------------------|-------------------|---------------------|
| **ä¸»è¦ç”¨é€”** | ç»“æ„åŒ–è¾“å‡º | åˆ›å»º/æ›´æ–°å•ä¸€å¯¹è±¡ | åˆ›å»º/æ›´æ–°å¤šä¸ªå¯¹è±¡ |
| **åˆ›å»ºæ–°è®°å½•** | âœ… æ”¯æŒ | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| **æ›´æ–°ç°æœ‰è®°å½•** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒï¼ˆJSON Patchï¼‰ | âœ… æ”¯æŒï¼ˆJSON Patchï¼‰ |
| **å¹¶è¡Œåˆ›å»º** | âŒ å•ä¸ª | âŒ å•ä¸ª | âœ… å¤šä¸ª |
| **å¤æ‚Schema** | âš ï¸ å¯èƒ½å¤±è´¥ | âœ… æ›´å¥å£® | âœ… æ›´å¥å£® |
| **è‡ªæˆ‘ä¿®æ­£** | âŒ æ—  | âœ… æœ‰ | âœ… æœ‰ |
| **enable_inserts** | N/A | Falseï¼ˆé»˜è®¤ï¼‰ | Trueï¼ˆå¿…éœ€ï¼‰ |
| **è¿”å›æ ¼å¼** | å•ä¸ª Pydantic å¯¹è±¡ | `{"responses": [obj], "messages": [...]}` | `{"responses": [obj1, obj2, ...], "messages": [...]}` |
| **ä½¿ç”¨å¤æ‚åº¦** | ç®€å• | ä¸­ç­‰ | ä¸­ç­‰ |
| **ä»£ç ç¤ºä¾‹** | `model.with_structured_output(Schema)` | `create_extractor(model, tools=[Schema])` | `create_extractor(model, tools=[Schema], enable_inserts=True)` |

### 2.3 å­˜å‚¨åç«¯é€‰æ‹©

| ç»´åº¦ | InMemoryStore | PostgresStore | Redis (è‡ªå®šä¹‰) |
|------|--------------|--------------|---------------|
| **æŒä¹…åŒ–** | âŒ å†…å­˜ï¼ˆé‡å¯ä¸¢å¤±ï¼‰ | âœ… ç£ç›˜ï¼ˆæŒä¹…ï¼‰ | âš ï¸ æŒä¹…åŒ–é…ç½® |
| **æ€§èƒ½** | âš¡ æœ€å¿« | ğŸ¢ ç›¸å¯¹æ…¢ | âš¡ å¾ˆå¿« |
| **å®¹é‡** | å†…å­˜é™åˆ¶ï¼ˆGBï¼‰ | ç£ç›˜é™åˆ¶ï¼ˆTBï¼‰ | å†…å­˜é™åˆ¶ï¼ˆGBï¼‰ |
| **åˆ†å¸ƒå¼** | âŒ å•æœº | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| **äº‹åŠ¡æ”¯æŒ** | âŒ æ—  | âœ… ACID | âš ï¸ æœ‰é™ |
| **æŸ¥è¯¢èƒ½åŠ›** | åŸºç¡€ï¼ˆsearchï¼‰ | å¼ºå¤§ï¼ˆSQLï¼‰ | åŸºç¡€ï¼ˆscanï¼‰ |
| **ç´¢å¼•** | âŒ æ—  | âœ… æ”¯æŒ | âš ï¸ æœ‰é™ |
| **è®¾ç½®å¤æ‚åº¦** | ğŸŸ¢ ç®€å•ï¼ˆæ— éœ€é…ç½®ï¼‰ | ğŸŸ¡ ä¸­ç­‰ï¼ˆéœ€æ•°æ®åº“ï¼‰ | ğŸŸ¡ ä¸­ç­‰ï¼ˆéœ€Redisï¼‰ |
| **é€‚ç”¨åœºæ™¯** | å¼€å‘ã€æµ‹è¯•ã€åŸå‹ | ç”Ÿäº§ã€ä¼ä¸šåº”ç”¨ | é«˜æ€§èƒ½ç¼“å­˜ |
| **æˆæœ¬** | å…è´¹ï¼ˆå†…å­˜ï¼‰ | æ•°æ®åº“æˆæœ¬ | Redis æˆæœ¬ |
| **è¿ç§»éš¾åº¦** | N/A | ğŸŸ¢ APIå…¼å®¹ | ğŸŸ¡ éœ€å®ç°æ¥å£ |

---

## ä¸‰ã€æ ¸å¿ƒé—®é¢˜ä¸è¯¦è§£

### é—®é¢˜ 1ï¼šå®ç°ä¸€ä¸ªæ”¯æŒå¤šç”¨æˆ·çš„è®°å¿†èŠå¤©æœºå™¨äººï¼Œè¦æ±‚æ¯ä¸ªç”¨æˆ·æœ‰ç‹¬ç«‹çš„Profileå’Œå¯¹è¯å†å²

**éš¾åº¦**ï¼šâ­â­â­  
**æ¶‰åŠçŸ¥è¯†ç‚¹**ï¼šStoreã€Checkpointerã€Namespaceè®¾è®¡ã€ç”¨æˆ·éš”ç¦»

#### å®Œæ•´å®ç°

```python
from typing import TypedDict, Optional, List
from pydantic import BaseModel, Field
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.store.memory import InMemoryStore
from langgraph.prebuilt import ToolNode
from trustcall import create_extractor

# ========== 1. å®šä¹‰ Profile Schema ==========
class UserProfile(BaseModel):
    """ç”¨æˆ·èµ„æ–™"""
    user_name: Optional[str] = Field(description="ç”¨æˆ·çš„åå­—", default=None)
    user_location: Optional[str] = Field(description="ç”¨æˆ·çš„ä½ç½®", default=None)
    interests: List[str] = Field(description="ç”¨æˆ·çš„å…´è¶£åˆ—è¡¨", default_factory=list)
    preferences: Optional[str] = Field(description="ç”¨æˆ·çš„åå¥½è®¾ç½®", default=None)

# ========== 2. ç³»ç»Ÿæç¤ºè¯ ==========
SYSTEM_PROMPT = """You are a helpful personal assistant with memory.

Current user profile:
{profile}

Instructions:
- Use the user's name and information from their profile when appropriate
- Ask clarifying questions if you need more information
- Be friendly and personalized
"""

PROFILE_UPDATE_PROMPT = """Based on the conversation, extract or update the user's profile information.

Existing profile:
{existing_profile}

Extract any new information about:
- Name
- Location
- Interests
- Preferences
"""

# ========== 3. åˆå§‹åŒ–ç»„ä»¶ ==========
model = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# Profile æå–å™¨
profile_extractor = create_extractor(
    model,
    tools=[UserProfile],
    tool_choice="UserProfile"
)

# è®°å¿†å’Œå­˜å‚¨
checkpointer = MemorySaver()  # çŸ­æœŸè®°å¿†ï¼ˆå¯¹è¯å†å²ï¼‰
store = InMemoryStore()       # é•¿æœŸè®°å¿†ï¼ˆç”¨æˆ·èµ„æ–™ï¼‰

# ========== 4. Namespace è®¾è®¡ ==========
def get_profile_namespace(user_id: str):
    """è·å–ç”¨æˆ· Profile çš„å‘½åç©ºé—´"""
    return (user_id, "profile")

def get_profile_key():
    """Profile ä½¿ç”¨å›ºå®šé”®"""
    return "user_profile"

# ========== 5. è¾…åŠ©å‡½æ•° ==========
def load_user_profile(user_id: str, store: InMemoryStore) -> Optional[dict]:
    """åŠ è½½ç”¨æˆ·èµ„æ–™"""
    namespace = get_profile_namespace(user_id)
    key = get_profile_key()
    
    item = store.get(namespace, key)
    if item:
        return item.value
    return None

def save_user_profile(user_id: str, profile: dict, store: InMemoryStore):
    """ä¿å­˜ç”¨æˆ·èµ„æ–™"""
    namespace = get_profile_namespace(user_id)
    key = get_profile_key()
    store.put(namespace, key, profile)

def format_profile(profile: Optional[dict]) -> str:
    """æ ¼å¼åŒ– Profile ç”¨äºæ˜¾ç¤º"""
    if not profile:
        return "No profile information yet."
    
    parts = []
    if profile.get("user_name"):
        parts.append(f"Name: {profile['user_name']}")
    if profile.get("user_location"):
        parts.append(f"Location: {profile['user_location']}")
    if profile.get("interests"):
        parts.append(f"Interests: {', '.join(profile['interests'])}")
    if profile.get("preferences"):
        parts.append(f"Preferences: {profile['preferences']}")
    
    return "\n".join(parts) if parts else "No profile information yet."

# ========== 6. Graph èŠ‚ç‚¹ ==========
def call_model(state: MessagesState, config, store):
    """è°ƒç”¨æ¨¡å‹ç”Ÿæˆå›å¤"""
    # è·å–ç”¨æˆ· ID
    user_id = config["configurable"]["user_id"]
    
    # åŠ è½½ç”¨æˆ·èµ„æ–™
    profile = load_user_profile(user_id, store)
    profile_text = format_profile(profile)
    
    # æ„å»ºç³»ç»Ÿæ¶ˆæ¯
    system_msg = SystemMessage(content=SYSTEM_PROMPT.format(profile=profile_text))
    
    # è°ƒç”¨æ¨¡å‹
    response = model.invoke([system_msg] + state["messages"])
    
    return {"messages": [response]}

def should_update_profile(state: MessagesState) -> bool:
    """åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–° Profile"""
    # ç®€åŒ–é€»è¾‘ï¼šæ£€æŸ¥æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
    messages = state["messages"]
    if not messages:
        return False
    
    last_msg = messages[-1]
    if isinstance(last_msg, HumanMessage):
        content = last_msg.content.lower()
        # åŒ…å«ä¸ªäººä¿¡æ¯å…³é”®è¯
        keywords = ["my name", "i am", "i'm", "i live", "i like", "i prefer", "i enjoy"]
        return any(kw in content for kw in keywords)
    
    return False

def update_profile(state: MessagesState, config, store):
    """æ›´æ–°ç”¨æˆ·èµ„æ–™"""
    # è·å–ç”¨æˆ· ID
    user_id = config["configurable"]["user_id"]
    
    # åŠ è½½ç°æœ‰èµ„æ–™
    existing_profile = load_user_profile(user_id, store)
    
    # å‡†å¤‡ Trustcall çš„ existing å‚æ•°
    if existing_profile:
        existing_data = [("0", "UserProfile", existing_profile)]
    else:
        existing_data = None
    
    # æ„å»ºæç¤ºè¯
    system_msg = SystemMessage(content=PROFILE_UPDATE_PROMPT.format(
        existing_profile=format_profile(existing_profile)
    ))
    
    # ä½¿ç”¨ Trustcall æå–/æ›´æ–°èµ„æ–™
    result = profile_extractor.invoke({
        "messages": [system_msg] + state["messages"],
        "existing": existing_data
    })
    
    # ä¿å­˜æ›´æ–°åçš„èµ„æ–™
    if result["responses"]:
        updated_profile = result["responses"][0].model_dump()
        save_user_profile(user_id, updated_profile, store)
        print(f"[DEBUG] Updated profile for user {user_id}: {updated_profile}")
    
    return {}

# ========== 7. æ„å»º Graph ==========
workflow = StateGraph(MessagesState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("agent", call_model)
workflow.add_node("update_profile", update_profile)

# æ·»åŠ è¾¹
workflow.add_edge(START, "agent")

# æ¡ä»¶è¾¹ï¼šåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°èµ„æ–™
def route_after_agent(state: MessagesState):
    if should_update_profile(state):
        return "update_profile"
    return END

workflow.add_conditional_edges(
    "agent",
    route_after_agent,
    {
        "update_profile": "update_profile",
        END: END
    }
)

workflow.add_edge("update_profile", END)

# ç¼–è¯‘ï¼ˆæ³¨å…¥ checkpointer å’Œ storeï¼‰
app = workflow.compile(checkpointer=checkpointer, store=store)

# ========== 8. ä½¿ç”¨ç¤ºä¾‹ ==========

def chat(user_id: str, message: str, thread_id: str = "default"):
    """
    ä¸èŠå¤©æœºå™¨äººäº¤äº’
    
    Args:
        user_id: ç”¨æˆ·å”¯ä¸€æ ‡è¯†
        message: ç”¨æˆ·æ¶ˆæ¯
        thread_id: ä¼šè¯ IDï¼ˆç”¨äºåŒºåˆ†åŒä¸€ç”¨æˆ·çš„ä¸åŒå¯¹è¯ï¼‰
    """
    config = {
        "configurable": {
            "user_id": user_id,
            "thread_id": f"{user_id}_{thread_id}"  # ç»„åˆç”¨æˆ·IDå’Œä¼šè¯ID
        }
    }
    
    result = app.invoke(
        {"messages": [HumanMessage(content=message)]},
        config=config
    )
    
    # è¿”å›æœ€åä¸€æ¡ AI æ¶ˆæ¯
    return result["messages"][-1].content

# ========== 9. æµ‹è¯•å¤šç”¨æˆ·éš”ç¦» ==========

# ç”¨æˆ· 1 çš„å¯¹è¯
print("=== User 1 ===")
print(chat("user_1", "Hi, my name is Alice and I live in New York."))
print(chat("user_1", "I really enjoy reading and hiking."))
print(chat("user_1", "What do you know about me?"))

# ç”¨æˆ· 2 çš„å¯¹è¯
print("\n=== User 2 ===")
print(chat("user_2", "Hello, I'm Bob from San Francisco."))
print(chat("user_2", "I like coding and playing guitar."))
print(chat("user_2", "What's my name?"))

# ç”¨æˆ· 1 çš„æ–°ä¼šè¯ï¼ˆä½†åº”è¯¥è®°ä½ä¹‹å‰çš„ä¿¡æ¯ï¼‰
print("\n=== User 1 - New Session ===")
print(chat("user_1", "Do you remember where I live?", thread_id="session_2"))

# ========== 10. è°ƒè¯•ï¼šæŸ¥çœ‹å­˜å‚¨çš„æ•°æ® ==========

def debug_store():
    """è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰ç”¨æˆ·çš„èµ„æ–™"""
    print("\n=== Stored Profiles ===")
    
    # æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ·
    for user_id in ["user_1", "user_2"]:
        namespace = get_profile_namespace(user_id)
        key = get_profile_key()
        item = store.get(namespace, key)
        
        if item:
            print(f"\nUser: {user_id}")
            print(f"  Namespace: {namespace}")
            print(f"  Key: {key}")
            print(f"  Profile: {item.value}")
            print(f"  Created: {item.created_at}")
            print(f"  Updated: {item.updated_at}")
        else:
            print(f"\nUser: {user_id} - No profile")

debug_store()
```

#### è¿è¡Œç»“æœç¤ºä¾‹

```
=== User 1 ===
[DEBUG] Updated profile for user user_1: {'user_name': 'Alice', 'user_location': 'New York', 'interests': [], 'preferences': None}
Hello Alice! Nice to meet you. How can I help you today?

[DEBUG] Updated profile for user user_1: {'user_name': 'Alice', 'user_location': 'New York', 'interests': ['reading', 'hiking'], 'preferences': None}
That's wonderful! Reading and hiking are great hobbies. Do you have any favorite books or hiking trails?

Based on your profile, Alice, I know that:
- Your name is Alice
- You live in New York
- You enjoy reading and hiking

Is there anything else you'd like me to remember about you?

=== User 2 ===
[DEBUG] Updated profile for user user_2: {'user_name': 'Bob', 'user_location': 'San Francisco', 'interests': [], 'preferences': None}
Hello Bob! Welcome from San Francisco. How can I assist you today?

[DEBUG] Updated profile for user user_2: {'user_name': 'Bob', 'user_location': 'San Francisco', 'interests': ['coding', 'playing guitar'], 'preferences': None}
That's great, Bob! Coding and guitar are both creative pursuits. What kind of coding do you do?

Your name is Bob!

=== User 1 - New Session ===
Yes, Alice! You live in New York. Is there something specific about New York you'd like to talk about?

=== Stored Profiles ===

User: user_1
  Namespace: ('user_1', 'profile')
  Key: user_profile
  Profile: {'user_name': 'Alice', 'user_location': 'New York', 'interests': ['reading', 'hiking'], 'preferences': None}
  Created: 2024-11-05T10:30:15
  Updated: 2024-11-05T10:30:20

User: user_2
  Namespace: ('user_2', 'profile')
  Key: user_profile
  Profile: {'user_name': 'Bob', 'user_location': 'San Francisco', 'interests': ['coding', 'playing guitar'], 'preferences': None}
  Created: 2024-11-05T10:30:25
  Updated: 2024-11-05T10:30:30
```

#### å…³é”®å®ç°è¦ç‚¹

1. **å¤šç”¨æˆ·éš”ç¦»**ï¼š
   ```python
   # æ¯ä¸ªç”¨æˆ·æœ‰ç‹¬ç«‹çš„ namespace
   namespace = (user_id, "profile")  # user_1 å’Œ user_2 å®Œå…¨éš”ç¦»
   
   # æ¯ä¸ªç”¨æˆ·çš„æ¯ä¸ªä¼šè¯æœ‰ç‹¬ç«‹çš„ thread_id
   thread_id = f"{user_id}_{thread_id}"
   ```

2. **çŸ­æœŸ + é•¿æœŸè®°å¿†ååŒ**ï¼š
   ```python
   # çŸ­æœŸè®°å¿†ï¼šå¯¹è¯å†å²ï¼ˆé€šè¿‡ checkpointerï¼‰
   # è‡ªåŠ¨ä¿å­˜åœ¨ thread_id å¯¹åº”çš„ checkpoint ä¸­
   
   # é•¿æœŸè®°å¿†ï¼šç”¨æˆ·èµ„æ–™ï¼ˆé€šè¿‡ storeï¼‰
   # æ‰‹åŠ¨ä¿å­˜åœ¨ (user_id, "profile") namespace ä¸­
   ```

3. **æ™ºèƒ½æ›´æ–°è§¦å‘**ï¼š
   ```python
   def should_update_profile(state):
       # åªåœ¨ç”¨æˆ·æä¾›ä¸ªäººä¿¡æ¯æ—¶æ›´æ–°
       # é¿å…æ¯æ¬¡å¯¹è¯éƒ½è°ƒç”¨ Trustcallï¼ˆèŠ‚çœæˆæœ¬ï¼‰
       keywords = ["my name", "i am", "i live", "i like"]
       return any(kw in last_message.lower() for kw in keywords)
   ```

4. **å¢é‡æ›´æ–°**ï¼š
   ```python
   # Trustcall è‡ªåŠ¨ä½¿ç”¨ JSON Patch
   # åªæ›´æ–°å˜åŒ–çš„å­—æ®µï¼Œä¿ç•™å…¶ä»–å­—æ®µ
   existing_data = [("0", "UserProfile", existing_profile)]
   result = profile_extractor.invoke({
       "messages": messages,
       "existing": existing_data  # ä¼ å…¥ç°æœ‰æ•°æ®
   })
   ```

---

### é—®é¢˜ 2ï¼šä½¿ç”¨ Collection æ¨¡å¼å®ç°ä¸€ä¸ªå­¦ä¹ ç¬”è®°ç³»ç»Ÿï¼Œæ”¯æŒæ·»åŠ ã€æœç´¢å’Œåˆ†ç±»ç¬”è®°

**éš¾åº¦**ï¼šâ­â­â­â­  
**æ¶‰åŠçŸ¥è¯†ç‚¹**ï¼šCollectionã€UUIDã€enable_insertsã€è¯­ä¹‰æœç´¢ã€åˆ†ç±»

#### å®Œæ•´å®ç°

```python
from typing import List, Optional
from pydantic import BaseModel, Field
from datetime import datetime
import uuid
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_core.messages import SystemMessage, HumanMessage
from langgraph.store.memory import InMemoryStore
from trustcall import create_extractor
import numpy as np

# ========== 1. å®šä¹‰ç¬”è®° Schema ==========
class Note(BaseModel):
    """å­¦ä¹ ç¬”è®°"""
    content: str = Field(description="ç¬”è®°çš„ä¸»è¦å†…å®¹")
    topic: Optional[str] = Field(
        description="ç¬”è®°çš„ä¸»é¢˜åˆ†ç±»ï¼Œå¦‚ï¼šPythonã€æœºå™¨å­¦ä¹ ã€æ•°æ®ç»“æ„ç­‰",
        default=None
    )
    tags: List[str] = Field(
        description="ç¬”è®°çš„æ ‡ç­¾åˆ—è¡¨",
        default_factory=list
    )
    importance: Optional[int] = Field(
        description="é‡è¦æ€§è¯„åˆ†ï¼ˆ1-5ï¼‰ï¼Œ5 æœ€é‡è¦",
        default=3,
        ge=1,
        le=5
    )

# ========== 2. åˆå§‹åŒ–ç»„ä»¶ ==========
model = ChatOpenAI(model="gpt-4o-mini", temperature=0)
embeddings = OpenAIEmbeddings()  # ç”¨äºè¯­ä¹‰æœç´¢
store = InMemoryStore()

# Note æå–å™¨ï¼ˆCollection æ¨¡å¼ï¼‰
note_extractor = create_extractor(
    model,
    tools=[Note],
    tool_choice="Note",
    enable_inserts=True  # å…³é”®ï¼å…è®¸æ’å…¥å¤šä¸ªç¬”è®°
)

# ========== 3. Namespace è®¾è®¡ ==========
def get_notes_namespace(user_id: str):
    """ç¬”è®°çš„å‘½åç©ºé—´"""
    return (user_id, "notes")

def get_note_embeddings_namespace(user_id: str):
    """ç¬”è®°å‘é‡çš„å‘½åç©ºé—´ï¼ˆç”¨äºè¯­ä¹‰æœç´¢ï¼‰"""
    return (user_id, "note_embeddings")

# ========== 4. ç¬”è®°ç®¡ç†ç±» ==========
class NoteManager:
    """å­¦ä¹ ç¬”è®°ç®¡ç†å™¨"""
    
    def __init__(self, user_id: str, store: InMemoryStore):
        self.user_id = user_id
        self.store = store
        self.notes_ns = get_notes_namespace(user_id)
        self.embeddings_ns = get_note_embeddings_namespace(user_id)
    
    def add_note(self, content: str, topic: Optional[str] = None, 
                 tags: List[str] = None, importance: int = 3) -> str:
        """
        æ·»åŠ ä¸€æ¡ç¬”è®°
        
        Returns:
            note_id: ç¬”è®°çš„å”¯ä¸€ ID
        """
        # ç”Ÿæˆå”¯ä¸€ ID
        note_id = str(uuid.uuid4())
        
        # åˆ›å»ºç¬”è®°
        note_data = {
            "content": content,
            "topic": topic,
            "tags": tags or [],
            "importance": importance,
            "created_at": datetime.now().isoformat()
        }
        
        # ä¿å­˜ç¬”è®°
        self.store.put(self.notes_ns, note_id, note_data)
        
        # ç”Ÿæˆå¹¶ä¿å­˜å‘é‡ï¼ˆç”¨äºè¯­ä¹‰æœç´¢ï¼‰
        embedding = embeddings.embed_query(content)
        self.store.put(self.embeddings_ns, note_id, {"embedding": embedding})
        
        return note_id
    
    def add_notes_from_text(self, text: str) -> List[str]:
        """
        ä»æ–‡æœ¬ä¸­æ™ºèƒ½æå–å¤šæ¡ç¬”è®°
        
        ä½¿ç”¨ Trustcall è‡ªåŠ¨æå–å’Œåˆ†ç±»
        """
        # æå–æŒ‡ä»¤
        system_msg = SystemMessage(content="""
        Extract structured notes from the following text.
        
        For each piece of information:
        - Identify the main content
        - Classify the topic (e.g., Python, Machine Learning, Data Structures)
        - Extract relevant tags
        - Assess importance (1-5)
        
        Extract multiple notes if the text contains multiple distinct pieces of information.
        """)
        
        # è°ƒç”¨ Trustcall æå–
        result = note_extractor.invoke({
            "messages": [system_msg, HumanMessage(content=text)]
        })
        
        # ä¿å­˜æå–çš„ç¬”è®°
        note_ids = []
        for note in result["responses"]:
            note_id = self.add_note(
                content=note.content,
                topic=note.topic,
                tags=note.tags,
                importance=note.importance
            )
            note_ids.append(note_id)
        
        return note_ids
    
    def get_note(self, note_id: str) -> Optional[dict]:
        """è·å–ç‰¹å®šç¬”è®°"""
        item = self.store.get(self.notes_ns, note_id)
        return item.value if item else None
    
    def get_all_notes(self) -> List[dict]:
        """è·å–æ‰€æœ‰ç¬”è®°"""
        items = self.store.search(self.notes_ns)
        notes = []
        for item in items:
            note = item.value
            note["id"] = item.key  # æ·»åŠ  ID
            notes.append(note)
        return notes
    
    def search_by_topic(self, topic: str) -> List[dict]:
        """æŒ‰ä¸»é¢˜æœç´¢ç¬”è®°"""
        all_notes = self.get_all_notes()
        return [note for note in all_notes if note.get("topic") == topic]
    
    def search_by_tag(self, tag: str) -> List[dict]:
        """æŒ‰æ ‡ç­¾æœç´¢ç¬”è®°"""
        all_notes = self.get_all_notes()
        return [note for note in all_notes if tag in note.get("tags", [])]
    
    def search_by_importance(self, min_importance: int) -> List[dict]:
        """æŒ‰é‡è¦æ€§æœç´¢ç¬”è®°"""
        all_notes = self.get_all_notes()
        return [
            note for note in all_notes 
            if note.get("importance", 0) >= min_importance
        ]
    
    def semantic_search(self, query: str, top_k: int = 5) -> List[dict]:
        """
        è¯­ä¹‰æœç´¢ï¼šæ‰¾åˆ°ä¸æŸ¥è¯¢æœ€ç›¸å…³çš„ç¬”è®°
        
        ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦
        """
        # ç”ŸæˆæŸ¥è¯¢å‘é‡
        query_embedding = embeddings.embed_query(query)
        
        # è·å–æ‰€æœ‰ç¬”è®°åŠå…¶å‘é‡
        all_notes = self.get_all_notes()
        all_embeddings = self.store.search(self.embeddings_ns)
        
        # è®¡ç®—ç›¸ä¼¼åº¦
        similarities = []
        for note in all_notes:
            note_id = note["id"]
            # æ‰¾åˆ°å¯¹åº”çš„å‘é‡
            embedding_item = self.store.get(self.embeddings_ns, note_id)
            if embedding_item:
                note_embedding = embedding_item.value["embedding"]
                # ä½™å¼¦ç›¸ä¼¼åº¦
                similarity = np.dot(query_embedding, note_embedding) / (
                    np.linalg.norm(query_embedding) * np.linalg.norm(note_embedding)
                )
                similarities.append((note, similarity))
        
        # æ’åºå¹¶è¿”å› top_k
        similarities.sort(key=lambda x: x[1], reverse=True)
        return [note for note, _ in similarities[:top_k]]
    
    def get_statistics(self) -> dict:
        """è·å–ç¬”è®°ç»Ÿè®¡ä¿¡æ¯"""
        all_notes = self.get_all_notes()
        
        # æŒ‰ä¸»é¢˜åˆ†ç»„
        topics = {}
        for note in all_notes:
            topic = note.get("topic", "Uncategorized")
            topics[topic] = topics.get(topic, 0) + 1
        
        # æŒ‰é‡è¦æ€§åˆ†ç»„
        importance_dist = {i: 0 for i in range(1, 6)}
        for note in all_notes:
            imp = note.get("importance", 3)
            importance_dist[imp] += 1
        
        return {
            "total_notes": len(all_notes),
            "topics": topics,
            "importance_distribution": importance_dist
        }
    
    def update_note(self, note_id: str, updates: dict):
        """æ›´æ–°ç¬”è®°"""
        existing = self.get_note(note_id)
        if existing:
            merged = {**existing, **updates}
            self.store.put(self.notes_ns, note_id, merged)
            
            # å¦‚æœå†…å®¹æ›´æ–°ï¼Œé‡æ–°ç”Ÿæˆå‘é‡
            if "content" in updates:
                embedding = embeddings.embed_query(updates["content"])
                self.store.put(self.embeddings_ns, note_id, {"embedding": embedding})
    
    def delete_note(self, note_id: str):
        """åˆ é™¤ç¬”è®°"""
        # Store æ²¡æœ‰ delete æ–¹æ³•ï¼Œä½†å¯ä»¥é€šè¿‡ put None å®ç°
        # æˆ–è€…ä¿ç•™æ•°æ®ä½†æ ‡è®°ä¸ºå·²åˆ é™¤
        existing = self.get_note(note_id)
        if existing:
            existing["deleted"] = True
            existing["deleted_at"] = datetime.now().isoformat()
            self.store.put(self.notes_ns, note_id, existing)

# ========== 5. ä½¿ç”¨ç¤ºä¾‹ ==========

# åˆ›å»ºç¬”è®°ç®¡ç†å™¨
note_mgr = NoteManager("user_alice", store)

# ========== æµ‹è¯• 1ï¼šæ‰‹åŠ¨æ·»åŠ ç¬”è®° ==========
print("=== Test 1: Manual Add ===")
id1 = note_mgr.add_note(
    content="Python uses indentation to define code blocks instead of braces.",
    topic="Python",
    tags=["syntax", "basics"],
    importance=4
)
print(f"Added note: {id1}")

id2 = note_mgr.add_note(
    content="A binary tree is a tree data structure where each node has at most two children.",
    topic="Data Structures",
    tags=["tree", "algorithms"],
    importance=5
)
print(f"Added note: {id2}")

# ========== æµ‹è¯• 2ï¼šä»æ–‡æœ¬æ™ºèƒ½æå–ç¬”è®° ==========
print("\n=== Test 2: Extract from Text ===")
learning_text = """
Today I learned about gradient descent in machine learning. 
It's an optimization algorithm used to minimize the cost function by iteratively moving in the direction of steepest descent.
Also learned that learning rate is a crucial hyperparameter that controls the step size.

In Python, list comprehensions provide a concise way to create lists.
For example: squares = [x**2 for x in range(10)]
"""

note_ids = note_mgr.add_notes_from_text(learning_text)
print(f"Extracted {len(note_ids)} notes")

# ========== æµ‹è¯• 3ï¼šæœç´¢ç¬”è®° ==========
print("\n=== Test 3: Search ===")

# æŒ‰ä¸»é¢˜æœç´¢
python_notes = note_mgr.search_by_topic("Python")
print(f"\nPython notes: {len(python_notes)}")
for note in python_notes:
    print(f"  - {note['content'][:50]}...")

# æŒ‰æ ‡ç­¾æœç´¢
tree_notes = note_mgr.search_by_tag("tree")
print(f"\nTree notes: {len(tree_notes)}")
for note in tree_notes:
    print(f"  - {note['content'][:50]}...")

# æŒ‰é‡è¦æ€§æœç´¢
important_notes = note_mgr.search_by_importance(min_importance=4)
print(f"\nImportant notes (>=4): {len(important_notes)}")

# ========== æµ‹è¯• 4ï¼šè¯­ä¹‰æœç´¢ ==========
print("\n=== Test 4: Semantic Search ===")
query = "How do optimization algorithms work?"
similar_notes = note_mgr.semantic_search(query, top_k=3)
print(f"\nTop 3 notes similar to '{query}':")
for i, note in enumerate(similar_notes, 1):
    print(f"{i}. {note['content'][:60]}...")
    print(f"   Topic: {note.get('topic', 'N/A')}, Importance: {note.get('importance', 'N/A')}")

# ========== æµ‹è¯• 5ï¼šç»Ÿè®¡ä¿¡æ¯ ==========
print("\n=== Test 5: Statistics ===")
stats = note_mgr.get_statistics()
print(f"\nTotal notes: {stats['total_notes']}")
print("\nNotes by topic:")
for topic, count in stats['topics'].items():
    print(f"  {topic}: {count}")
print("\nImportance distribution:")
for imp, count in stats['importance_distribution'].items():
    print(f"  {imp} stars: {count}")

# ========== æµ‹è¯• 6ï¼šæ›´æ–°å’Œåˆ é™¤ ==========
print("\n=== Test 6: Update & Delete ===")
# æ›´æ–°ç¬”è®°
note_mgr.update_note(id1, {"importance": 5, "tags": ["syntax", "basics", "fundamentals"]})
updated = note_mgr.get_note(id1)
print(f"\nUpdated note importance: {updated['importance']}")
print(f"Updated tags: {updated['tags']}")

# åˆ é™¤ç¬”è®°
note_mgr.delete_note(id2)
deleted = note_mgr.get_note(id2)
print(f"\nDeleted note status: deleted={deleted.get('deleted', False)}")
```

#### è¿è¡Œç»“æœç¤ºä¾‹

```
=== Test 1: Manual Add ===
Added note: e1c4e5ab-ab0f-4cbb-822d-f29240a983af
Added note: f2d5b6bc-bc10-5dcc-933e-g40351b094bg

=== Test 2: Extract from Text ===
Extracted 3 notes

=== Test 3: Search ===

Python notes: 2
  - Python uses indentation to define code blocks ...
  - In Python, list comprehensions provide a concis...

Tree notes: 1
  - A binary tree is a tree data structure where ea...

Important notes (>=4): 3

=== Test 4: Semantic Search ===

Top 3 notes similar to 'How do optimization algorithms work?':
1. Gradient descent is an optimization algorithm used to minimi...
   Topic: Machine Learning, Importance: 5
2. Learning rate is a crucial hyperparameter that controls the ...
   Topic: Machine Learning, Importance: 4
3. A binary tree is a tree data structure where each node has a...
   Topic: Data Structures, Importance: 5

=== Test 5: Statistics ===

Total notes: 5

Notes by topic:
  Python: 2
  Data Structures: 1
  Machine Learning: 2

Importance distribution:
  1 stars: 0
  2 stars: 0
  3 stars: 0
  4 stars: 2
  5 stars: 3

=== Test 6: Update & Delete ===

Updated note importance: 5
Updated tags: ['syntax', 'basics', 'fundamentals']

Deleted note status: deleted=True
```

#### å…³é”®å®ç°è¦ç‚¹

1. **Collection æ¨¡å¼æ ¸å¿ƒ**ï¼š
   ```python
   # æ¯æ¡ç¬”è®°ä½¿ç”¨ UUID
   note_id = str(uuid.uuid4())
   
   # ç‹¬ç«‹ä¿å­˜
   store.put(notes_namespace, note_id, note_data)
   
   # enable_inserts=True å…è®¸æ‰¹é‡æå–
   note_extractor = create_extractor(
       model,
       tools=[Note],
       enable_inserts=True  # å…³é”®ï¼
   )
   ```

2. **è¯­ä¹‰æœç´¢å®ç°**ï¼š
   ```python
   # ä¸ºæ¯æ¡ç¬”è®°ç”Ÿæˆå‘é‡
   embedding = embeddings.embed_query(content)
   store.put(embeddings_ns, note_id, {"embedding": embedding})
   
   # æœç´¢æ—¶è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
   similarity = np.dot(query_emb, note_emb) / (
       np.linalg.norm(query_emb) * np.linalg.norm(note_emb)
   )
   ```

3. **å¤šç»´åº¦æœç´¢**ï¼š
   ```python
   # å…³é”®è¯æœç´¢ï¼ˆtopic, tagï¼‰
   # é‡è¦æ€§ç­›é€‰ï¼ˆimportanceï¼‰
   # è¯­ä¹‰æœç´¢ï¼ˆembeddingï¼‰
   # å¯ç»„åˆä½¿ç”¨
   ```

4. **æ™ºèƒ½æå–**ï¼š
   ```python
   # Trustcall è‡ªåŠ¨ä»é•¿æ–‡æœ¬ä¸­æå–å¤šæ¡ç»“æ„åŒ–ç¬”è®°
   result = note_extractor.invoke({
       "messages": [system_msg, user_text]
   })
   # responses åŒ…å«å¤šä¸ª Note å¯¹è±¡
   ```

---

### é—®é¢˜ 3ï¼šè®¾è®¡ä¸€ä¸ªä¼ä¸šçº§çš„è®°å¿†æ¶æ„ï¼Œæ”¯æŒå¤šç§Ÿæˆ·ã€æƒé™æ§åˆ¶å’Œæ•°æ®éš”ç¦»

**éš¾åº¦**ï¼šâ­â­â­â­â­  
**æ¶‰åŠçŸ¥è¯†ç‚¹**ï¼šMulti-tenancyã€Namespace è®¾è®¡ã€æƒé™æ§åˆ¶ã€PostgresStore

#### æ¶æ„è®¾è®¡

```python
from typing import Optional, List, Dict, Set
from enum import Enum
from dataclasses import dataclass
from datetime import datetime
from langgraph.store.postgres import PostgresStore
from pydantic import BaseModel, Field
import hashlib

# ========== 1. æƒé™æ¨¡å‹ ==========
class Permission(str, Enum):
    """æƒé™æšä¸¾"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"

class Role(str, Enum):
    """è§’è‰²æšä¸¾"""
    OWNER = "owner"          # æ‹¥æœ‰è€…ï¼šæ‰€æœ‰æƒé™
    ADMIN = "admin"          # ç®¡ç†å‘˜ï¼šè¯»å†™åˆ é™¤
    MEMBER = "member"        # æˆå‘˜ï¼šè¯»å†™
    VIEWER = "viewer"        # æŸ¥çœ‹è€…ï¼šåªè¯»

# è§’è‰²æƒé™æ˜ å°„
ROLE_PERMISSIONS: Dict[Role, Set[Permission]] = {
    Role.OWNER: {Permission.READ, Permission.WRITE, Permission.DELETE, Permission.ADMIN},
    Role.ADMIN: {Permission.READ, Permission.WRITE, Permission.DELETE},
    Role.MEMBER: {Permission.READ, Permission.WRITE},
    Role.VIEWER: {Permission.READ}
}

# ========== 2. å¤šç§Ÿæˆ·æ¨¡å‹ ==========
@dataclass
class Tenant:
    """ç§Ÿæˆ·ï¼ˆç»„ç»‡ï¼‰"""
    tenant_id: str
    name: str
    created_at: datetime
    settings: dict

@dataclass
class User:
    """ç”¨æˆ·"""
    user_id: str
    email: str
    name: str
    tenant_id: str  # æ‰€å±ç§Ÿæˆ·

@dataclass
class UserRole:
    """ç”¨æˆ·-è§’è‰²å…³è”"""
    user_id: str
    tenant_id: str
    role: Role

# ========== 3. Namespace è®¾è®¡æ¨¡å¼ ==========
class NamespaceBuilder:
    """
    ä¼ä¸šçº§ Namespace è®¾è®¡
    
    ç»“æ„ï¼š(tenant_id, resource_type, resource_id, ...)
    """
    
    @staticmethod
    def tenant_metadata(tenant_id: str):
        """ç§Ÿæˆ·å…ƒæ•°æ®"""
        return (tenant_id, "metadata", "tenant")
    
    @staticmethod
    def user_profile(tenant_id: str, user_id: str):
        """ç”¨æˆ·èµ„æ–™"""
        return (tenant_id, "users", user_id, "profile")
    
    @staticmethod
    def user_memories(tenant_id: str, user_id: str):
        """ç”¨æˆ·è®°å¿†é›†åˆ"""
        return (tenant_id, "users", user_id, "memories")
    
    @staticmethod
    def user_permissions(tenant_id: str, user_id: str):
        """ç”¨æˆ·æƒé™"""
        return (tenant_id, "users", user_id, "permissions")
    
    @staticmethod
    def shared_knowledge(tenant_id: str, category: str):
        """å…±äº«çŸ¥è¯†åº“"""
        return (tenant_id, "shared", "knowledge", category)
    
    @staticmethod
    def team_data(tenant_id: str, team_id: str, data_type: str):
        """å›¢é˜Ÿæ•°æ®"""
        return (tenant_id, "teams", team_id, data_type)

# ========== 4. è®¿é—®æ§åˆ¶å±‚ ==========
class AccessControlError(Exception):
    """è®¿é—®æ§åˆ¶å¼‚å¸¸"""
    pass

class AccessController:
    """è®¿é—®æ§åˆ¶å™¨"""
    
    def __init__(self, store: PostgresStore):
        self.store = store
        # ç¼“å­˜æƒé™ä»¥æå‡æ€§èƒ½
        self._permission_cache: Dict[str, Set[Permission]] = {}
    
    def get_user_role(self, user_id: str, tenant_id: str) -> Optional[Role]:
        """è·å–ç”¨æˆ·åœ¨ç§Ÿæˆ·ä¸­çš„è§’è‰²"""
        ns = NamespaceBuilder.user_permissions(tenant_id, user_id)
        item = self.store.get(ns, "role")
        
        if item and "role" in item.value:
            return Role(item.value["role"])
        return None
    
    def get_user_permissions(self, user_id: str, tenant_id: str) -> Set[Permission]:
        """è·å–ç”¨æˆ·æƒé™"""
        # æ£€æŸ¥ç¼“å­˜
        cache_key = f"{user_id}_{tenant_id}"
        if cache_key in self._permission_cache:
            return self._permission_cache[cache_key]
        
        # è·å–è§’è‰²
        role = self.get_user_role(user_id, tenant_id)
        if not role:
            return set()
        
        # è·å–æƒé™
        permissions = ROLE_PERMISSIONS.get(role, set())
        
        # ç¼“å­˜
        self._permission_cache[cache_key] = permissions
        
        return permissions
    
    def check_permission(
        self, 
        user_id: str, 
        tenant_id: str, 
        required_permission: Permission
    ) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æŒ‡å®šæƒé™"""
        permissions = self.get_user_permissions(user_id, tenant_id)
        return required_permission in permissions
    
    def require_permission(
        self, 
        user_id: str, 
        tenant_id: str, 
        required_permission: Permission
    ):
        """è¦æ±‚ç”¨æˆ·æœ‰æŒ‡å®šæƒé™ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸"""
        if not self.check_permission(user_id, tenant_id, required_permission):
            raise AccessControlError(
                f"User {user_id} lacks {required_permission.value} permission in tenant {tenant_id}"
            )
    
    def grant_role(
        self, 
        granter_id: str, 
        grantee_id: str, 
        tenant_id: str, 
        role: Role
    ):
        """æˆäºˆè§’è‰²ï¼ˆéœ€è¦ ADMIN æƒé™ï¼‰"""
        # æ£€æŸ¥æˆäºˆè€…æƒé™
        self.require_permission(granter_id, tenant_id, Permission.ADMIN)
        
        # æˆäºˆè§’è‰²
        ns = NamespaceBuilder.user_permissions(tenant_id, grantee_id)
        self.store.put(ns, "role", {
            "role": role.value,
            "granted_by": granter_id,
            "granted_at": datetime.now().isoformat()
        })
        
        # æ¸…é™¤ç¼“å­˜
        cache_key = f"{grantee_id}_{tenant_id}"
        if cache_key in self._permission_cache:
            del self._permission_cache[cache_key]

# ========== 5. æ•°æ®è®¿é—®å±‚ï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰ ==========
class SecureMemoryStore:
    """å®‰å…¨çš„è®°å¿†å­˜å‚¨ï¼ˆé›†æˆè®¿é—®æ§åˆ¶ï¼‰"""
    
    def __init__(self, store: PostgresStore, access_controller: AccessController):
        self.store = store
        self.ac = access_controller
    
    def put(
        self, 
        user_id: str, 
        tenant_id: str, 
        namespace: tuple, 
        key: str, 
        value: dict
    ):
        """ä¿å­˜æ•°æ®ï¼ˆéœ€è¦ WRITE æƒé™ï¼‰"""
        # éªŒè¯æƒé™
        self.ac.require_permission(user_id, tenant_id, Permission.WRITE)
        
        # éªŒè¯ namespace å±äºè¯¥ç§Ÿæˆ·
        if namespace[0] != tenant_id:
            raise AccessControlError(f"Namespace {namespace} does not belong to tenant {tenant_id}")
        
        # æ·»åŠ å®¡è®¡ä¿¡æ¯
        value["_meta"] = {
            "created_by": user_id,
            "created_at": datetime.now().isoformat(),
            "tenant_id": tenant_id
        }
        
        # ä¿å­˜
        self.store.put(namespace, key, value)
    
    def get(
        self, 
        user_id: str, 
        tenant_id: str, 
        namespace: tuple, 
        key: str
    ) -> Optional[dict]:
        """è·å–æ•°æ®ï¼ˆéœ€è¦ READ æƒé™ï¼‰"""
        # éªŒè¯æƒé™
        self.ac.require_permission(user_id, tenant_id, Permission.READ)
        
        # éªŒè¯ namespace
        if namespace[0] != tenant_id:
            raise AccessControlError(f"Namespace {namespace} does not belong to tenant {tenant_id}")
        
        # è·å–
        item = self.store.get(namespace, key)
        return item.value if item else None
    
    def search(
        self, 
        user_id: str, 
        tenant_id: str, 
        namespace: tuple
    ) -> List[dict]:
        """æœç´¢æ•°æ®ï¼ˆéœ€è¦ READ æƒé™ï¼‰"""
        # éªŒè¯æƒé™
        self.ac.require_permission(user_id, tenant_id, Permission.READ)
        
        # éªŒè¯ namespace
        if namespace[0] != tenant_id:
            raise AccessControlError(f"Namespace {namespace} does not belong to tenant {tenant_id}")
        
        # æœç´¢
        items = self.store.search(namespace)
        return [item.value for item in items]
    
    def delete(
        self, 
        user_id: str, 
        tenant_id: str, 
        namespace: tuple, 
        key: str
    ):
        """åˆ é™¤æ•°æ®ï¼ˆéœ€è¦ DELETE æƒé™ï¼‰"""
        # éªŒè¯æƒé™
        self.ac.require_permission(user_id, tenant_id, Permission.DELETE)
        
        # éªŒè¯ namespace
        if namespace[0] != tenant_id:
            raise AccessControlError(f"Namespace {namespace} does not belong to tenant {tenant_id}")
        
        # è½¯åˆ é™¤ï¼ˆæ ‡è®°ä¸ºå·²åˆ é™¤ï¼‰
        existing = self.store.get(namespace, key)
        if existing:
            value = existing.value
            value["_deleted"] = True
            value["_deleted_by"] = user_id
            value["_deleted_at"] = datetime.now().isoformat()
            self.store.put(namespace, key, value)

# ========== 6. æ•°æ®éš”ç¦»ç­–ç•¥ ==========
class DataIsolationPolicy:
    """æ•°æ®éš”ç¦»ç­–ç•¥"""
    
    @staticmethod
    def encrypt_sensitive_data(data: dict, tenant_secret: str) -> dict:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        # ç®€åŒ–ç¤ºä¾‹ï¼šä½¿ç”¨ tenant_secret åŠ å¯†
        # å®é™…åº”ä½¿ç”¨ AES/RSA ç­‰åŠ å¯†ç®—æ³•
        encrypted = data.copy()
        
        if "sensitive_fields" in data:
            for field in data["sensitive_fields"]:
                if field in encrypted:
                    # ç®€å•å“ˆå¸Œç¤ºä¾‹ï¼ˆå®é™…åº”ä½¿ç”¨å¯é€†åŠ å¯†ï¼‰
                    hash_input = f"{tenant_secret}_{encrypted[field]}"
                    encrypted[field] = hashlib.sha256(hash_input.encode()).hexdigest()
        
        return encrypted
    
    @staticmethod
    def anonymize_for_analytics(data: dict) -> dict:
        """ä¸ºåˆ†æè„±æ•æ•°æ®"""
        anonymized = data.copy()
        
        # ç§»é™¤ä¸ªäººèº«ä»½ä¿¡æ¯
        pii_fields = ["email", "phone", "address", "ssn"]
        for field in pii_fields:
            if field in anonymized:
                anonymized[field] = "***REDACTED***"
        
        return anonymized

# ========== 7. å®¡è®¡æ—¥å¿— ==========
class AuditLogger:
    """å®¡è®¡æ—¥å¿—"""
    
    def __init__(self, store: PostgresStore):
        self.store = store
    
    def log_access(
        self, 
        user_id: str, 
        tenant_id: str, 
        action: str, 
        resource: str, 
        success: bool,
        metadata: Optional[dict] = None
    ):
        """è®°å½•è®¿é—®æ—¥å¿—"""
        log_ns = (tenant_id, "audit_logs")
        log_id = f"{datetime.now().isoformat()}_{user_id}_{action}"
        
        log_entry = {
            "user_id": user_id,
            "tenant_id": tenant_id,
            "action": action,
            "resource": resource,
            "success": success,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        }
        
        self.store.put(log_ns, log_id, log_entry)
    
    def get_user_activity(
        self, 
        tenant_id: str, 
        user_id: str, 
        start_date: Optional[datetime] = None
    ) -> List[dict]:
        """è·å–ç”¨æˆ·æ´»åŠ¨æ—¥å¿—"""
        log_ns = (tenant_id, "audit_logs")
        all_logs = self.store.search(log_ns)
        
        # ç­›é€‰ç”¨æˆ·æ—¥å¿—
        user_logs = [
            log.value for log in all_logs 
            if log.value.get("user_id") == user_id
        ]
        
        # æŒ‰æ—¥æœŸç­›é€‰
        if start_date:
            user_logs = [
                log for log in user_logs
                if datetime.fromisoformat(log["timestamp"]) >= start_date
            ]
        
        return user_logs

# ========== 8. ä½¿ç”¨ç¤ºä¾‹ ==========

# åˆå§‹åŒ–å­˜å‚¨ï¼ˆä½¿ç”¨ PostgresStoreï¼‰
postgres_store = PostgresStore(
    connection_string="postgresql://user:pass@localhost/enterprise_db"
)

# åˆå§‹åŒ–è®¿é—®æ§åˆ¶
access_controller = AccessController(postgres_store)
secure_store = SecureMemoryStore(postgres_store, access_controller)
audit_logger = AuditLogger(postgres_store)

# ========== åœºæ™¯ 1ï¼šè®¾ç½®ç»„ç»‡å’Œç”¨æˆ· ==========

# åˆ›å»ºç§Ÿæˆ·
tenant_id = "acme_corp"
tenant_ns = NamespaceBuilder.tenant_metadata(tenant_id)
postgres_store.put(tenant_ns, "info", {
    "name": "Acme Corporation",
    "created_at": datetime.now().isoformat(),
    "settings": {
        "data_retention_days": 90,
        "encryption_enabled": True
    }
})

# åˆ›å»ºç”¨æˆ·å¹¶æˆäºˆè§’è‰²
users = [
    ("alice", "alice@acme.com", Role.OWNER),
    ("bob", "bob@acme.com", Role.ADMIN),
    ("charlie", "charlie@acme.com", Role.MEMBER),
    ("david", "david@acme.com", Role.VIEWER)
]

for user_id, email, role in users:
    # ä¿å­˜ç”¨æˆ·ä¿¡æ¯
    user_ns = NamespaceBuilder.user_profile(tenant_id, user_id)
    postgres_store.put(user_ns, "info", {
        "email": email,
        "tenant_id": tenant_id
    })
    
    # æˆäºˆè§’è‰²
    perm_ns = NamespaceBuilder.user_permissions(tenant_id, user_id)
    postgres_store.put(perm_ns, "role", {
        "role": role.value,
        "granted_at": datetime.now().isoformat()
    })

# ========== åœºæ™¯ 2ï¼šæƒé™éªŒè¯ ==========

print("=== Scenario 2: Permission Check ===")

# Alice (OWNER) å¯ä»¥å†™å…¥
try:
    ns = NamespaceBuilder.user_memories(tenant_id, "alice")
    secure_store.put("alice", tenant_id, ns, "note_1", {
        "content": "Important business note"
    })
    print("âœ… Alice can write")
    audit_logger.log_access("alice", tenant_id, "write", "note_1", True)
except AccessControlError as e:
    print(f"âŒ Alice write failed: {e}")

# David (VIEWER) ä¸èƒ½å†™å…¥
try:
    ns = NamespaceBuilder.user_memories(tenant_id, "david")
    secure_store.put("david", tenant_id, ns, "note_2", {
        "content": "Trying to write"
    })
    print("âœ… David can write")
except AccessControlError as e:
    print(f"âŒ David write failed: {e}")
    audit_logger.log_access("david", tenant_id, "write", "note_2", False, {"error": str(e)})

# David å¯ä»¥è¯»å–
try:
    ns = NamespaceBuilder.user_memories(tenant_id, "alice")
    data = secure_store.get("david", tenant_id, ns, "note_1")
    print(f"âœ… David can read: {data['content']}")
    audit_logger.log_access("david", tenant_id, "read", "note_1", True)
except AccessControlError as e:
    print(f"âŒ David read failed: {e}")

# ========== åœºæ™¯ 3ï¼šè·¨ç§Ÿæˆ·éš”ç¦» ==========

print("\n=== Scenario 3: Tenant Isolation ===")

# åˆ›å»ºå¦ä¸€ä¸ªç§Ÿæˆ·
other_tenant_id = "rival_corp"

# Alice ä¸èƒ½è®¿é—®å…¶ä»–ç§Ÿæˆ·çš„æ•°æ®
try:
    ns = NamespaceBuilder.user_memories(other_tenant_id, "alice")
    secure_store.get("alice", tenant_id, ns, "note_1")  # tenant_id ä¸åŒ¹é…
    print("âŒ Cross-tenant access succeeded (should fail!)")
except AccessControlError as e:
    print(f"âœ… Cross-tenant access blocked: {e}")

# ========== åœºæ™¯ 4ï¼šè§’è‰²ç®¡ç† ==========

print("\n=== Scenario 4: Role Management ===")

# Bob (ADMIN) æˆäºˆ Charlie ADMIN è§’è‰²
try:
    access_controller.grant_role("bob", "charlie", tenant_id, Role.ADMIN)
    print("âœ… Bob granted ADMIN role to Charlie")
    
    # éªŒè¯ Charlie ç°åœ¨æœ‰ DELETE æƒé™
    has_delete = access_controller.check_permission("charlie", tenant_id, Permission.DELETE)
    print(f"âœ… Charlie has DELETE permission: {has_delete}")
except AccessControlError as e:
    print(f"âŒ Role grant failed: {e}")

# Charlie (MEMBER) ä¸èƒ½æˆäºˆè§’è‰²ï¼ˆæ²¡æœ‰ ADMIN æƒé™ï¼‰
try:
    # é‡ç½® Charlie ä¸º MEMBER
    perm_ns = NamespaceBuilder.user_permissions(tenant_id, "charlie")
    postgres_store.put(perm_ns, "role", {"role": Role.MEMBER.value})
    access_controller._permission_cache.clear()  # æ¸…é™¤ç¼“å­˜
    
    access_controller.grant_role("charlie", "david", tenant_id, Role.ADMIN)
    print("âŒ Charlie granted role (should fail!)")
except AccessControlError as e:
    print(f"âœ… Non-admin role grant blocked: {e}")

# ========== åœºæ™¯ 5ï¼šå®¡è®¡æ—¥å¿— ==========

print("\n=== Scenario 5: Audit Logs ===")

# æŸ¥çœ‹ Alice çš„æ´»åŠ¨
alice_logs = audit_logger.get_user_activity(tenant_id, "alice")
print(f"\nAlice's activity ({len(alice_logs)} events):")
for log in alice_logs[:3]:  # åªæ˜¾ç¤ºå‰3æ¡
    print(f"  - {log['action']} on {log['resource']} at {log['timestamp']}")

# æŸ¥çœ‹ David çš„æ´»åŠ¨
david_logs = audit_logger.get_user_activity(tenant_id, "david")
print(f"\nDavid's activity ({len(david_logs)} events):")
for log in david_logs:
    status = "âœ…" if log['success'] else "âŒ"
    print(f"  {status} {log['action']} on {log['resource']}")
```

#### è¿è¡Œç»“æœç¤ºä¾‹

```
=== Scenario 2: Permission Check ===
âœ… Alice can write
âŒ David write failed: User david lacks write permission in tenant acme_corp
âœ… David can read: Important business note

=== Scenario 3: Tenant Isolation ===
âœ… Cross-tenant access blocked: Namespace ('rival_corp', 'users', 'alice', 'memories') does not belong to tenant acme_corp

=== Scenario 4: Role Management ===
âœ… Bob granted ADMIN role to Charlie
âœ… Charlie has DELETE permission: True
âœ… Non-admin role grant blocked: User charlie lacks admin permission in tenant acme_corp

=== Scenario 5: Audit Logs ===

Alice's activity (1 events):
  - write on note_1 at 2024-11-05T14:30:00

David's activity (2 events):
  âŒ write on note_2
  âœ… read on note_1
```

#### æ¶æ„è¦ç‚¹æ€»ç»“

1. **å¤šç§Ÿæˆ·éš”ç¦»**ï¼š
   - Namespace ç¬¬ä¸€å±‚å¿…é¡»æ˜¯ `tenant_id`
   - æ‰€æœ‰æ“ä½œéƒ½éªŒè¯ namespace å±äºæ­£ç¡®çš„ç§Ÿæˆ·
   - æ•°æ®ç‰©ç†éš”ç¦»æˆ–é€»è¾‘éš”ç¦»

2. **æƒé™æ§åˆ¶**ï¼š
   - RBAC (Role-Based Access Control)
   - è§’è‰²-æƒé™æ˜ å°„
   - ç»†ç²’åº¦æƒé™æ£€æŸ¥ï¼ˆREAD/WRITE/DELETE/ADMINï¼‰

3. **å®¡è®¡æ—¥å¿—**ï¼š
   - è®°å½•æ‰€æœ‰è®¿é—®ï¼ˆæˆåŠŸå’Œå¤±è´¥ï¼‰
   - å¯è¿½æº¯ç”¨æˆ·æ´»åŠ¨
   - åˆè§„æ€§è¦æ±‚ï¼ˆGDPRã€SOC2ï¼‰

4. **æ•°æ®å®‰å…¨**ï¼š
   - æ•æ„Ÿæ•°æ®åŠ å¯†
   - è½¯åˆ é™¤ï¼ˆä¿ç•™å®¡è®¡è®°å½•ï¼‰
   - æ•°æ®è„±æ•ï¼ˆç”¨äºåˆ†æï¼‰

5. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - æƒé™ç¼“å­˜
   - ç´¢å¼•ä¼˜åŒ–ï¼ˆPostgreSQLï¼‰
   - æ‰¹é‡æ“ä½œ

---

ï¼ˆé—®é¢˜4-10 çš„å‚è€ƒç­”æ¡ˆå°†åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­å‘ˆç°ï¼‰

### é—®é¢˜ 4ï¼šProfile vs Collection é€‰æ‹©å†³ç­– - è¯·åˆ†æä»¥ä¸‹åœºæ™¯å¹¶ç»™å‡ºå»ºè®®

**éš¾åº¦**ï¼šâ­â­â­  
**åœºæ™¯åˆ†æé¢˜**

#### åœºæ™¯ Aï¼šç”µå•†ç½‘ç«™ç”¨æˆ·ç³»ç»Ÿ

**éœ€æ±‚**ï¼š
- ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ï¼šå§“åã€é‚®ç®±ã€ç”µè¯ã€åœ°å€
- ç”¨æˆ·æµè§ˆå†å²
- ç”¨æˆ·æ”¶è—å•†å“åˆ—è¡¨
- ç”¨æˆ·åå¥½è®¾ç½®ï¼ˆè¯­è¨€ã€è´§å¸ã€é€šçŸ¥ï¼‰

**åˆ†æä¸å»ºè®®**ï¼š

```python
# æ¨èæ¶æ„ï¼šProfile + Collection æ··åˆ

# ========== Profileï¼šç»“æ„åŒ–çš„å›ºå®šä¿¡æ¯ ==========
class UserProfile(BaseModel):
    """ç”¨æˆ·åŸºæœ¬èµ„æ–™ - ä½¿ç”¨ Profile"""
    name: str
    email: str
    phone: Optional[str]
    default_address: Optional[str]
    preferences: UserPreferences

class UserPreferences(BaseModel):
    """åå¥½è®¾ç½® - åµŒå¥—åœ¨ Profile ä¸­"""
    language: str = "en"
    currency: str = "USD"
    email_notifications: bool = True
    sms_notifications: bool = False

# ä¿å­˜æ–¹å¼ï¼š
namespace = (user_id, "profile")
key = "user_profile"  # å›ºå®šé”®
store.put(namespace, key, profile.model_dump())

# ========== Collectionï¼šå¼€æ”¾å¼çš„å†å²è®°å½• ==========
class BrowsingHistory(BaseModel):
    """æµè§ˆå†å² - ä½¿ç”¨ Collection"""
    product_id: str
    product_name: str
    viewed_at: datetime
    duration_seconds: int

class FavoriteItem(BaseModel):
    """æ”¶è—å•†å“ - ä½¿ç”¨ Collection"""
    product_id: str
    product_name: str
    added_at: datetime
    notes: Optional[str]

# ä¿å­˜æ–¹å¼ï¼š
import uuid

# æµè§ˆå†å²
namespace = (user_id, "browsing_history")
key = str(uuid.uuid4())
store.put(namespace, key, history_item.model_dump())

# æ”¶è—åˆ—è¡¨
namespace = (user_id, "favorites")
key = str(uuid.uuid4())
store.put(namespace, key, favorite_item.model_dump())
```

**å†³ç­–ç†ç”±**ï¼š

| æ•°æ®ç±»å‹ | æ¨¡å¼é€‰æ‹© | åŸå›  |
|---------|---------|------|
| ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ | Profile | å›ºå®šå­—æ®µï¼Œå¢é‡æ›´æ–° |
| åå¥½è®¾ç½® | Profileï¼ˆåµŒå¥—ï¼‰ | ç»“æ„åŒ–é…ç½®ï¼Œç»å¸¸æ›´æ–°ç‰¹å®šå­—æ®µ |
| æµè§ˆå†å² | Collection | æ— é™å¢é•¿ï¼Œæ¯æ¬¡æµè§ˆæ˜¯ç‹¬ç«‹äº‹ä»¶ |
| æ”¶è—åˆ—è¡¨ | Collection | åŠ¨æ€å¢åˆ ï¼Œæ¯ä¸ªå•†å“ç‹¬ç«‹ç®¡ç† |

---

#### åœºæ™¯ Bï¼šåœ¨çº¿æ•™è‚²å¹³å°å­¦ä¹ ç³»ç»Ÿ

**éœ€æ±‚**ï¼š
- å­¦ç”Ÿæ¡£æ¡ˆï¼šå§“åã€å¹´çº§ã€å­¦å·
- å­¦ä¹ è¿›åº¦ï¼šæ¯é—¨è¯¾ç¨‹çš„å®Œæˆç™¾åˆ†æ¯”
- å­¦ä¹ ç¬”è®°
- ç»ƒä¹ é¢˜é”™é¢˜è®°å½•

**åˆ†æä¸å»ºè®®**ï¼š

```python
# ========== Profileï¼šå­¦ç”Ÿæ¡£æ¡ˆå’Œè¿›åº¦ ==========
class StudentProfile(BaseModel):
    """å­¦ç”Ÿæ¡£æ¡ˆ - Profile"""
    student_id: str
    name: str
    grade: int
    enrollment_date: datetime

class CourseProgress(BaseModel):
    """è¯¾ç¨‹è¿›åº¦ - Profileï¼ˆç»“æ„åŒ–ï¼‰"""
    course_id: str
    completion_percentage: int
    last_accessed: datetime
    quiz_scores: List[int]

# ä½¿ç”¨åµŒå¥— Profile æˆ–è€… Collectionï¼Ÿ
# é€‰æ‹©ï¼šCollectionï¼ˆå› ä¸ºè¯¾ç¨‹æ•°é‡å¯èƒ½å˜åŒ–ï¼‰

# ========== Collectionï¼šç¬”è®°å’Œé”™é¢˜ ==========
class StudyNote(BaseModel):
    """å­¦ä¹ ç¬”è®° - Collection"""
    course_id: str
    lesson_id: str
    content: str
    created_at: datetime

class WrongAnswer(BaseModel):
    """é”™é¢˜è®°å½• - Collection"""
    question_id: str
    student_answer: str
    correct_answer: str
    explanation: str
    reviewed: bool = False
```

**å†³ç­–è¦ç‚¹**ï¼š

1. **å­¦ç”Ÿæ¡£æ¡ˆ**ï¼šProfileï¼ˆåŸºæœ¬ä¿¡æ¯å˜åŒ–å°‘ï¼‰
2. **è¯¾ç¨‹è¿›åº¦**ï¼šCollectionï¼ˆæ¯é—¨è¯¾æ˜¯ç‹¬ç«‹é¡¹ï¼‰
3. **å­¦ä¹ ç¬”è®°**ï¼šCollectionï¼ˆæŒç»­å¢é•¿ï¼‰
4. **é”™é¢˜è®°å½•**ï¼šCollectionï¼ˆéœ€è¦æ ‡è®°å’Œå¤ä¹ ï¼‰

---

#### åœºæ™¯ Cï¼šåŒ»ç–—å¥åº·è®°å½•ç³»ç»Ÿ

**éœ€æ±‚**ï¼š
- æ‚£è€…åŸºæœ¬ä¿¡æ¯
- ç—…å²è®°å½•
- å°±è¯Šè®°å½•
- å¤„æ–¹è®°å½•
- è¿‡æ•ä¿¡æ¯

**åˆ†æä¸å»ºè®®**ï¼š

```python
# ========== Profileï¼šæ‚£è€…åŸºæœ¬ä¿¡æ¯ ==========
class PatientProfile(BaseModel):
    """æ‚£è€…èµ„æ–™ - Profile"""
    patient_id: str
    name: str
    date_of_birth: datetime
    gender: str
    blood_type: str
    emergency_contact: str
    
    # é‡è¦ï¼šè¿‡æ•ä¿¡æ¯è™½ç„¶å¯èƒ½æœ‰å¤šä¸ªï¼Œä½†å±äºå…³é”®åŒ»ç–—ä¿¡æ¯
    # åº”è¯¥åœ¨ Profile ä¸­ç»´æŠ¤ï¼ˆå¿«é€Ÿè®¿é—®ï¼‰
    allergies: List[str]  # ä½œä¸ºåˆ—è¡¨å­—æ®µ
    chronic_conditions: List[str]

# ========== Collectionï¼šå†å²è®°å½• ==========
class MedicalVisit(BaseModel):
    """å°±è¯Šè®°å½• - Collection"""
    visit_id: str
    visit_date: datetime
    doctor_id: str
    chief_complaint: str
    diagnosis: str
    treatment_plan: str

class Prescription(BaseModel):
    """å¤„æ–¹è®°å½• - Collection"""
    prescription_id: str
    visit_id: str
    medication_name: str
    dosage: str
    duration_days: int
    issued_date: datetime
```

**ç‰¹æ®Šè€ƒè™‘**ï¼š

1. **è¿‡æ•ä¿¡æ¯**ï¼šè™½ç„¶å¯èƒ½æœ‰å¤šä¸ªï¼Œä½†åº”æ”¾åœ¨ Profile ä¸­
   - åŸå› ï¼šéœ€è¦å¿«é€Ÿè®¿é—®ï¼ˆæ€¥æ•‘åœºæ™¯ï¼‰
   - ä½¿ç”¨ `List[str]` å­—æ®µè€Œé Collection

2. **å°±è¯Šè®°å½•**ï¼šå¿…é¡»ä½¿ç”¨ Collection
   - åŸå› ï¼šæŒç»­å¢é•¿ï¼Œæ¯æ¬¡å°±è¯Šç‹¬ç«‹
   - éœ€è¦æŒ‰æ—¶é—´æŸ¥è¯¢

3. **å¤„æ–¹è®°å½•**ï¼šCollection
   - åŸå› ï¼šå…³è”åˆ°å°±è¯Šè®°å½•
   - éœ€è¦è¿½æº¯å†å²å¤„æ–¹

---

#### å†³ç­–æµç¨‹å›¾

```mermaid
graph TD
    A[éœ€è¦å­˜å‚¨çš„ä¿¡æ¯] --> B{ä¿¡æ¯æ•°é‡å›ºå®šå—?}
    B -->|æ˜¯| C{å­—æ®µç»“æ„å›ºå®šå—?}
    B -->|å¦| D[Collection]
    
    C -->|æ˜¯| E{æ›´æ–°é¢‘ç‡é«˜å—?}
    C -->|å¦| D
    
    E -->|æ˜¯| F{æ›´æ–°æ˜¯å¢é‡çš„å—?}
    E -->|å¦| G[Profile]
    
    F -->|æ˜¯| G
    F -->|å¦| D
    
    G --> H[ä½¿ç”¨ Profile æ¨¡å¼]
    D --> I[ä½¿ç”¨ Collection æ¨¡å¼]
    
    H --> J{æ˜¯å¦æœ‰åµŒå¥—åˆ—è¡¨?}
    J -->|æ˜¯| K{åˆ—è¡¨é¡¹æ•°é‡æœ‰é™ä¸”é‡è¦?}
    K -->|æ˜¯| L[ä½œä¸º Profile çš„ List å­—æ®µ]
    K -->|å¦| M[æ‹†åˆ†ä¸º Collection]
    
    style H fill:#90EE90
    style I fill:#87CEEB
    style L fill:#FFD700
    style M fill:#87CEEB
```

---

### é—®é¢˜ 5ï¼šä½¿ç”¨ Trustcall å¤„ç†å¤æ‚åµŒå¥— Schema çš„æœ€ä½³å®è·µ

**éš¾åº¦**ï¼šâ­â­â­â­  
**æ¶‰åŠçŸ¥è¯†ç‚¹**ï¼šTrustcallã€å¤æ‚ Schemaã€JSON Patch

#### é—®é¢˜åœºæ™¯

å‡è®¾ä½ éœ€è¦ç®¡ç†ä¸€ä¸ªç”¨æˆ·çš„å®Œæ•´ç¤¾äº¤æ¡£æ¡ˆï¼ŒåŒ…æ‹¬ï¼š
- åŸºæœ¬ä¿¡æ¯
- å¤šä¸ªç¤¾äº¤åª’ä½“è´¦å·
- å…´è¶£çˆ±å¥½ï¼ˆåˆ†ç±»ï¼‰
- èŒä¸šä¿¡æ¯ï¼ˆåŒ…æ‹¬å·¥ä½œç»å†ï¼‰

**å¤æ‚åµŒå¥— Schema**ï¼š

```python
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime

# ========== åµŒå¥— Schema å®šä¹‰ ==========
class SocialMediaAccount(BaseModel):
    """ç¤¾äº¤åª’ä½“è´¦å·"""
    platform: str = Field(description="å¹³å°åç§°ï¼Œå¦‚ Twitter, LinkedIn")
    username: str
    follower_count: Optional[int] = None
    verified: bool = False

class InterestCategory(BaseModel):
    """å…´è¶£åˆ†ç±»"""
    category: str = Field(description="åˆ†ç±»ï¼Œå¦‚ Technology, Sports")
    interests: List[str] = Field(description="è¯¥åˆ†ç±»ä¸‹çš„å…·ä½“å…´è¶£")

class WorkExperience(BaseModel):
    """å·¥ä½œç»å†"""
    company: str
    position: str
    start_date: str  # ISOæ ¼å¼æ—¥æœŸ
    end_date: Optional[str] = None  # None è¡¨ç¤ºå½“å‰å·¥ä½œ
    description: Optional[str] = None

class UserSocialProfile(BaseModel):
    """å®Œæ•´çš„ç”¨æˆ·ç¤¾äº¤æ¡£æ¡ˆ"""
    # åŸºæœ¬ä¿¡æ¯
    name: str
    bio: Optional[str] = None
    
    # åµŒå¥—åˆ—è¡¨
    social_accounts: List[SocialMediaAccount] = Field(default_factory=list)
    interest_categories: List[InterestCategory] = Field(default_factory=list)
    work_history: List[WorkExperience] = Field(default_factory=list)
```

#### æœ€ä½³å®è·µ 1ï¼šåˆ†è§£å¤æ‚ Schema

**é—®é¢˜**ï¼šå¤æ‚åµŒå¥— Schema å®¹æ˜“å¯¼è‡´ LLM æå–å¤±è´¥æˆ–ä¸å‡†ç¡®

**è§£å†³æ–¹æ¡ˆ**ï¼šåˆ†æ­¥æå–

```python
from trustcall import create_extractor
from langchain_openai import ChatOpenAI

model = ChatOpenAI(model="gpt-4o", temperature=0)  # ä½¿ç”¨æ›´å¼ºå¤§çš„æ¨¡å‹

# ========== æ­¥éª¤ 1ï¼šæå–åŸºæœ¬ä¿¡æ¯ ==========
class BasicInfo(BaseModel):
    name: str
    bio: Optional[str] = None

basic_extractor = create_extractor(
    model,
    tools=[BasicInfo],
    tool_choice="BasicInfo"
)

# ========== æ­¥éª¤ 2ï¼šæå–ç¤¾äº¤è´¦å· ==========
social_extractor = create_extractor(
    model,
    tools=[SocialMediaAccount],
    tool_choice="SocialMediaAccount",
    enable_inserts=True  # å…è®¸æå–å¤šä¸ªè´¦å·
)

# ========== æ­¥éª¤ 3ï¼šæå–å…´è¶£åˆ†ç±» ==========
interest_extractor = create_extractor(
    model,
    tools=[InterestCategory],
    tool_choice="InterestCategory",
    enable_inserts=True
)

# ========== æ­¥éª¤ 4ï¼šæå–å·¥ä½œç»å† ==========
work_extractor = create_extractor(
    model,
    tools=[WorkExperience],
    tool_choice="WorkExperience",
    enable_inserts=True
)
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```python
from langchain_core.messages import SystemMessage, HumanMessage

user_text = """
I'm Alice Johnson, a software engineer passionate about AI and open source.
I'm active on Twitter (@alice_codes) with 5000 followers, and LinkedIn (alice-johnson) where I'm verified.
I love technology (especially Python and Machine Learning) and sports (tennis and hiking).
I currently work at TechCorp as a Senior Engineer since 2022, and previously worked at StartupXYZ as a Junior Developer from 2020 to 2022.
"""

# æ­¥éª¤ 1ï¼šåŸºæœ¬ä¿¡æ¯
basic_result = basic_extractor.invoke({
    "messages": [
        SystemMessage(content="Extract the user's basic information."),
        HumanMessage(content=user_text)
    ]
})
basic_info = basic_result["responses"][0].model_dump()
print("Basic Info:", basic_info)

# æ­¥éª¤ 2ï¼šç¤¾äº¤è´¦å·
social_result = social_extractor.invoke({
    "messages": [
        SystemMessage(content="Extract all social media accounts mentioned."),
        HumanMessage(content=user_text)
    ]
})
social_accounts = [acc.model_dump() for acc in social_result["responses"]]
print("\nSocial Accounts:", social_accounts)

# æ­¥éª¤ 3ï¼šå…´è¶£åˆ†ç±»
interest_result = interest_extractor.invoke({
    "messages": [
        SystemMessage(content="Extract and categorize the user's interests."),
        HumanMessage(content=user_text)
    ]
})
interests = [cat.model_dump() for cat in interest_result["responses"]]
print("\nInterests:", interests)

# æ­¥éª¤ 4ï¼šå·¥ä½œç»å†
work_result = work_extractor.invoke({
    "messages": [
        SystemMessage(content="Extract all work experience mentioned."),
        HumanMessage(content=user_text)
    ]
})
work_history = [exp.model_dump() for exp in work_result["responses"]]
print("\nWork History:", work_history)

# ç»„åˆæˆå®Œæ•´ Profile
complete_profile = {
    **basic_info,
    "social_accounts": social_accounts,
    "interest_categories": interests,
    "work_history": work_history
}

print("\n=== Complete Profile ===")
import json
print(json.dumps(complete_profile, indent=2))
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```json
{
  "name": "Alice Johnson",
  "bio": "Software engineer passionate about AI and open source",
  "social_accounts": [
    {
      "platform": "Twitter",
      "username": "@alice_codes",
      "follower_count": 5000,
      "verified": false
    },
    {
      "platform": "LinkedIn",
      "username": "alice-johnson",
      "follower_count": null,
      "verified": true
    }
  ],
  "interest_categories": [
    {
      "category": "Technology",
      "interests": ["Python", "Machine Learning"]
    },
    {
      "category": "Sports",
      "interests": ["tennis", "hiking"]
    }
  ],
  "work_history": [
    {
      "company": "TechCorp",
      "position": "Senior Engineer",
      "start_date": "2022",
      "end_date": null,
      "description": "Current position"
    },
    {
      "company": "StartupXYZ",
      "position": "Junior Developer",
      "start_date": "2020",
      "end_date": "2022",
      "description": null
    }
  ]
}
```

#### æœ€ä½³å®è·µ 2ï¼šå¢é‡æ›´æ–°åµŒå¥—æ•°æ®

**åœºæ™¯**ï¼šç”¨æˆ·æ›´æ–°äº†éƒ¨åˆ†ä¿¡æ¯

```python
# ç°æœ‰ Profile
existing_profile = complete_profile

# ç”¨æˆ·æ›´æ–°ï¼š"I just joined Instagram as @alice.ai with 1000 followers"

# æ–¹å¼ 1ï¼šæ‰‹åŠ¨åˆå¹¶ï¼ˆä¸æ¨èï¼‰
new_account = {
    "platform": "Instagram",
    "username": "@alice.ai",
    "follower_count": 1000,
    "verified": False
}
existing_profile["social_accounts"].append(new_account)

# æ–¹å¼ 2ï¼šä½¿ç”¨ Trustcall æ™ºèƒ½æ›´æ–°ï¼ˆæ¨èï¼‰
# å‡†å¤‡ existing æ•°æ®
existing_accounts = [
    (str(i), "SocialMediaAccount", acc)
    for i, acc in enumerate(existing_profile["social_accounts"])
]

update_result = social_extractor.invoke({
    "messages": [
        SystemMessage(content="Update social media accounts."),
        HumanMessage(content="I just joined Instagram as @alice.ai with 1000 followers")
    ],
    "existing": existing_accounts
})

# Trustcall ä¼šï¼š
# 1. è¯†åˆ«è¿™æ˜¯æ–°è´¦å·
# 2. æ·»åŠ åˆ°åˆ—è¡¨ï¼ˆå› ä¸º enable_inserts=Trueï¼‰
# 3. è¿”å›æ‰€æœ‰è´¦å·ï¼ˆåŒ…æ‹¬æ–°çš„ï¼‰

updated_accounts = [acc.model_dump() for acc in update_result["responses"]]
existing_profile["social_accounts"] = updated_accounts
```

#### æœ€ä½³å®è·µ 3ï¼šä½¿ç”¨ Field çš„ description å¼•å¯¼ LLM

```python
class SocialMediaAccount(BaseModel):
    """ç¤¾äº¤åª’ä½“è´¦å·"""
    platform: str = Field(
        description="""å¹³å°åç§°ã€‚
        å¸¸è§å¹³å°ï¼šTwitter, LinkedIn, Instagram, Facebook, GitHub, YouTube
        è¯·è§„èŒƒåŒ–å¹³å°åç§°ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰"""
    )
    username: str = Field(
        description="""ç”¨æˆ·åæˆ–å¥æŸ„ã€‚
        ä¿ç•™ @ ç¬¦å·ï¼ˆå¦‚æœæœ‰ï¼‰
        ç¤ºä¾‹ï¼š@alice_codes, alice-johnson"""
    )
    follower_count: Optional[int] = Field(
        description="""ç²‰ä¸/å…³æ³¨è€…æ•°é‡ã€‚
        å¦‚æœæœªæåŠï¼Œè®¾ä¸º Noneã€‚
        åªæ¥å—æ•°å­—ï¼Œå¿½ç•¥ K/M ç­‰åç¼€ï¼ˆéœ€è¦è½¬æ¢ï¼‰""",
        default=None
    )
    verified: bool = Field(
        description="""è´¦å·æ˜¯å¦å·²éªŒè¯ã€‚
        å…³é”®è¯ï¼šverified, blue check, official
        é»˜è®¤ä¸º False""",
        default=False
    )
```

**æ•ˆæœ**ï¼šè¯¦ç»†çš„ description æ˜¾è‘—æé«˜æå–å‡†ç¡®æ€§ã€‚

#### æœ€ä½³å®è·µ 4ï¼šé”™è¯¯å¤„ç†å’ŒéªŒè¯

```python
from pydantic import ValidationError, field_validator

class WorkExperience(BaseModel):
    """å·¥ä½œç»å†ï¼ˆå¸¦éªŒè¯ï¼‰"""
    company: str
    position: str
    start_date: str
    end_date: Optional[str] = None
    
    @field_validator("start_date", "end_date")
    @classmethod
    def validate_date_format(cls, v):
        """éªŒè¯æ—¥æœŸæ ¼å¼"""
        if v is None:
            return v
        try:
            datetime.fromisoformat(v)
            return v
        except ValueError:
            raise ValueError(f"Invalid date format: {v}. Use ISO format (YYYY-MM-DD)")

# ä½¿ç”¨æ—¶ä¼šè‡ªåŠ¨éªŒè¯
try:
    work = WorkExperience(
        company="TechCorp",
        position="Engineer",
        start_date="2022-01-15",  # æ­£ç¡®
        end_date="invalid-date"    # é”™è¯¯
    )
except ValidationError as e:
    print("Validation Error:", e)
```

---

### é—®é¢˜ 6-10ï¼šè¯·å‚è€ƒè¯¦ç»†å†…å®¹æ–‡ä»¶

ä¸ºäº†ä¿æŒæœ¬å¤ä¹ æ–‡æ¡£çš„ç®€æ´æ€§ï¼Œä»¥ä¸‹é—®é¢˜çš„è¯¦ç»†ç­”æ¡ˆè¯·å‚è€ƒå¯¹åº”çš„è¯¦ç»†è§£è¯»æ–‡ä»¶ï¼š

**é—®é¢˜ 6**ï¼šå¦‚ä½•å®ç°è®°å¿†çš„ç‰ˆæœ¬æ§åˆ¶å’Œå›æ»šï¼Ÿ  
ğŸ‘‰ å‚è€ƒï¼š[6.1 Memory Agent - è¯¦ç»†è§£è¯»](./6.1-memory_agent-è¯¦ç»†è§£è¯».md) ä¸­çš„"é«˜çº§ç‰¹æ€§"ç« èŠ‚

**é—®é¢˜ 7**ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒè¯­ä¹‰æœç´¢çš„è®°å¿†ç³»ç»Ÿï¼ˆç»“åˆå‘é‡æ•°æ®åº“ï¼‰  
ğŸ‘‰ å‚è€ƒï¼š[6.2 Memory Store - è¯¦ç»†è§£è¯»](./6.2-memory_store-è¯¦ç»†è§£è¯».md) ä¸­çš„"æ‰©å±•åº”ç”¨"ç« èŠ‚

**é—®é¢˜ 8**ï¼šå¦‚ä½•ä¼˜åŒ– Store çš„æŸ¥è¯¢æ€§èƒ½ï¼ˆç´¢å¼•ã€ç¼“å­˜ã€åˆ†é¡µï¼‰  
ğŸ‘‰ å‚è€ƒï¼š[6.2 Memory Store - è¯¦ç»†è§£è¯»](./6.2-memory_store-è¯¦ç»†è§£è¯».md) ä¸­çš„"æ€§èƒ½ä¼˜åŒ–"ç« èŠ‚

**é—®é¢˜ 9**ï¼šå®ç°è®°å¿†çš„è‡ªåŠ¨åˆ†ç±»å’Œæ ‡ç­¾ç³»ç»Ÿ  
ğŸ‘‰ å‚è€ƒï¼š[6.3 Memory Schema - Profile](./6.3-memoryschema_profile-è¯¦ç»†è§£è¯».md) å’Œ [6.4 Memory Schema - Collection](./6.4-memoryschema_collection-è¯¦ç»†è§£è¯».md)

**é—®é¢˜ 10**ï¼šå¦‚ä½•è®¾è®¡è®°å¿†çš„è¿‡æœŸå’Œæ¸…ç†ç­–ç•¥ï¼ˆæ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼‰  
ğŸ‘‰ å‚è€ƒï¼š[6.1 Memory Agent - è¯¦ç»†è§£è¯»](./6.1-memory_agent-è¯¦ç»†è§£è¯».md) ä¸­çš„"ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ"ç« èŠ‚

---

## å››ã€çŸ¥è¯†æŒæ¡åº¦è‡ªæµ‹

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œè¯·è¯šå®è¯„ä¼°è‡ªå·±å¯¹ä»¥ä¸‹çŸ¥è¯†ç‚¹çš„æŒæ¡ç¨‹åº¦ï¼š

### åŸºç¡€æ¦‚å¿µï¼ˆå¿…é¡»æŒæ¡ï¼‰âœ“

- [ ] **è®¤çŸ¥ç§‘å­¦åŸºç¡€**
  - [ ] èƒ½è§£é‡ŠçŸ­æœŸè®°å¿†å’Œé•¿æœŸè®°å¿†çš„åŒºåˆ«
  - [ ] ç†è§£è¯­ä¹‰è®°å¿†ã€æƒ…èŠ‚è®°å¿†ã€ç¨‹åºæ€§è®°å¿†çš„å«ä¹‰
  - [ ] çŸ¥é“å¦‚ä½•å°†è®¤çŸ¥æ¨¡å‹æ˜ å°„åˆ° LangGraph ç»„ä»¶

- [ ] **LangGraph Store**
  - [ ] ç†è§£ namespaceã€keyã€value ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µ
  - [ ] èƒ½ç†Ÿç»ƒä½¿ç”¨ put()ã€get()ã€search() æ–¹æ³•
  - [ ] çŸ¥é“å¦‚ä½•è®¾è®¡åˆç†çš„ namespace ç»“æ„

- [ ] **Checkpointer vs Store**
  - [ ] èƒ½æ¸…æ¥šè¯´æ˜ä¸¤è€…çš„åŒºåˆ«
  - [ ] çŸ¥é“ä½•æ—¶ä½¿ç”¨ Checkpointerï¼Œä½•æ—¶ä½¿ç”¨ Store
  - [ ] ç†è§£å¦‚ä½•ååŒä½¿ç”¨ä¸¤è€…

### æ ¸å¿ƒæŠ€æœ¯ï¼ˆåº”è¯¥æŒæ¡ï¼‰âœ“

- [ ] **Pydantic Schema**
  - [ ] èƒ½å®šä¹‰ BaseModel å’Œ Field
  - [ ] ç†è§£æ•°æ®éªŒè¯çš„å·¥ä½œåŸç†
  - [ ] ä¼šä½¿ç”¨åµŒå¥—æ¨¡å‹å’Œåˆ—è¡¨å­—æ®µ

- [ ] **Trustcall**
  - [ ] èƒ½åˆ›å»ºå’Œä½¿ç”¨ extractor
  - [ ] ç†è§£ enable_inserts å‚æ•°çš„ä½œç”¨
  - [ ] çŸ¥é“å¦‚ä½•ä¼ é€’ existing æ•°æ®å®ç°å¢é‡æ›´æ–°

- [ ] **Profile vs Collection**
  - [ ] èƒ½å‡†ç¡®åˆ¤æ–­ä½•æ—¶ä½¿ç”¨ Profile
  - [ ] èƒ½å‡†ç¡®åˆ¤æ–­ä½•æ—¶ä½¿ç”¨ Collection
  - [ ] ç†è§£ä¸¤ç§æ¨¡å¼çš„æŠ€æœ¯å®ç°å·®å¼‚

### é«˜çº§åº”ç”¨ï¼ˆæ·±å…¥æŒæ¡ï¼‰âœ“

- [ ] **å¤æ‚ Schema å¤„ç†**
  - [ ] èƒ½å¤„ç†åµŒå¥—çš„ Pydantic æ¨¡å‹
  - [ ] ä¼šåˆ†è§£å¤æ‚ Schema ä¸ºå¤šæ­¥æå–
  - [ ] ç†è§£ JSON Patch çš„å·¥ä½œåŸç†

- [ ] **ä¼ä¸šçº§æ¶æ„**
  - [ ] èƒ½è®¾è®¡å¤šç§Ÿæˆ·çš„è®°å¿†ç³»ç»Ÿ
  - [ ] ç†è§£æƒé™æ§åˆ¶å’Œæ•°æ®éš”ç¦»
  - [ ] çŸ¥é“å¦‚ä½•å®ç°å®¡è®¡æ—¥å¿—

- [ ] **æ€§èƒ½ä¼˜åŒ–**
  - [ ] èƒ½è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
  - [ ] ä¼šä½¿ç”¨ç¼“å­˜ç­–ç•¥
  - [ ] ç†è§£ InMemoryStore vs PostgresStore çš„é€‰æ‹©

### è‡ªæµ‹è¯„åˆ†æ ‡å‡†

- **90% ä»¥ä¸Š**ï¼šâœ… ä¼˜ç§€ï¼å¯ä»¥è¿›å…¥ä¸‹ä¸€æ¨¡å—æˆ–æŒ‘æˆ˜é«˜çº§é¡¹ç›®
- **70-89%**ï¼šğŸ‘ è‰¯å¥½ï¼å»ºè®®å®Œæˆå®è·µé¡¹ç›®å·©å›º
- **50-69%**ï¼šâš ï¸ åŠæ ¼ï¼éœ€è¦é‡ç‚¹å¤ä¹ è–„å¼±éƒ¨åˆ†
- **50% ä»¥ä¸‹**ï¼šâŒ éœ€è¦é‡æ–°å­¦ä¹ æœ¬ç« å†…å®¹

---

## äº”ã€å­¦ä¹ è·¯å¾„ä¸ä¸‹ä¸€æ­¥

### å¦‚æœä½ çš„æŒæ¡åº¦ < 70%

**å»ºè®®**ï¼šå·©å›ºåŸºç¡€

1. **é‡è¯»æ ¸å¿ƒç« èŠ‚**ï¼ˆ2-3å¤©ï¼‰
   - 6.2 Memory Storeï¼ˆStore åŸºç¡€ï¼‰
   - 6.3 Profile æˆ– 6.4 Collectionï¼ˆé€‰ä¸€ä¸ªæ·±å…¥ï¼‰

2. **å®ŒæˆåŸºç¡€å®è·µ**ï¼ˆ2-3å¤©ï¼‰
   - å®ç°ä¸€ä¸ªç®€å•çš„è®°å¿†èŠå¤©æœºå™¨äºº
   - å®ç° Profile æˆ– Collection çš„ä¸€ä¸ªåº”ç”¨

3. **é‡åšå¤ä¹ é¢˜**ï¼ˆ1å¤©ï¼‰
   - é—®é¢˜ 1ï¼šå¤šç”¨æˆ·è®°å¿†èŠå¤©æœºå™¨äºº
   - é—®é¢˜ 2ï¼šå­¦ä¹ ç¬”è®°ç³»ç»Ÿ

### å¦‚æœä½ çš„æŒæ¡åº¦ 70-90%

**å»ºè®®**ï¼šæ·±åŒ–ç†è§£

1. **å®Œæˆè¿›é˜¶å®è·µ**ï¼ˆ3-5å¤©ï¼‰
   - é¡¹ç›® 2ï¼šæ™ºèƒ½å­¦ä¹ ç¬”è®°ç³»ç»Ÿï¼ˆè§ä¸‹æ–‡ï¼‰
   - æ·»åŠ è¯­ä¹‰æœç´¢åŠŸèƒ½
   - å®ç°è‡ªåŠ¨åˆ†ç±»

2. **ç ”ç©¶æºç **ï¼ˆ2-3å¤©ï¼‰
   - é˜…è¯» LangGraph Store æºç 
   - é˜…è¯» Trustcall æºç 
   - ç†è§£ JSON Patch å®ç°

3. **æ€§èƒ½ä¼˜åŒ–å®éªŒ**ï¼ˆ2å¤©ï¼‰
   - å¯¹æ¯” InMemoryStore vs PostgresStore
   - å®ç°ç¼“å­˜å±‚
   - è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•

### å¦‚æœä½ çš„æŒæ¡åº¦ > 90%

**å»ºè®®**ï¼šæŒ‘æˆ˜é«˜çº§åº”ç”¨

1. **ä¼ä¸šçº§é¡¹ç›®**ï¼ˆ5-7å¤©ï¼‰
   - é¡¹ç›® 3ï¼šä¼ä¸šçº§å®¢æœç³»ç»Ÿï¼ˆè§ä¸‹æ–‡ï¼‰
   - å®ç°å¤šç§Ÿæˆ·æ¶æ„
   - æ·»åŠ æƒé™æ§åˆ¶
   - éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

2. **åˆ›æ–°åº”ç”¨**ï¼ˆå¼€æ”¾æ—¶é—´ï¼‰
   - å¤šæ¨¡æ€è®°å¿†ç³»ç»Ÿï¼ˆæ–‡æœ¬+å›¾åƒ+éŸ³é¢‘ï¼‰
   - è®°å¿†çš„æ™ºèƒ½æ‘˜è¦å’Œå‹ç¼©
   - åŸºäºè®°å¿†çš„ä¸ªæ€§åŒ–æ¨è

3. **è´¡çŒ®å¼€æº**
   - ä¸º LangGraph è´¡çŒ®ä»£ç 
   - ç¼–å†™æ•™ç¨‹å’Œåšå®¢
   - å‚ä¸ç¤¾åŒºè®¨è®º

---

## å…­ã€å®è·µé¡¹ç›®å»ºè®®

### é¡¹ç›® 1ï¼šä¸ªæ€§åŒ–æ–°é—»åŠ©æ‰‹ ğŸ”° åˆçº§

**æ—¶é•¿**ï¼š3-5 å°æ—¶  
**éš¾åº¦**ï¼šâ­â­

**åŠŸèƒ½è¦æ±‚**ï¼š
1. è®°ä½ç”¨æˆ·çš„å…´è¶£ä¸»é¢˜ï¼ˆProfileï¼‰
2. ä¿å­˜ç”¨æˆ·é˜…è¯»å†å²ï¼ˆCollectionï¼‰
3. æ ¹æ®å…´è¶£æ¨èæ–°é—»
4. è·¨ä¼šè¯è®°å¿†ç”¨æˆ·åå¥½

**æŠ€æœ¯æ ˆ**ï¼š
- LangGraph + InMemoryStore
- OpenAI API
- Pydantic Schema

**è¯„ä¼°æ ‡å‡†**ï¼š
- [ ] Store åŸºæœ¬æ“ä½œæ­£ç¡®
- [ ] Profile æ›´æ–°æ­£å¸¸
- [ ] èƒ½å¤Ÿæ¨èç›¸å…³æ–°é—»
- [ ] è·¨ä¼šè¯è®°å¿†æœ‰æ•ˆ

---

### é¡¹ç›® 2ï¼šæ™ºèƒ½å­¦ä¹ ç¬”è®°ç³»ç»Ÿ â­ ä¸­çº§

**æ—¶é•¿**ï¼š1-2 å¤©  
**éš¾åº¦**ï¼šâ­â­â­

**åŠŸèƒ½è¦æ±‚**ï¼š
1. ä»å­¦ä¹ ææ–™ä¸­æ™ºèƒ½æå–ç¬”è®°ï¼ˆTrustcallï¼‰
2. è‡ªåŠ¨åˆ†ç±»å’Œæ‰“æ ‡ç­¾
3. æ”¯æŒå¤šç»´åº¦æœç´¢ï¼ˆä¸»é¢˜ã€æ ‡ç­¾ã€é‡è¦æ€§ï¼‰
4. è¯­ä¹‰æœç´¢ï¼ˆä½¿ç”¨ Embeddingsï¼‰
5. ç¬”è®°ç»Ÿè®¡å’Œå¯è§†åŒ–

**æŠ€æœ¯æ ˆ**ï¼š
- LangGraph + InMemoryStore
- Trustcall
- OpenAI Embeddings
- å¯é€‰ï¼šStreamlitï¼ˆUIï¼‰

**è¯„ä¼°æ ‡å‡†**ï¼š
- [ ] Trustcall æå–å‡†ç¡®
- [ ] Collection ç®¡ç†æ­£ç¡®
- [ ] è¯­ä¹‰æœç´¢æœ‰æ•ˆ
- [ ] ç»Ÿè®¡åŠŸèƒ½å®Œæ•´

**æ‰©å±•æŒ‘æˆ˜**ï¼š
- [ ] æ·»åŠ ç¬”è®°å¤ä¹ æé†’ï¼ˆé—´éš”é‡å¤ç®—æ³•ï¼‰
- [ ] ç”ŸæˆçŸ¥è¯†å›¾è°±
- [ ] ç¬”è®°è‡ªåŠ¨æ‘˜è¦

---

### é¡¹ç›® 3ï¼šä¼ä¸šçº§å®¢æœç³»ç»Ÿ ğŸš€ é«˜çº§

**æ—¶é•¿**ï¼š3-5 å¤©  
**éš¾åº¦**ï¼šâ­â­â­â­â­

**åŠŸèƒ½è¦æ±‚**ï¼š
1. å¤šç§Ÿæˆ·æ”¯æŒï¼ˆä¸åŒä¼ä¸šçš„æ•°æ®éš”ç¦»ï¼‰
2. ç”¨æˆ·ç®¡ç†å’Œæƒé™æ§åˆ¶ï¼ˆRBACï¼‰
3. å®¢æˆ·èµ„æ–™ç®¡ç†ï¼ˆProfileï¼‰
4. å¯¹è¯å†å²ï¼ˆCollectionï¼‰
5. å·¥å•ç®¡ç†ï¼ˆCollectionï¼‰
6. å®¡è®¡æ—¥å¿—
7. æ•°æ®åˆ†æå’ŒæŠ¥è¡¨

**æŠ€æœ¯æ ˆ**ï¼š
- LangGraph + PostgresStore
- Trustcall
- FastAPIï¼ˆåç«¯ï¼‰
- Reactï¼ˆå‰ç«¯ï¼Œå¯é€‰ï¼‰
- PostgreSQL

**è¯„ä¼°æ ‡å‡†**ï¼š
- [ ] å¤šç§Ÿæˆ·éš”ç¦»æœ‰æ•ˆ
- [ ] æƒé™æ§åˆ¶æ­£ç¡®
- [ ] æ•°æ®å®‰å…¨ï¼ˆåŠ å¯†ã€å®¡è®¡ï¼‰
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆç¼“å­˜ã€ç´¢å¼•ï¼‰
- [ ] å¯éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

**æ‰©å±•æŒ‘æˆ˜**ï¼š
- [ ] æ·»åŠ å®æ—¶åˆ†æä»ªè¡¨ç›˜
- [ ] å®ç°å®¢æˆ·æƒ…æ„Ÿåˆ†æ
- [ ] é›†æˆç¬¬ä¸‰æ–¹ CRM ç³»ç»Ÿ

---

## ä¸ƒã€çŸ¥è¯†å¡ç‰‡æ€»ç»“

### å¡ç‰‡ 1ï¼šStore æ ¸å¿ƒæ¦‚å¿µ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         LangGraph Store                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Namespace: å…ƒç»„ï¼ˆå±‚çº§ç»„ç»‡ï¼‰            â”‚
â”‚   ("user_1", "profile")                â”‚
â”‚                                         â”‚
â”‚ Key: å­—ç¬¦ä¸²ï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰                â”‚
â”‚   - Profile: å›ºå®šé”®                    â”‚
â”‚   - Collection: UUID é”®                â”‚
â”‚                                         â”‚
â”‚ Value: å­—å…¸ï¼ˆå®é™…æ•°æ®ï¼‰                â”‚
â”‚   {"field": "value"}                   â”‚
â”‚                                         â”‚
â”‚ æ“ä½œ:                                   â”‚
â”‚   â€¢ put(ns, key, value)                â”‚
â”‚   â€¢ get(ns, key) â†’ Item | None         â”‚
â”‚   â€¢ search(ns) â†’ List[Item]            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¡ç‰‡ 2ï¼šProfile vs Collection

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Profile      â”‚   Collection     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å•ä¸€å¯¹è±¡         â”‚ å¤šä¸ªç‹¬ç«‹é¡¹       â”‚
â”‚ å›ºå®šç»“æ„         â”‚ çµæ´»ç»“æ„         â”‚
â”‚ å›ºå®šé”®           â”‚ UUID é”®          â”‚
â”‚ JSON Patch æ›´æ–°  â”‚ å¢åˆ æ”¹ç‹¬ç«‹é¡¹     â”‚
â”‚ enable_inserts=F â”‚ enable_inserts=T â”‚
â”‚                  â”‚                  â”‚
â”‚ é€‚ç”¨ï¼š           â”‚ é€‚ç”¨ï¼š           â”‚
â”‚ â€¢ ç”¨æˆ·èµ„æ–™       â”‚ â€¢ ç¬”è®°           â”‚
â”‚ â€¢ ç³»ç»Ÿé…ç½®       â”‚ â€¢ ä»»åŠ¡           â”‚
â”‚ â€¢ è®¤è¯ä¿¡æ¯       â”‚ â€¢ äº‹ä»¶è®°å½•       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¡ç‰‡ 3ï¼šTrustcall å·¥ä½œæµ

```
1. å®šä¹‰ Schema
   class UserProfile(BaseModel):
       name: str
       interests: List[str]

2. åˆ›å»ºæå–å™¨
   extractor = create_extractor(
       model,
       tools=[UserProfile],
       enable_inserts=True  # Collection
   )

3. æå–ï¼ˆåˆ›å»ºï¼‰
   result = extractor.invoke({
       "messages": conversation
   })

4. æ›´æ–°ï¼ˆå¢é‡ï¼‰
   result = extractor.invoke({
       "messages": new_conversation,
       "existing": existing_data  # ä¼ å…¥ç°æœ‰æ•°æ®
   })
   # å†…éƒ¨ä½¿ç”¨ JSON Patch
```

### å¡ç‰‡ 4ï¼šå¤šç§Ÿæˆ· Namespace è®¾è®¡

```
(tenant_id, resource_type, resource_id, ...)
    â”‚           â”‚              â”‚
    â”‚           â”‚              â””â”€ å…·ä½“èµ„æºID
    â”‚           â””â”€ èµ„æºç±»å‹ï¼ˆusers/teams/sharedï¼‰
    â””â”€ ç§Ÿæˆ·IDï¼ˆç¬¬ä¸€å±‚å¿…é¡»æ˜¯ç§Ÿæˆ·ï¼‰

ç¤ºä¾‹ï¼š
("acme_corp", "users", "alice", "profile")
("acme_corp", "teams", "team_1", "knowledge")
("rival_corp", "users", "bob", "profile")

ä¼˜ç‚¹ï¼š
â€¢ æ•°æ®éš”ç¦»
â€¢ æƒé™æ§åˆ¶
â€¢ å¯å®¡è®¡
```

---

## å…«ã€å¸¸è§é—®é¢˜ FAQ

### Q1ï¼šStore å’Œ Checkpointer æœ‰ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ï¼Ÿ

**A**ï¼š

| ç»´åº¦ | Checkpointer | Store |
|------|--------------|-------|
| **ç”¨é€”** | ä¿å­˜ Graph æ‰§è¡ŒçŠ¶æ€ | ä¿å­˜è‡ªå®šä¹‰ä¸šåŠ¡æ•°æ® |
| **ç”Ÿå‘½å‘¨æœŸ** | å•æ¬¡ä¼šè¯ï¼ˆthreadï¼‰ | è·¨æ‰€æœ‰ä¼šè¯ï¼ˆpersistentï¼‰ |
| **è®¿é—®æ–¹å¼** | é€šè¿‡ `thread_id` è‡ªåŠ¨åŠ è½½ | éœ€è¦æ‰‹åŠ¨ put/get/search |
| **æ•°æ®ç»“æ„** | Graph Stateï¼ˆå®Œæ•´çŠ¶æ€ï¼‰ | ä»»æ„å­—å…¸ |
| **å…¸å‹å†…å®¹** | å¯¹è¯å†å²ã€èŠ‚ç‚¹çŠ¶æ€ | ç”¨æˆ·èµ„æ–™ã€è®°å¿†é›†åˆ |

**ç±»æ¯”**ï¼š
- Checkpointer = æµè§ˆå™¨çš„ä¼šè¯å­˜å‚¨ï¼ˆsessionStorageï¼‰
- Store = æµè§ˆå™¨çš„æœ¬åœ°å­˜å‚¨ï¼ˆlocalStorageï¼‰

---

### Q2ï¼šä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨ Collection è€Œä¸æ˜¯ Profile çš„åˆ—è¡¨å­—æ®µï¼Ÿ

**A**ï¼š

**ä½¿ç”¨ Profile çš„åˆ—è¡¨å­—æ®µ**ï¼ˆå¦‚ `interests: List[str]`ï¼‰ï¼š
- âœ… åˆ—è¡¨é¡¹æ˜¯ç®€å•å€¼ï¼ˆå­—ç¬¦ä¸²ã€æ•°å­—ï¼‰
- âœ… åˆ—è¡¨é•¿åº¦æœ‰é™ï¼ˆ< 20 é¡¹ï¼‰
- âœ… æ•´ä¸ªåˆ—è¡¨ç»å¸¸ä¸€èµ·è¯»å–
- âœ… å±äºæ ¸å¿ƒèµ„æ–™çš„ä¸€éƒ¨åˆ†

**ä½¿ç”¨ Collection**ï¼ˆå¤šä¸ªç‹¬ç«‹å¯¹è±¡ï¼‰ï¼š
- âœ… åˆ—è¡¨é¡¹æ˜¯å¤æ‚å¯¹è±¡ï¼ˆåµŒå¥—ç»“æ„ï¼‰
- âœ… åˆ—è¡¨å¯èƒ½æ— é™å¢é•¿
- âœ… ç»å¸¸å•ç‹¬æ“ä½œæŸä¸€é¡¹
- âœ… éœ€è¦ç‹¬ç«‹çš„æŸ¥è¯¢å’Œç­›é€‰

**ç¤ºä¾‹å¯¹æ¯”**ï¼š

```python
# âœ… å¥½ï¼šProfile çš„åˆ—è¡¨å­—æ®µ
class UserProfile(BaseModel):
    name: str
    interests: List[str]  # ["Python", "AI", "Music"]

# âŒ ä¸å¥½ï¼šCollection ä¸­è¿‡äºç®€å•çš„æ•°æ®
# æ¯ä¸ªå…´è¶£ä¸€ä¸ªå¯¹è±¡å¤ªæµªè´¹
namespace = ("user_1", "interests")
for interest in ["Python", "AI", "Music"]:
    store.put(namespace, str(uuid.uuid4()), {"interest": interest})

# âœ… å¥½ï¼šCollection å­˜å‚¨å¤æ‚å¯¹è±¡
class Note(BaseModel):
    title: str
    content: str
    tags: List[str]
    created_at: datetime

namespace = ("user_1", "notes")
for note in notes:
    store.put(namespace, str(uuid.uuid4()), note.model_dump())
```

---

### Q3ï¼šenable_inserts åˆ°åº•åšäº†ä»€ä¹ˆï¼Ÿ

**A**ï¼š

`enable_inserts` æ§åˆ¶ Trustcall æ˜¯å¦å¯ä»¥**åˆ›å»ºæ–°é¡¹**ã€‚

**enable_inserts=Falseï¼ˆé»˜è®¤ï¼‰**ï¼š
- åªèƒ½**æ›´æ–°**ç°æœ‰çš„ `existing` æ•°æ®
- å¦‚æœæ²¡æœ‰ä¼ å…¥ `existing`ï¼Œä¼šåˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡
- é€‚åˆ Profileï¼ˆå•ä¸€å¯¹è±¡ï¼‰

**enable_inserts=True**ï¼š
- å¯ä»¥**æ›´æ–°**ç°æœ‰æ•°æ®
- ä¹Ÿå¯ä»¥**åˆ›å»º**æ–°é¡¹ï¼ˆå³ä½¿å·²æœ‰ `existing`ï¼‰
- é€‚åˆ Collectionï¼ˆå¤šä¸ªå¯¹è±¡ï¼‰

**ç¤ºä¾‹**ï¼š

```python
# Scenario: ç”¨æˆ·æœ‰2æ¡ç¬”è®°ï¼Œæ·»åŠ ç¬¬3æ¡

existing_notes = [
    ("0", "Note", {"content": "Note 1"}),
    ("1", "Note", {"content": "Note 2"})
]

new_text = "I learned something new today."

# ========== enable_inserts=False ==========
extractor_no_insert = create_extractor(
    model,
    tools=[Note],
    enable_inserts=False
)

result = extractor_no_insert.invoke({
    "messages": [HumanMessage(content=new_text)],
    "existing": existing_notes
})

# ç»“æœï¼šåªèƒ½æ›´æ–°ç°æœ‰2æ¡ç¬”è®°ï¼Œä¸èƒ½æ·»åŠ ç¬¬3æ¡
# ï¼ˆLLM å¯èƒ½å°è¯•æŠŠæ–°å†…å®¹åˆå¹¶åˆ°ç°æœ‰ç¬”è®°ä¸­ï¼‰

# ========== enable_inserts=True ==========
extractor_with_insert = create_extractor(
    model,
    tools=[Note],
    enable_inserts=True  # å…³é”®ï¼
)

result = extractor_with_insert.invoke({
    "messages": [HumanMessage(content=new_text)],
    "existing": existing_notes
})

# ç»“æœï¼šä¼šåˆ›å»ºç¬¬3æ¡ç¬”è®°
# responses å¯èƒ½åŒ…å«3ä¸ª Note å¯¹è±¡
```

---

### Q4ï¼šå¦‚ä½•è¿ç§»ä» InMemoryStore åˆ° PostgresStoreï¼Ÿ

**A**ï¼š

è¿ç§»éå¸¸ç®€å•ï¼Œå› ä¸ºä¸¤è€…æœ‰**ç›¸åŒçš„ API**ï¼š

```python
# ========== å¼€å‘ç¯å¢ƒï¼ˆInMemoryStoreï¼‰ ==========
from langgraph.store.memory import InMemoryStore

store = InMemoryStore()

# ========== ç”Ÿäº§ç¯å¢ƒï¼ˆPostgresStoreï¼‰ ==========
from langgraph.store.postgres import PostgresStore

store = PostgresStore(
    connection_string="postgresql://user:pass@localhost:5432/db"
)

# API å®Œå…¨ç›¸åŒï¼æ— éœ€ä¿®æ”¹ä»£ç 
store.put(namespace, key, value)
store.get(namespace, key)
store.search(namespace)
```

**è¿ç§»æ­¥éª¤**ï¼š

1. **å®‰è£… PostgreSQL**
   ```bash
   # macOS
   brew install postgresql
   
   # Ubuntu
   sudo apt install postgresql
   ```

2. **åˆ›å»ºæ•°æ®åº“**
   ```sql
   CREATE DATABASE langgraph_store;
   ```

3. **æ›´æ–°ä»£ç **
   ```python
   # åªéœ€ä¿®æ”¹è¿™ä¸€è¡Œ
   store = PostgresStore("postgresql://user:pass@localhost/langgraph_store")
   ```

4. **æ•°æ®è¿ç§»**ï¼ˆå¦‚æœéœ€è¦ï¼‰
   ```python
   # ä» InMemoryStore å¯¼å‡º
   old_store = InMemoryStore()
   # ... åŠ è½½æ—§æ•°æ®

   # å¯¼å…¥åˆ° PostgresStore
   new_store = PostgresStore(conn_string)
   
   for namespace in all_namespaces:
       items = old_store.search(namespace)
       for item in items:
           new_store.put(namespace, item.key, item.value)
   ```

---

### Q5ï¼šå¦‚ä½•å¤„ç† Store ä¸­çš„å¤§é‡æ•°æ®ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰ï¼Ÿ

**A**ï¼š

**é—®é¢˜**ï¼š`search(namespace)` ä¼šè¿”å›è¯¥ namespace ä¸‹çš„**æ‰€æœ‰**é¡¹ï¼Œæ•°æ®é‡å¤§æ—¶å¾ˆæ…¢ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **åˆ†ç‰‡ Namespace**
   ```python
   # âŒ ä¸å¥½ï¼šæ‰€æœ‰ç¬”è®°åœ¨åŒä¸€ä¸ª namespace
   namespace = ("user_1", "notes")
   # å¯èƒ½æœ‰ 10000+ æ¡ç¬”è®°

   # âœ… å¥½ï¼šæŒ‰æ—¶é—´åˆ†ç‰‡
   import datetime
   month = datetime.now().strftime("%Y-%m")
   namespace = ("user_1", "notes", month)  # ("user_1", "notes", "2024-11")
   # æ¯ä¸ªæœˆçš„ç¬”è®°åœ¨ç‹¬ç«‹çš„ namespace
   ```

2. **ä½¿ç”¨ PostgresStore çš„ SQL æŸ¥è¯¢**
   ```python
   # PostgresStore æ”¯æŒè‡ªå®šä¹‰æŸ¥è¯¢
   from langgraph.store.postgres import PostgresStore
   
   store = PostgresStore(conn_string)
   
   # ä½¿ç”¨ SQL ç­›é€‰
   query = """
   SELECT * FROM store 
   WHERE namespace = %s 
   AND value->>'importance' >= %s
   ORDER BY created_at DESC
   LIMIT 100
   """
   
   results = store.execute(query, [namespace, "4"])
   ```

3. **æ·»åŠ ç´¢å¼•**ï¼ˆPostgresStoreï¼‰
   ```sql
   -- ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
   CREATE INDEX idx_namespace ON store(namespace);
   CREATE INDEX idx_created_at ON store(created_at);
   CREATE INDEX idx_importance ON store((value->>'importance'));
   ```

4. **ç¼“å­˜**
   ```python
   from functools import lru_cache
   
   @lru_cache(maxsize=100)
   def get_user_profile(user_id: str):
       namespace = (user_id, "profile")
       return store.get(namespace, "user_profile")
   ```

---

## ä¹ã€æ€»ç»“ä¸å±•æœ›

### ä½ å·²ç»æŒæ¡çš„èƒ½åŠ›

é€šè¿‡ Module-6 çš„å­¦ä¹ ï¼Œä½ ç°åœ¨èƒ½å¤Ÿï¼š

1. âœ… **ç†è§£è®°å¿†çš„æœ¬è´¨**
   - çŸ­æœŸè®°å¿† vs é•¿æœŸè®°å¿†
   - è®¤çŸ¥ç§‘å­¦åˆ°ç³»ç»Ÿæ¶æ„çš„æ˜ å°„

2. âœ… **ä½¿ç”¨ LangGraph Store**
   - ç†Ÿç»ƒæ“ä½œ put/get/search
   - è®¾è®¡åˆç†çš„ namespace ç»“æ„
   - é€‰æ‹©åˆé€‚çš„å­˜å‚¨åç«¯

3. âœ… **æ„å»ºç»“æ„åŒ–è®°å¿†**
   - å®šä¹‰ Pydantic Schema
   - ä½¿ç”¨ Trustcall æå–å’Œæ›´æ–°
   - å¤„ç†å¤æ‚åµŒå¥— Schema

4. âœ… **æ¶æ„å†³ç­–**
   - Profile vs Collection çš„é€‰æ‹©
   - ä½•æ—¶ä½¿ç”¨ä½•ç§è®°å¿†æ¨¡å¼
   - ä¼ä¸šçº§æ¶æ„è®¾è®¡ï¼ˆå¤šç§Ÿæˆ·ã€æƒé™æ§åˆ¶ï¼‰

5. âœ… **æ€§èƒ½ä¼˜åŒ–**
   - è¯†åˆ«ç“¶é¢ˆ
   - ç¼“å­˜ç­–ç•¥
   - æ•°æ®åº“ç´¢å¼•

### ä¸‹ä¸€æ­¥å­¦ä¹ æ–¹å‘

å®Œæˆ Module-6 åï¼Œä½ å¯ä»¥æ¢ç´¢ï¼š

1. **Module-7ï¼šé«˜çº§ Agent æ¨¡å¼**ï¼ˆæ¨èä¸‹ä¸€æ­¥ï¼‰
   - Multi-Agent ç³»ç»Ÿ
   - Agent ç›‘ç£å’Œç¼–æ’
   - å¤æ‚å·¥ä½œæµè®¾è®¡

2. **å‘é‡æ•°æ®åº“ä¸ RAG**
   - ç»“åˆ Pinecone/Weaviate å®ç°è¯­ä¹‰æœç´¢
   - è®°å¿†ä¸å¤–éƒ¨çŸ¥è¯†çš„èåˆ
   - æ„å»ºçŸ¥è¯†å¢å¼ºçš„ Agent

3. **ç”Ÿäº§éƒ¨ç½²**
   - å®¹å™¨åŒ–ï¼ˆDockerï¼‰
   - ç›‘æ§å’Œæ—¥å¿—ï¼ˆPrometheus, Grafanaï¼‰
   - CI/CD æµæ°´çº¿

4. **åˆ›æ–°åº”ç”¨**
   - å¤šæ¨¡æ€è®°å¿†ï¼ˆæ–‡æœ¬+å›¾åƒ+éŸ³é¢‘ï¼‰
   - è®°å¿†çš„æ™ºèƒ½å‹ç¼©å’Œæ‘˜è¦
   - åŸºäºè®°å¿†çš„ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ

### ç»ˆèº«å­¦ä¹ èµ„æº

- **å®˜æ–¹æ–‡æ¡£**ï¼šæŒç»­å…³æ³¨ LangGraph æ›´æ–°
- **ç¤¾åŒºè®¨è®º**ï¼šå‚ä¸ Discord/GitHub Discussions
- **å¼€æºé¡¹ç›®**ï¼šå­¦ä¹ ä¼˜ç§€çš„ LangGraph åº”ç”¨
- **å­¦æœ¯è®ºæ–‡**ï¼šç ”ç©¶è®°å¿†ç³»ç»Ÿçš„å‰æ²¿è¿›å±•

---

## åã€æˆå°±è§£é” ğŸ†

æ­å–œä½ å®Œæˆ Module-6ï¼ä½ å·²è§£é”ä»¥ä¸‹æˆå°±ï¼š

```
ğŸ“ è®°å¿†å¤§å¸ˆ
   æŒæ¡äº†çŸ­æœŸå’Œé•¿æœŸè®°å¿†ç³»ç»Ÿçš„æ„å»º

ğŸ—ï¸ æ¶æ„å¸ˆ
   èƒ½å¤Ÿè®¾è®¡ä¼ä¸šçº§çš„è®°å¿†æ¶æ„

ğŸ”§ å·¥ç¨‹å¸ˆ
   ç†Ÿç»ƒä½¿ç”¨ Storeã€Trustcallã€Pydantic

ğŸ’¡ åˆ›æ–°è€…
   ç†è§£å¦‚ä½•å°†è®¤çŸ¥ç§‘å­¦åº”ç”¨äº AI ç³»ç»Ÿ
```

**ä¸‹ä¸€ä¸ªæˆå°±**ï¼š**Multi-Agent åè°ƒè€…**ï¼ˆModule-7ï¼‰

---

**ç»§ç»­å‰è¿›ï¼Œæ¢ç´¢ AI Agent çš„æ›´å¤šå¯èƒ½æ€§ï¼** ğŸš€

---

*æœ¬æ–‡æ¡£æœ€åæ›´æ–°ï¼š2024-11*  
*LangGraph ç‰ˆæœ¬ï¼šv0.2.0+*  
*ä½œè€…ï¼šLangGraph æ•™å­¦å›¢é˜Ÿ*
