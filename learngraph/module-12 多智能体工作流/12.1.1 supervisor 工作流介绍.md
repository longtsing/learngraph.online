# 12.1 Supervisor 工作流介绍

## 多智能体架构概览

在多智能体系统中，有多种架构模式可以选择。本节重点介绍 **Supervisor（监督者）架构**，这是最常用且最实用的多智能体协作模式之一。

### 其他架构模式简介

除了 Supervisor 架构外，还有以下几种常见模式：

| 架构模式 | 简要说明 |
|---------|---------|
| **Parallel（并行）** | 多个 Agent 同时处理任务的不同部分 |
| **Sequential（顺序）** | Agent 按序执行，前一个的输出作为下一个的输入 |
| **Loop（循环）** | Agent 迭代改进输出，如代码编写+测试循环 |
| **Router（路由）** | 中央路由器根据任务类型分发给不同 Agent |
| **Aggregator（聚合）** | 多个 Agent 的输出被汇总合成最终结果 |
| **Network（网络）** | Agent 之间多对多直接通信，去中心化 |
| **Handoffs（交接）** | Agent 之间直接传递控制权 |

---

## 什么是 Supervisor 架构？

**Supervisor 架构**是一种集中式的多智能体协作模式。在这种架构中，有一个"监督者" Agent（通常由 LLM 驱动）负责：

1. **理解用户请求**
2. **决定调用哪个子 Agent**
3. **协调多个 Agent 的工作顺序**
4. **汇总结果返回给用户**

```
用户请求 → Supervisor（总调度）→ 选择合适的 Worker Agent → 执行任务 → 返回结果给 Supervisor → 汇总回复用户
```

### 架构示意图

```
                         ┌─────────────────┐
                         │   Supervisor    │
                         │   (LLM 决策)    │
                         └────────┬────────┘
                                  │
              ┌───────────────────┼───────────────────┐
              │                   │                   │
              ▼                   ▼                   ▼
        ┌──────────┐        ┌──────────┐        ┌──────────┐
        │ Agent 1  │        │ Agent 2  │        │ Agent 3  │
        │ (专业A)  │        │ (专业B)  │        │ (专业C)  │
        └──────────┘        └──────────┘        └──────────┘
```

---

## Supervisor 架构的核心优势

| 优势 | 说明 |
|------|------|
| **流程清晰可控** | 所有通信经过中心节点，便于追踪 |
| **易于调试和监控** | 可以在 Supervisor 层面观察所有交互 |
| **灵活的任务分配** | LLM 可以动态决定调用哪个 Agent |
| **支持并行执行** | 可以同时调用多个 Agent 处理不同子任务 |
| **支持 Map-Reduce** | 适合将大任务拆分、并行处理、再汇总 |

### 适用场景

- 任务有明确的阶段划分
- 需要协调多个专业领域（如日历、邮件、CRM）
- 需要严格的执行顺序控制
- 复杂任务需要分解后分发给不同专家

---

## Supervisor 架构的两种实现方式

### 方式一：基本 Supervisor 模式

在这种模式下，Agent 被定义为图的节点，Supervisor 节点（LLM）决定下一步调用哪个 Agent 节点。使用 `Command` 对象来路由执行流程。

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, MessagesState, START, END

model = ChatOpenAI()

def supervisor(state: MessagesState) -> Command[Literal["agent_1", "agent_2", END]]:
    """Supervisor 节点：决定下一步调用哪个 Agent"""
    # 将状态相关信息传给 LLM，让它决定下一步
    # 常见做法是使用结构化输出，强制返回 "next_agent" 字段
    response = model.invoke(...)

    # 根据 Supervisor 的决策路由到某个 Agent 或结束
    # 如果返回 "__end__"，图执行结束
    return Command(goto=response["next_agent"])

def agent_1(state: MessagesState) -> Command[Literal["supervisor"]]:
    """Agent 1：执行特定任务后返回 Supervisor"""
    response = model.invoke(...)
    return Command(
        goto="supervisor",
        update={"messages": [response]},
    )

def agent_2(state: MessagesState) -> Command[Literal["supervisor"]]:
    """Agent 2：执行特定任务后返回 Supervisor"""
    response = model.invoke(...)
    return Command(
        goto="supervisor",
        update={"messages": [response]},
    )

# 构建图
builder = StateGraph(MessagesState)
builder.add_node(supervisor)
builder.add_node(agent_1)
builder.add_node(agent_2)
builder.add_edge(START, "supervisor")

supervisor_graph = builder.compile()
```

**工作流程**：
1. 用户请求进入 Supervisor
2. Supervisor（LLM）分析请求，决定调用哪个 Agent
3. Agent 执行任务，返回结果给 Supervisor
4. Supervisor 决定是否需要继续调用其他 Agent，或结束并返回结果

---

### 方式二：Tool-Calling Supervisor 模式

这是 Supervisor 架构的一个变体：**将子 Agent 定义为工具（Tools）**，然后使用支持工具调用的 LLM 作为 Supervisor。这本质上是一个 ReAct 风格的 Agent。

```python
from typing import Annotated
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import InjectedState, create_react_agent

model = ChatOpenAI()

# 将 Agent 定义为工具函数
# 通过 InjectedState 注解可以将图状态传递给工具
def agent_1(state: Annotated[dict, InjectedState]):
    """Agent 1 作为工具：处理特定类型的任务"""
    response = model.invoke(...)
    # 返回字符串格式的响应（标准工具响应格式）
    # 会被自动转换为 ToolMessage
    return response.content

def agent_2(state: Annotated[dict, InjectedState]):
    """Agent 2 作为工具：处理另一类任务"""
    response = model.invoke(...)
    return response.content

# 将 Agent 作为工具注册
tools = [agent_1, agent_2]

# 使用预构建的 ReAct Agent 作为 Supervisor
# 它由两个节点组成：工具调用 LLM 节点（Supervisor）+ 工具执行节点
supervisor = create_react_agent(model, tools)
```

**这种方式的特点**：
- Supervisor 使用 LLM 的工具调用能力来选择 Agent
- 更简洁的实现方式
- Agent 的输入由 Supervisor 根据工具 schema 决定
- 可以通过 LangGraph 在运行时将状态传递给各个工具

---

## 层级式 Supervisor 架构（Hierarchical）

当系统变得更复杂时，单个 Supervisor 可能难以管理所有 Agent。这时可以采用**层级式架构**——多层 Supervisor 嵌套。

### 为什么需要层级式架构？

当你遇到以下问题时，说明需要升级到层级式架构：

- Supervisor 管理的 Agent 太多，决策质量下降
- 上下文变得过于复杂，单个 Supervisor 难以跟踪
- 不同领域的 Agent 之间需要更好的隔离

### 层级式架构示意

```
                              ┌─────────────────────┐
                              │  Top-Level          │
                              │  Supervisor         │
                              │  (总调度)           │
                              └──────────┬──────────┘
                                         │
              ┌──────────────────────────┼──────────────────────────┐
              │                          │                          │
              ▼                          ▼                          ▼
    ┌─────────────────┐        ┌─────────────────┐        ┌─────────────────┐
    │  Team 1         │        │  Team 2         │        │  Team 3         │
    │  Supervisor     │        │  Supervisor     │        │  Supervisor     │
    │  (研究团队)     │        │  (开发团队)     │        │  (运营团队)     │
    └────────┬────────┘        └────────┬────────┘        └────────┬────────┘
             │                          │                          │
      ┌──────┴──────┐            ┌──────┴──────┐            ┌──────┴──────┐
      │             │            │             │            │             │
      ▼             ▼            ▼             ▼            ▼             ▼
 ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
 │搜索专家 │  │论文分析 │  │前端开发 │  │后端开发 │  │数据分析 │  │报告生成 │
 └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────┘
```

### 层级式架构实现

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.types import Command

model = ChatOpenAI()

# ==================== Team 1 定义 ====================
def team_1_supervisor(state: MessagesState) -> Command[Literal["team_1_agent_1", "team_1_agent_2", END]]:
    response = model.invoke(...)
    return Command(goto=response["next_agent"])

def team_1_agent_1(state: MessagesState) -> Command[Literal["team_1_supervisor"]]:
    response = model.invoke(...)
    return Command(goto="team_1_supervisor", update={"messages": [response]})

def team_1_agent_2(state: MessagesState) -> Command[Literal["team_1_supervisor"]]:
    response = model.invoke(...)
    return Command(goto="team_1_supervisor", update={"messages": [response]})

# 构建 Team 1 子图
team_1_builder = StateGraph(MessagesState)
team_1_builder.add_node(team_1_supervisor)
team_1_builder.add_node(team_1_agent_1)
team_1_builder.add_node(team_1_agent_2)
team_1_builder.add_edge(START, "team_1_supervisor")
team_1_graph = team_1_builder.compile()

# ==================== Team 2 定义 ====================
# （类似 Team 1 的结构）
team_2_builder = StateGraph(MessagesState)
# ... 添加节点和边
team_2_graph = team_2_builder.compile()

# ==================== 顶层 Supervisor ====================
def top_level_supervisor(state: MessagesState) -> Command[Literal["team_1_graph", "team_2_graph", END]]:
    """顶层 Supervisor：决定将任务分配给哪个团队"""
    response = model.invoke(...)
    return Command(goto=response["next_team"])

# 构建顶层图
builder = StateGraph(MessagesState)
builder.add_node(top_level_supervisor)
builder.add_node("team_1_graph", team_1_graph)  # 子图作为节点
builder.add_node("team_2_graph", team_2_graph)  # 子图作为节点
builder.add_edge(START, "top_level_supervisor")
builder.add_edge("team_1_graph", "top_level_supervisor")  # 执行完返回顶层
builder.add_edge("team_2_graph", "top_level_supervisor")

graph = builder.compile()
```

### 层级式架构的优缺点

**优点**：
- 清晰的角色和职责划分
- 流程化的通信机制
- 适合大型系统和结构化决策流程
- 每层可以独立测试和优化

**缺点**：
- 上层失败可能影响整个系统
- 底层 Agent 独立性有限
- 架构复杂度增加

---

## Agent 间的通信方式

### 方式一：通过图状态（Graph State）通信

Agent 通过共享的图状态进行通信。每个 Agent 节点接收当前状态，执行后更新状态传给下一个节点。

```python
class SupervisorState(TypedDict):
    messages: List[BaseMessage]  # 消息历史
    current_task: str            # 当前任务
    results: Dict[str, Any]      # 各 Agent 的结果
```

### 方式二：通过工具调用（Tool Calls）通信

在 Tool-Calling Supervisor 模式下，通信的"载荷"是工具调用参数。

### 共享消息列表的两种策略

当 Agent 通过共享消息列表通信时，需要决定共享范围：

| 策略 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **共享完整历史** | Agent 共享完整的思考过程 | 其他 Agent 可以参考完整上下文做更好的决策 | 随着 Agent 数量增加，上下文会快速膨胀 |
| **只共享最终结果** | Agent 有私有"草稿本"，只共享结论 | 控制上下文大小，适合复杂系统 | 可能丢失有价值的中间信息 |

---

## 实战案例：三层 Supervisor 架构

这是一个完整的实现示例，展示 Supervisor 模式的三层架构：

```
┌─────────────────────────────────────────────────────────────┐
│  第三层：Supervisor Agent                                    │
│  - 理解用户自然语言请求                                       │
│  - 决定调用哪个专业 Agent                                     │
│  - 汇总结果回复用户                                          │
├─────────────────────────────────────────────────────────────┤
│  第二层：专业子 Agent（Calendar Agent、Email Agent）           │
│  - 接收自然语言请求                                          │
│  - 转换为结构化的工具调用                                     │
│  - 处理领域特定逻辑                                          │
├─────────────────────────────────────────────────────────────┤
│  第一层：底层 API 工具                                        │
│  - 需要精确格式的输入（ISO 日期、邮件地址等）                   │
│  - 执行实际操作                                              │
└─────────────────────────────────────────────────────────────┘
```

### Step 1：定义底层 API 工具

```python
from langchain.tools import tool

@tool
def create_calendar_event(
    title: str,
    start_time: str,  # ISO 格式：2025-01-15T14:00:00
    end_time: str,
    attendees: list[str],
) -> str:
    """创建日历事件"""
    return f"事件已创建: {title}"

@tool
def send_email(
    to: list[str],
    subject: str,
    body: str,
) -> str:
    """发送邮件"""
    return f"邮件已发送给: {', '.join(to)}"
```

### Step 2：创建专业子 Agent

```python
from langchain.agents import create_agent

# 日历专家
calendar_agent = create_agent(
    model="openai:gpt-4o",
    tools=[create_calendar_event],
    system_prompt="你是日历管理专家，负责将自然语言日期解析为 ISO 格式。"
)

# 邮件专家
email_agent = create_agent(
    model="openai:gpt-4o",
    tools=[send_email],
    system_prompt="你是邮件撰写专家，负责撰写专业得体的邮件。"
)
```

### Step 3：将子 Agent 包装为 Supervisor 的工具

```python
@tool
def schedule_event(request: str) -> str:
    """处理日程安排请求"""
    result = calendar_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].text

@tool
def manage_email(request: str) -> str:
    """处理邮件相关请求"""
    result = email_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].text
```

### Step 4：创建 Supervisor Agent

```python
supervisor_agent = create_agent(
    model="openai:gpt-4o",
    tools=[schedule_event, manage_email],
    system_prompt="""你是智能个人助手，负责协调日程和邮件管理。

    对于复合请求（如"安排会议并发邮件通知"），请依次调用多个工具。"""
)
```

### Step 5：运行示例

```python
# 复合请求示例
result = supervisor_agent.invoke({
    "messages": [{
        "role": "user",
        "content": "安排下周一上午10点与设计团队的评审会议，然后给他们发邮件提醒"
    }]
})

# 执行流程：
# Supervisor → schedule_event → calendar_agent → create_calendar_event
#           → manage_email → email_agent → send_email
```

---

## 何时选择 Supervisor 架构？

| 场景 | 推荐方案 |
|------|---------|
| 工具少于 5 个，任务简单 | 单 Agent 即可 |
| 工具 5-15 个，有明确分类 | **Supervisor + 2-3 个专业 Agent** |
| 工具 15+ 个，多领域复杂任务 | **层级式 Supervisor 架构** |
| 需要 Agent 直接与用户交互 | Handoffs 模式 |

---

## 关键设计原则

### 1. 工具/Agent 命名要清晰

子 Agent 的名称和描述**直接影响** Supervisor 的路由决策：

```python
# ❌ 不好的命名
@tool("agent1", description="处理一些事情")
def bad_agent(): ...

# ✅ 好的命名
@tool(
    "financial_analyst",
    description="分析财务报表、计算投资回报率、生成财务预测报告。适用于财务数据分析请求。"
)
def good_agent(): ...
```

### 2. 控制信息流

- **输入控制**：决定子 Agent 能看到多少上下文
- **输出控制**：决定子 Agent 返回什么给 Supervisor

### 3. 避免 Supervisor 过载

当 Supervisor 管理的 Agent 太多时，考虑：
- 升级为层级式架构
- 将相关 Agent 分组到团队中
- 使用更专业的子 Supervisor

---

## 延伸阅读

- [LangGraph 多智能体概念](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)
- [Supervisor 模式教程](https://docs.langchain.com/oss/python/langchain/supervisor)

---

> **下一节预告**：我们将通过完整的代码案例，手把手实现一个 Supervisor 多智能体系统。