# 基础案例1：水果店流水线

在正式进入复杂的 LangGraph 案例之前，我们先通过一个简单有趣的例子来理解 LangGraph 的核心概念。这个案例模拟了一个「水果店流水线」，帮助你理解 LangGraph 中**状态（State）**、**节点（Node）**和**边（Edge）**这三个核心概念。

## 案例概览

这个案例做的事情很简单：
- 用户输入一个水果名称（比如"苹果"）
- 经过 3 个节点的加工处理
- 最终输出一句完整的话："苹果水果店的水果很新鲜，处理完毕"

整个流程就像一条流水线：**输入 → 加工 → 加工 → 加工 → 输出**

## Graph 架构图

下图展示了整个流程的结构：

![Graph 架构图](./8.0.1-graph-architecture.png)

可以看到：
- `__start__` 是起点（对应代码中的 `START`）
- `node_1`、`node_2`、`node_3` 是三个处理节点
- `__end__` 是终点（对应代码中的 `END`）
- 箭头表示数据流动的方向

---

## 知识点拆解

### 1. 导入必要的模块

```python
from typing import TypedDict
from langgraph.constants import END, START
from langgraph.graph import StateGraph
```

**解释：**

| 导入项 | 作用 |
|--------|------|
| `TypedDict` | Python 标准库，用于定义带类型提示的字典 |
| `START` | LangGraph 常量，表示图的起点 |
| `END` | LangGraph 常量，表示图的终点 |
| `StateGraph` | LangGraph 核心类，用于构建状态图 |

> **小白提示**：`TypedDict` 让我们可以明确告诉 Python："这个字典里有哪些 key，每个 key 对应什么类型的值"。这样代码更清晰，IDE 也能给你更好的提示。

---

### 2. 定义状态类型

在 LangGraph 中，**状态（State）** 是贯穿整个流程的数据容器。我们需要定义几种不同用途的状态：

#### 2.1 输入状态 (InputState)

```python
class InputState(TypedDict):
    user_input: str  # 用户输入的文本
```

**作用**：定义用户传入 Graph 的数据格式。

**类比**：就像快递单上的"寄件人信息"，告诉系统输入长什么样。

#### 2.2 输出状态 (OutputState)

```python
class OutputState(TypedDict):
    graph_output: str  # Graph 最终输出的结果
```

**作用**：定义 Graph 最终返回给用户的数据格式。

**类比**：就像快递单上的"收件人信息"，告诉系统最终要输出什么。

#### 2.3 整体状态 (OverallState)

```python
class OverallState(TypedDict):
    foo: str          # 中间处理的变量
    user_input: str   # 用户原始输入
    graph_output: str # 最终输出
```

**作用**：包含了整个流程中所有需要用到的数据字段。这是 LangGraph 的核心——**状态会在节点之间传递和更新**。

**类比**：就像工厂流水线上的"工作台"，每个工人（节点）都可以看到和修改工作台上的东西。

#### 2.4 私有状态 (PrivateState)

```python
class PrivateState(TypedDict):
    bar: str  # 仅某些节点使用的变量
```

**作用**：存储中间处理结果，但不会暴露在最终输出中。

**类比**：就像流水线上的临时便签纸，只在特定工序使用，最后不会交给客户。

---

### 3. 定义处理节点

节点是 LangGraph 中的"工人"，负责处理数据。每个节点都是一个函数：

#### 节点 1：生成店名

```python
def node_1(state: InputState) -> OverallState:
    return {
        "foo": state["user_input"] + "水果店"
    }
```

**做了什么**：
- 输入：`"苹果"`
- 输出：`{"foo": "苹果水果店"}`

**Python 知识点**：
- 函数参数 `state: InputState` 表示接收一个 InputState 类型的参数
- `-> OverallState` 表示函数返回一个 OverallState 类型的值
- `state["user_input"]` 是从字典中取值

#### 节点 2：添加描述

```python
def node_2(state: OverallState) -> PrivateState:
    return {
        "bar": state["foo"] + "的水果很新鲜"
    }
```

**做了什么**：
- 输入：`{"foo": "苹果水果店"}`
- 输出：`{"bar": "苹果水果店的水果很新鲜"}`

#### 节点 3：完成处理

```python
def node_3(state: PrivateState) -> OutputState:
    return {
        "graph_output": state["bar"] + "，处理完毕"
    }
```

**做了什么**：
- 输入：`{"bar": "苹果水果店的水果很新鲜"}`
- 输出：`{"graph_output": "苹果水果店的水果很新鲜，处理完毕"}`

---

### 4. 构建 StateGraph

现在我们有了所有的"零件"，接下来要把它们组装起来：

```python
builder = StateGraph(
    OverallState,        # 整体状态类型
    input=InputState,    # 输入类型
    output=OutputState   # 输出类型
)
```

**解释**：
- `StateGraph` 是构建器，我们用它来搭建流程图
- `OverallState` 是主状态，所有节点共享
- `input=InputState` 告诉 Graph 接受什么格式的输入
- `output=OutputState` 告诉 Graph 返回什么格式的输出

> **注意**：LangGraph V0.5 之后，`input` 和 `output` 参数被重命名为 `input_schema` 和 `output_schema`。

---

### 5. 添加节点

```python
builder.add_node("node_1", node_1)  # 添加节点1
builder.add_node("node_2", node_2)  # 添加节点2
builder.add_node("node_3", node_3)  # 添加节点3
```

**解释**：
- 第一个参数是节点的**名称**（字符串，用于后续连接）
- 第二个参数是节点的**处理函数**

**类比**：就像给流水线上的每个工位起名字，方便后续安排工作顺序。

---

### 6. 添加边（连接节点）

```python
builder.add_edge(START, "node_1")    # 起点 → node_1
builder.add_edge("node_1", "node_2") # node_1 → node_2
builder.add_edge("node_2", "node_3") # node_2 → node_3
builder.add_edge("node_3", END)      # node_3 → 终点
```

**解释**：
- `add_edge(A, B)` 表示从 A 节点连接到 B 节点
- `START` 和 `END` 是特殊的常量，表示图的起点和终点
- 边决定了节点的**执行顺序**

**类比**：就像在流水线上安排传送带，决定产品从哪个工位流向下一个工位。

---

### 7. 编译并运行

```python
# 编译 Graph
graph = builder.compile()

# 运行 Graph
result = graph.invoke({"user_input": "苹果"})
print(result)
```

**输出结果**：
```python
{'graph_output': '苹果水果店的水果很新鲜，处理完毕'}
```

**解释**：
- `compile()` 将构建器转换为可执行的 Graph
- `invoke()` 是调用 Graph 的方法，传入输入数据，返回输出结果

---

## 数据流转过程

让我们跟踪一下数据是如何在整个流程中流转的：

```
输入: {"user_input": "苹果"}
    ↓
[node_1] 处理后状态: {"foo": "苹果水果店", "user_input": "苹果"}
    ↓
[node_2] 处理后状态: {"foo": "苹果水果店", "bar": "苹果水果店的水果很新鲜", ...}
    ↓
[node_3] 处理后状态: {..., "graph_output": "苹果水果店的水果很新鲜，处理完毕"}
    ↓
输出: {"graph_output": "苹果水果店的水果很新鲜，处理完毕"}
```

注意：
- 每个节点只返回它**修改或新增**的字段
- LangGraph 会自动将返回值**合并**到整体状态中
- 最终输出只包含 `OutputState` 中定义的字段

---

## 核心概念总结

| 概念 | 说明 | 类比 |
|------|------|------|
| **State（状态）** | 在节点之间传递的数据容器 | 流水线上的工作台 |
| **Node（节点）** | 处理数据的函数 | 流水线上的工人 |
| **Edge（边）** | 连接节点，决定执行顺序 | 流水线上的传送带 |
| **StateGraph** | 用于构建和组织整个流程 | 流水线的设计图 |
| **compile()** | 将设计图转换为可运行的流程 | 流水线开始运转 |
| **invoke()** | 执行整个流程 | 投入原料，产出成品 |

---

## 思考题

1. 如果我们想在 node_2 和 node_3 之间插入一个新节点，需要修改哪些代码？
2. 如果想让 Graph 同时输出 `foo` 和 `graph_output`，应该怎么修改 `OutputState`？
3. 为什么需要区分 InputState、OutputState、OverallState 和 PrivateState？直接用一个大的 State 不行吗？

---

## 下一步

理解了这个基础案例后，你就掌握了 LangGraph 最核心的概念。接下来的案例会在此基础上，引入更多高级特性：
- **条件边（Conditional Edge）**：根据条件选择不同的执行路径
- **循环（Loop）**：让 Agent 可以反复思考和行动
- **人机协作（Human-in-the-loop）**：让人类参与决策过程
---

# 基础案例2：消息累加器

在案例一中，我们学习了 LangGraph 的基础概念：State、Node 和 Edge。现在我们来学习一个更高级的特性——**状态合并策略（Reducer）**。

## 案例概览

这个案例演示了 LangGraph 中一个非常重要的概念：**不同字段可以有不同的更新策略**。

- 有些字段每次更新会**覆盖**原值（普通模式）
- 有些字段每次更新会**追加**到列表（累加模式）

就像一个聊天记录：
- 消息是**不断追加**的（不会覆盖之前的聊天记录）
- 而在线状态是**直接覆盖**的（只需要知道当前状态）

## Graph 架构图

![Graph 架构图](./8.0.1-2-graph-architecture.png)

这个图比案例一更简单：只有两个节点 `node1` 和 `node2`，按顺序执行。

---

## 核心概念：Annotated 和 Reducer

### 什么是 Reducer？

在 LangGraph 中，**Reducer** 是一种规则，告诉系统**如何合并新旧状态**。

```python
from typing import Annotated
from operator import add
from langgraph.graph.message import add_messages
```

| 导入项 | 作用 |
|--------|------|
| `Annotated` | Python 类型注解，用于给字段附加额外信息 |
| `add` | Python 内置函数，用于列表拼接 |
| `add_messages` | LangGraph 专用，智能合并消息列表 |

---

## 知识点拆解

### 1. 定义带 Reducer 的 State

```python
from langchain_core.messages import AnyMessage, AIMessage
from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from typing import Annotated, TypedDict
from operator import add

class State(TypedDict):
    # 消息列表：使用 add_messages 作为 reducer
    messages: Annotated[list[AnyMessage], add_messages]

    # 字符串列表：使用 add 作为 reducer
    list_field: Annotated[list[str], add]

    # 普通字段：没有 reducer，直接覆盖
    another_field: int
```

**解释**：

| 字段 | 类型 | Reducer | 更新行为 |
|------|------|---------|----------|
| `messages` | `list[AnyMessage]` | `add_messages` | 智能追加消息 |
| `list_field` | `list[str]` | `add` | 简单列表拼接 |
| `another_field` | `int` | 无 | 直接覆盖 |

> **小白提示**：`Annotated[类型, reducer]` 的格式就像给字段贴一个"处理标签"。当 LangGraph 更新这个字段时，会按照标签上的规则来处理。

---

### 2. add vs add_messages 的区别

#### `add`（简单拼接）

```python
# 原值: ['a', 'b', 'c']
# 新值: ['d']
# 结果: ['a', 'b', 'c', 'd']
```

`add` 就是 Python 的 `+` 操作符，简单粗暴地把两个列表接在一起。

#### `add_messages`（智能合并）

`add_messages` 是 LangGraph 专门为消息设计的，它有更智能的行为：
- 自动给每条消息分配唯一 ID
- 如果新消息的 ID 和旧消息相同，会**更新**而不是追加
- 支持各种消息类型（HumanMessage、AIMessage 等）

---

### 3. 定义节点

```python
def node1(state: State):
    """
    node1:
    - 创建一条 AI 消息 "Hello"
    - list_field 追加 ['d']
    - another_field 设为 1
    """
    new_message = AIMessage("Hello")
    return {
        "messages": [new_message],
        "list_field": ['d'],
        "another_field": 1
    }


def node2(state: State):
    """
    node2:
    - 创建一条 AI 消息 "LangGraph"
    - list_field 追加 ['f']
    - another_field 设为 2（会覆盖 node1 的值）
    """
    new_message = AIMessage("LangGraph")
    return {
        "messages": [new_message],
        "list_field": ['f'],
        "another_field": 2
    }
```

**关键点**：
- 节点只需返回**要更新的字段**
- LangGraph 会根据每个字段的 Reducer 自动决定如何合并

---

### 4. 构建 Graph（链式写法）

```python
graph = (
    StateGraph(State)
        .add_node("node1", node1)
        .add_node("node2", node2)
        .set_entry_point("node1")
        .add_edge("node1", "node2")
        .compile()
)
```

**解释**：

这是一种**链式调用**的写法，等价于：

```python
builder = StateGraph(State)
builder.add_node("node1", node1)
builder.add_node("node2", node2)
builder.set_entry_point("node1")  # 等价于 add_edge(START, "node1")
builder.add_edge("node1", "node2")
graph = builder.compile()
```

> **小白提示**：链式调用让代码更紧凑，但可读性见仁见智。两种写法效果完全一样。

---

### 5. 运行 Graph

```python
input_message = {"role": "user", "content": "Hello"}

result = graph.invoke({
    "messages": [input_message],
    "list_field": ['a', 'b', 'c']
})

print(result)
```

**输出结果**：

```python
{
    'messages': [
        HumanMessage(content='Hello', id='7c4962f7-...'),
        AIMessage(content='Hello', id='18244cc5-...'),
        AIMessage(content='LangGraph', id='ecb626fd-...')
    ],
    'list_field': ['a', 'b', 'c', 'd', 'f'],
    'another_field': 2
}
```

---

## 数据流转过程

让我们详细跟踪每个字段的变化：

```
初始输入:
  messages: [HumanMessage("Hello")]
  list_field: ['a', 'b', 'c']
  another_field: (未设置)
    ↓
[node1] 返回: {messages: [AIMessage("Hello")], list_field: ['d'], another_field: 1}
    ↓
合并后状态:
  messages: [HumanMessage("Hello"), AIMessage("Hello")]  ← 追加了一条
  list_field: ['a', 'b', 'c', 'd']                       ← 追加了 'd'
  another_field: 1                                        ← 设置为 1
    ↓
[node2] 返回: {messages: [AIMessage("LangGraph")], list_field: ['f'], another_field: 2}
    ↓
最终状态:
  messages: [HumanMessage, AIMessage, AIMessage]  ← 又追加了一条
  list_field: ['a', 'b', 'c', 'd', 'f']           ← 追加了 'f'
  another_field: 2                                 ← 被覆盖为 2
```

**观察要点**：
- `messages` 和 `list_field` 是**累加**的
- `another_field` 是**覆盖**的（最终值是 node2 设置的 2，而不是 node1 的 1）

---

## Reducer 对比表

| 更新方式 | 使用场景 | 示例 |
|----------|----------|------|
| **无 Reducer（覆盖）** | 状态值、计数器、配置 | `another_field: int` |
| **add（简单追加）** | 日志、标签列表 | `list_field: Annotated[list[str], add]` |
| **add_messages（智能追加）** | 聊天记录 | `messages: Annotated[list[AnyMessage], add_messages]` |

---

## 思考题

1. 如果我们想让 `another_field` 也变成累加模式（每次加 1），应该怎么写 Reducer？
2. `add_messages` 在什么情况下会**更新**消息而不是追加？
3. 如果 node2 不返回 `another_field`，最终的 `another_field` 值会是多少？

---

## 案例二完整代码

```python
from langchain_core.messages import AnyMessage, AIMessage
from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from typing import Annotated, TypedDict
from operator import add


# ============================================
# 1. 定义 State（整体状态结构）
# ============================================
class State(TypedDict):
    # messages 字段：存放消息列表
    messages: Annotated[list[AnyMessage], add_messages]

    # list_field：一个字符串列表
    list_field: Annotated[list[str], add]

    # 普通字段，不参与合并
    another_field: int


# ============================================
# 2. 定义节点 node1
# ============================================
def node1(state: State):
    """
    node1:
    - 创建新的 AIMessage("Hello")
    - list_field 追加 ['d']
    - another_field = 1
    """
    new_message = AIMessage("Hello")
    return {
        "messages": [new_message],
        "list_field": ['d'],
        "another_field": 1
    }


# ============================================
# 3. 定义节点 node2
# ============================================
def node2(state: State):
    """
    node2:
    - 创建新的 AIMessage("LangGraph")
    - list_field 追加 ['f']
    - another_field = 2（此字段直接覆盖前面的）
    """
    new_message = AIMessage("LangGraph")
    return {
        "messages": [new_message],
        "list_field": ['f'],
        "another_field": 2
    }


# ============================================
# 4. 构建状态图（StateGraph）
# ============================================
graph = (
    StateGraph(State)
        .add_node("node1", node1)
        .add_node("node2", node2)
        .set_entry_point("node1")
        .add_edge("node1", "node2")
        .compile()
)


# ============================================
# 5. 调用 Graph
# ============================================
input_message = {"role": "user", "content": "Hello"}

result = graph.invoke({
    "messages": [input_message],
    "list_field": ['a', 'b', 'c']
})

print(result)

# ================================
# 打印 result 内各个字段的内容
# ================================
print("\n===== State 字段逐项打印 =====")
print("messages:")
for msg in result["messages"]:
    print("  -", msg)

print("list_field:", result["list_field"])
print("another_field:", result["another_field"])


# 可视化图结构
from IPython.display import Image, display
display(Image(graph.get_graph(xray=True).draw_mermaid_png()))
```

---

## 下一步

现在你已经掌握了：
- ✅ State、Node、Edge 基础概念
- ✅ Reducer 和状态合并策略

接下来的案例会介绍更高级的特性，比如条件分支和循环！
