# 5.4 Memory Schema - Collection - è¯¦ç»†è§£è¯»

---

## ğŸ“š æœ¯è¯­è¡¨

| æœ¯è¯­åç§° | LangGraph å®šä¹‰å’Œè§£è¯» | Python å®šä¹‰å’Œè¯´æ˜ | é‡è¦ç¨‹åº¦ |
|---------|---------------------|------------------|---------|
| **Collection Schema** | å¤šä¸ªç‹¬ç«‹è®°å¿†é¡¹çš„é›†åˆæ¨¡å¼ï¼Œæ¯ä¸ªé¡¹ç›®ä½¿ç”¨ UUID é”®ç‹¬ç«‹å­˜å‚¨ï¼Œæ”¯æŒæ— é™æ‰©å±• | ä½¿ç”¨ Pydantic BaseModel å®šä¹‰å•ä¸ªé¡¹ç›®ç»“æ„ï¼Œå¦‚ `Memory(content: str)` | â­â­â­â­â­ |
| **UUIDï¼ˆé€šç”¨å”¯ä¸€è¯†åˆ«ç ï¼‰** | å…¨å±€å”¯ä¸€çš„ 128 ä½æ ‡è¯†ç¬¦ï¼Œç”¨äºæ ‡è¯† Collection ä¸­çš„æ¯ä¸ªç‹¬ç«‹è®°å¿†é¡¹ | `uuid.uuid4()` ç”Ÿæˆï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²ä½œä¸º Store çš„é”®ï¼Œå¦‚ `str(uuid.uuid4())` | â­â­â­â­â­ |
| **enable_inserts** | Trustcall å‚æ•°ï¼Œè®¾ä¸º True æ—¶å…è®¸æ’å…¥æ–°çš„ç‹¬ç«‹é¡¹ç›®ï¼ˆCollection æ¨¡å¼å¿…éœ€ï¼‰ | `create_extractor(model, tools=[Memory], enable_inserts=True)`ï¼Œæ”¯æŒå¹¶è¡Œåˆ›å»ºå¤šä¸ªå¯¹è±¡ | â­â­â­â­â­ |
| **json_doc_id** | Trustcall è¿”å›å…ƒæ•°æ®ä¸­çš„å­—æ®µï¼Œæ ‡è¯†æ›´æ–°æ“ä½œçš„ç›®æ ‡å¯¹è±¡ ID | åœ¨ `response_metadata` ä¸­ï¼Œå¦‚ `{"id": "...", "json_doc_id": "existing_key"}`ï¼Œæœ‰åˆ™æ›´æ–°ï¼Œæ— åˆ™æ’å…¥ | â­â­â­â­â­ |
| **å¹¶è¡Œå·¥å…·è°ƒç”¨ï¼ˆParallel Tool Callingï¼‰** | Trustcall åŒæ—¶è°ƒç”¨å¤šä¸ªå·¥å…·å®ä¾‹ï¼Œå¤„ç†æ›´æ–°å’Œæ’å…¥æ“ä½œ | ä¸€æ¬¡è°ƒç”¨è¿”å›å¤šä¸ªå“åº”ï¼Œå¦‚ `result["responses"]` åŒ…å«å¤šä¸ª Memory å¯¹è±¡ | â­â­â­â­ |
| **existing æ ¼å¼ï¼ˆCollectionï¼‰** | Collection æ¨¡å¼ä¸‹ Trustcall çš„ existing å‚æ•°æ ¼å¼ï¼Œä½¿ç”¨åˆ—è¡¨çš„ä¸‰å…ƒç»„ | æ ¼å¼ï¼š`[(key, "ToolName", data), ...]`ï¼Œå¦‚ `[("uuid1", "Memory", {...}), ("uuid2", "Memory", {...})]` | â­â­â­â­â­ |
| **merge_message_runs()** | LangChain å‡½æ•°ï¼Œåˆå¹¶è¿ç»­çš„ç›¸åŒè§’è‰²æ¶ˆæ¯ï¼Œå‡å°‘æ¶ˆæ¯æ•°é‡ | `from langchain_core.messages import merge_message_runs`ï¼Œåˆå¹¶å¦‚ `[HumanMessage, HumanMessage]` ä¸ºå•ä¸ªæ¶ˆæ¯ | â­â­â­ |
| **Profile vs Collection** | Profile æ˜¯å•ä¸€å¯¹è±¡ï¼ˆå›ºå®šé”®ï¼‰ï¼ŒCollection æ˜¯å¤šä¸ªç‹¬ç«‹é¡¹ï¼ˆUUID é”®ï¼‰ | Profile é€‚åˆå›ºå®šç»“æ„ï¼ˆç”¨æˆ·èµ„æ–™ï¼‰ï¼ŒCollection é€‚åˆå¼€æ”¾å¼æ‰©å±•ï¼ˆç¬”è®°ã€ä»»åŠ¡ï¼‰ | â­â­â­â­â­ |
| **search() éå†** | Collection æ¨¡å¼ä¸‹ä½¿ç”¨ search() è·å–æ‰€æœ‰è®°å¿†é¡¹ï¼Œè€Œé get() å•ä¸ªå¯¹è±¡ | `store.search(namespace)` è¿”å›åˆ—è¡¨ï¼Œéœ€éå†ï¼š`for item in items: item.value["content"]` | â­â­â­â­ |
| **rmeta.get()** | Python å­—å…¸çš„å®‰å…¨è·å–æ–¹æ³•ï¼Œç”¨äºåˆ¤æ–­æ˜¯æ›´æ–°è¿˜æ˜¯æ’å…¥æ“ä½œ | `rmeta.get("json_doc_id", str(uuid.uuid4()))`ï¼Œæœ‰ json_doc_id ç”¨ç°æœ‰é”®ï¼Œå¦åˆ™ç”Ÿæˆæ–° UUID | â­â­â­â­â­ |
| **zip() å‡½æ•°** | Python å†…ç½®å‡½æ•°ï¼Œå¹¶è¡Œè¿­ä»£å¤šä¸ªåºåˆ—ï¼Œç”¨äºåŒæ—¶å¤„ç†å“åº”å’Œå…ƒæ•°æ® | `for r, rmeta in zip(responses, metadata)`ï¼Œé…å¯¹å¤„ç†æ¯ä¸ªå“åº”åŠå…¶å…ƒæ•°æ® | â­â­â­â­ |
| **æ ¼å¼åŒ–ç”Ÿæˆå™¨** | Python ç”Ÿæˆå™¨è¡¨è¾¾å¼ï¼Œç”¨äºé«˜æ•ˆæ ¼å¼åŒ–è®°å¿†åˆ—è¡¨ | `"\n".join(f"- {mem.value['content']}" for mem in memories)`ï¼Œä¸€è¡Œä»£ç æ ¼å¼åŒ–æ‰€æœ‰è®°å¿† | â­â­â­ |

---

## ä¸€ã€æ¦‚è¿°

![Collection Schema Architecture](https://cdn.prod.website-files.com/65b8cd72835ceeacd4449a53/6732d0876d3daa19fef993ba_Screenshot%202024-11-11%20at%207.50.21%E2%80%AFPM.png)

### 1.1 æœ¬èŠ‚ç®€ä»‹

æœ¬èŠ‚æ˜¯ LangChain Academy Module-5 çš„ç¬¬å››éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯æœ€åä¸€éƒ¨åˆ†ï¼Œä¸»è¦å†…å®¹æ˜¯å°†è®°å¿†ä»**å•ä¸€ Profileï¼ˆç”¨æˆ·èµ„æ–™ï¼‰** è½¬å˜ä¸º **Collectionï¼ˆè®°å¿†é›†åˆï¼‰**ï¼Œå®ç°æ›´çµæ´»å’Œå¯æ‰©å±•çš„è®°å¿†ç®¡ç†ç³»ç»Ÿã€‚

### 1.2 Profile vs Collectionï¼šæ ¸å¿ƒåŒºåˆ«

è¿™æ˜¯ç†è§£æœ¬èŠ‚çš„å…³é”®ï¼è®©æˆ‘ä»¬å…ˆæ˜ç¡®è¿™ä¸¤ç§è®°å¿†æ¨¡å¼çš„æœ¬è´¨åŒºåˆ«ï¼š

#### Profileï¼ˆå•ä¸€å¯¹è±¡ï¼‰

**5.3 èŠ‚çš„ Profile æ¨¡å¼**ï¼š

```python
# å•ä¸€çš„ç”¨æˆ·èµ„æ–™å¯¹è±¡
{
    "user_name": "Lance",
    "user_location": "San Francisco",
    "interests": ["biking", "bakeries"]
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… å›ºå®šç»“æ„
- âœ… å­—æ®µæ˜ç¡®
- âœ… æ›´æ–°æ—¶ä¿®æ”¹ç‰¹å®šå­—æ®µ
- âŒ ä¸é€‚åˆå¼€æ”¾å¼ä¿¡æ¯æ”¶é›†
- âŒ éš¾ä»¥æ·»åŠ æ–°ç±»å‹çš„ä¿¡æ¯

**ç±»æ¯”**ï¼šå°±åƒä¸€å¼ å›ºå®šæ ¼å¼çš„è¡¨å•ã€‚

#### Collectionï¼ˆè®°å¿†é›†åˆï¼‰

**5.4 èŠ‚çš„ Collection æ¨¡å¼**ï¼š

```python
# å¤šä¸ªç‹¬ç«‹çš„è®°å¿†é¡¹
[
    {"content": "User's name is Lance."},
    {"content": "Lance likes to bike around San Francisco."},
    {"content": "Lance enjoys going to bakeries."}
]
```

**ç‰¹ç‚¹**ï¼š
- âœ… çµæ´»ç»“æ„
- âœ… å¯ä»¥æ— é™æ‰©å±•
- âœ… æ¯ä¸ªè®°å¿†ç‹¬ç«‹å­˜å‚¨
- âœ… å¯ä»¥æ·»åŠ ä»»ä½•ç±»å‹çš„æ–°è®°å¿†
- âœ… æ”¯æŒå¹¶è¡Œæ›´æ–°å’Œæ’å…¥

**ç±»æ¯”**ï¼šå°±åƒä¸€ä¸ªç¬”è®°æœ¬ï¼Œå¯ä»¥ä¸æ–­æ·»åŠ æ–°ç¬”è®°ã€‚

### 1.3 ç›´è§‚å¯¹æ¯”

```
Profile æ¨¡å¼ï¼ˆ5.3ï¼‰              Collection æ¨¡å¼ï¼ˆ5.4ï¼‰
    â†“                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·èµ„æ–™      â”‚            â”‚  è®°å¿† 1        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚  content: ...  â”‚
â”‚  â”‚ name     â”‚  â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚ location â”‚  â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ interestsâ”‚  â”‚            â”‚  è®°å¿† 2        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚  content: ...  â”‚
â”‚  å•ä¸€å¯¹è±¡      â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  è®°å¿† 3        â”‚
æ›´æ–° = ä¿®æ”¹å­—æ®µ                â”‚  content: ...  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              å¤šä¸ªç‹¬ç«‹å¯¹è±¡

                              æ›´æ–° = ä¿®æ”¹ç°æœ‰é¡¹
                              æ’å…¥ = æ·»åŠ æ–°é¡¹
```

### 1.4 å­¦ä¹ ç›®æ ‡

é€šè¿‡å­¦ä¹ æœ¬èŠ‚å†…å®¹ï¼Œä½ å°†æŒæ¡ï¼š

1. **Collection Schema çš„å®šä¹‰å’Œä½¿ç”¨**
2. **`enable_inserts=True` å‚æ•°çš„ä½œç”¨**
3. **å¦‚ä½•ä½¿ç”¨ UUID ç®¡ç†å¤šä¸ªè®°å¿†é¡¹**
4. **Trustcall å¦‚ä½•åŒæ—¶å¤„ç†æ›´æ–°å’Œæ’å…¥**
5. **ä½•æ—¶ä½¿ç”¨ Profileï¼Œä½•æ—¶ä½¿ç”¨ Collection**

### 1.5 åº”ç”¨åœºæ™¯

**Collection é€‚åˆçš„åœºæ™¯**ï¼š

| åœºæ™¯ | ä¸ºä»€ä¹ˆç”¨ Collection |
|------|-------------------|
| å­¦ä¹ ç¬”è®° | å¯ä»¥ä¸æ–­æ·»åŠ æ–°çŸ¥è¯†ç‚¹ |
| å¯¹è¯è®°å½• | ä¿å­˜é‡è¦çš„å¯¹è¯ç‰‡æ®µ |
| ç”¨æˆ·åé¦ˆ | æ”¶é›†å¤šæ¡åé¦ˆæ„è§ |
| å¾…åŠäº‹é¡¹ | æ·»åŠ å’Œç®¡ç†å¤šä¸ªä»»åŠ¡ |
| å¼€æ”¾å¼é—®ç­” | è®°å½•ç”¨æˆ·çš„å„ç§é—®é¢˜ |

**Profile é€‚åˆçš„åœºæ™¯**ï¼š

| åœºæ™¯ | ä¸ºä»€ä¹ˆç”¨ Profile |
|------|-----------------|
| ç”¨æˆ·èµ„æ–™ | å›ºå®šå­—æ®µï¼ˆå§“åã€å¹´é¾„ç­‰ï¼‰ |
| ç³»ç»Ÿé…ç½® | ç»“æ„åŒ–çš„è®¾ç½®é¡¹ |
| è®¤è¯ä¿¡æ¯ | æ˜ç¡®çš„å‡­è¯å­—æ®µ |

---

## äºŒã€Collection Schema åŸºç¡€

### 2.1 å®šä¹‰ Memory Schema

é¦–å…ˆå®šä¹‰å•ä¸ªè®°å¿†çš„ç»“æ„ï¼š

```python
from pydantic import BaseModel, Field

class Memory(BaseModel):
    content: str = Field(
        description="The main content of the memory. For example: User expressed interest in learning about French."
    )
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š

1. **æç®€è®¾è®¡**ï¼š
   - åªæœ‰ä¸€ä¸ªå­—æ®µï¼š`content`
   - æ²¡æœ‰é¢„å®šä¹‰çš„ç±»åˆ«æˆ–æ ‡ç­¾
   - æœ€å¤§åŒ–çµæ´»æ€§

2. **æè¿°æ€§æŒ‡å¼•**ï¼š
   - `description` å­—æ®µå‘Šè¯‰ LLM å¦‚ä½•ä½¿ç”¨
   - æä¾›ç¤ºä¾‹å¸®åŠ©ç†è§£

3. **å¼€æ”¾å¼å†…å®¹**ï¼š
   - å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„ä¿¡æ¯
   - æ²¡æœ‰ç»“æ„é™åˆ¶

### 2.2 å®šä¹‰ MemoryCollection Schema

å®šä¹‰è®°å¿†é›†åˆï¼ˆç”¨äºæ‰¹é‡æå–ï¼‰ï¼š

```python
class MemoryCollection(BaseModel):
    memories: list[Memory] = Field(
        description="A list of memories about the user."
    )
```

**ç”¨é€”**ï¼š
- ç”¨äº `with_structured_output()` ä¸€æ¬¡æ€§æå–å¤šæ¡è®°å¿†
- æ¨¡å‹ä¼šè¿”å›ä¸€ä¸ªåŒ…å«å¤šä¸ª Memory çš„åˆ—è¡¨

**Python çŸ¥è¯†ç‚¹**ï¼š

**ç±»å‹æ³¨è§£ `list[Memory]`**ï¼š
```python
# Python 3.9+
memories: list[Memory]

# Python 3.8 åŠæ›´æ—©ç‰ˆæœ¬
from typing import List
memories: List[Memory]
```

### 2.3 ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

**ç®€å•ä½†å¼ºå¤§çš„ç†ç”±**ï¼š

1. **çµæ´»æ€§æœ€å¤§åŒ–**ï¼š
   ```python
   # å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„ä¿¡æ¯
   Memory(content="User's name is Lance.")
   Memory(content="Lance likes biking.")
   Memory(content="Lance visited Paris in 2023.")
   Memory(content="Lance prefers dark mode in apps.")
   ```

2. **æ˜“äºæ‰©å±•**ï¼š
   ```python
   # å¦‚æœå°†æ¥éœ€è¦æ›´å¤šå­—æ®µï¼Œå¯ä»¥æ‰©å±•
   class Memory(BaseModel):
       content: str
       category: Optional[str] = None      # å¯é€‰çš„ç±»åˆ«
       importance: Optional[int] = None    # å¯é€‰çš„é‡è¦æ€§è¯„åˆ†
       timestamp: datetime = Field(default_factory=datetime.now)
   ```

3. **ä¸ Profile äº’è¡¥**ï¼š
   ```python
   # Profile: ç»“æ„åŒ–çš„å›ºå®šä¿¡æ¯
   profile = {
       "user_name": "Lance",
       "user_location": "San Francisco"
   }

   # Collection: çµæ´»çš„å¼€æ”¾å¼ä¿¡æ¯
   memories = [
       {"content": "Lance likes biking."},
       {"content": "Lance visited Tartine bakery."},
       {"content": "Lance is planning a trip to Japan."}
   ]
   ```

---

## ä¸‰ã€ä½¿ç”¨ with_structured_output æå– Collection

### 3.1 åŸºç¡€æå–

```python
from langchain_core.messages import HumanMessage
from langchain_openai import ChatOpenAI

# åˆå§‹åŒ–æ¨¡å‹
model = ChatOpenAI(model="gpt-5-nano", temperature=0)

# ç»‘å®š Schema åˆ°æ¨¡å‹
model_with_structure = model.with_structured_output(MemoryCollection)

# è°ƒç”¨æ¨¡å‹æå–è®°å¿†
memory_collection = model_with_structure.invoke([
    HumanMessage("My name is Lance. I like to bike.")
])

# æŸ¥çœ‹ç»“æœ
print(memory_collection.memories)
```

**è¾“å‡º**ï¼š
```python
[
    Memory(content="User's name is Lance."),
    Memory(content='Lance likes to bike.')
]
```

**åˆ†æ**ï¼š
- æ¨¡å‹è‡ªåŠ¨å°†ä¸€å¥è¯æ‹†åˆ†æˆä¸¤æ¡ç‹¬ç«‹çš„è®°å¿†
- æ¯æ¡è®°å¿†éƒ½æ˜¯ä¸€ä¸ª `Memory` å¯¹è±¡
- ç¬¦åˆ `MemoryCollection` çš„ç»“æ„

### 3.2 åºåˆ—åŒ–ä¸ºå­—å…¸

```python
# å•ä¸ªè®°å¿†
memory = memory_collection.memories[0]
print(memory.model_dump())
# è¾“å‡ºï¼š{'content': "User's name is Lance."}

# æ‰€æœ‰è®°å¿†
for mem in memory_collection.memories:
    print(mem.model_dump())
```

**`model_dump()` çš„ä½œç”¨**ï¼š
- å°† Pydantic æ¨¡å‹è½¬æ¢ä¸º Python å­—å…¸
- ä¾¿äºå­˜å‚¨åˆ° Store æˆ–æ•°æ®åº“
- å¯ä»¥åºåˆ—åŒ–ä¸º JSON

### 3.3 ä¿å­˜åˆ° Store

Collection çš„æ¯ä¸ªè®°å¿†é¡¹éƒ½**ç‹¬ç«‹ä¿å­˜**ï¼Œä½¿ç”¨å”¯ä¸€çš„ UUID ä½œä¸ºé”®ï¼š

```python
import uuid
from langgraph.store.memory import InMemoryStore

# åˆå§‹åŒ– Store
in_memory_store = InMemoryStore()

# å®šä¹‰å‘½åç©ºé—´
user_id = "1"
namespace_for_memory = (user_id, "memories")

# ä¿å­˜ç¬¬ä¸€æ¡è®°å¿†
key = str(uuid.uuid4())  # ç”Ÿæˆå”¯ä¸€ ID
value = memory_collection.memories[0].model_dump()
in_memory_store.put(namespace_for_memory, key, value)

# ä¿å­˜ç¬¬äºŒæ¡è®°å¿†
key = str(uuid.uuid4())  # å¦ä¸€ä¸ªå”¯ä¸€ ID
value = memory_collection.memories[1].model_dump()
in_memory_store.put(namespace_for_memory, key, value)
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ UUIDï¼Ÿ**

| ä½¿ç”¨å›ºå®šé”® | ä½¿ç”¨ UUID |
|----------|----------|
| åªèƒ½æœ‰ä¸€æ¡è®°å¿† | å¯ä»¥æœ‰æ— é™æ¡è®°å¿† |
| æ–°è®°å¿†ä¼šè¦†ç›–æ—§è®°å¿† | æ¯æ¡è®°å¿†ç‹¬ç«‹å­˜å‚¨ |
| é€‚åˆ Profile | é€‚åˆ Collection |

**å­˜å‚¨ç»“æ„ç¤ºæ„**ï¼š
```
Store
â””â”€â”€ ("1", "memories")  â† namespace
    â”œâ”€â”€ "e1c4e5ab-..." â†’ {"content": "User's name is Lance."}
    â””â”€â”€ "e132a1ea-..." â†’ {"content": "Lance likes to bike."}
```

### 3.4 æœç´¢è®°å¿†

```python
# æœç´¢å‘½åç©ºé—´ä¸­çš„æ‰€æœ‰è®°å¿†
for m in in_memory_store.search(namespace_for_memory):
    print(m.dict())
```

**è¾“å‡º**ï¼š
```python
{
    'value': {'content': "User's name is Lance."},
    'key': 'e1c4e5ab-ab0f-4cbb-822d-f29240a983af',
    'namespace': ['1', 'memories'],
    'created_at': '2024-10-30T21:43:26.893775+00:00',
    'updated_at': '2024-10-30T21:43:26.893779+00:00'
}
{
    'value': {'content': 'Lance likes to bike.'},
    'key': 'e132a1ea-6202-43ac-a9a6-3ecf2c1780a8',
    'namespace': ['1', 'memories'],
    'created_at': '2024-10-30T21:43:26.893833+00:00',
    'updated_at': '2024-10-30T21:43:26.893834+00:00'
}
```

---

## å››ã€Trustcall çš„ enable_inserts å‚æ•°

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦ enable_insertsï¼Ÿ

åœ¨ 5.3 èŠ‚ä¸­ï¼ŒTrustcall é»˜è®¤åª**æ›´æ–°å•ä¸€å¯¹è±¡**ï¼š

```python
# 5.3 çš„ç”¨æ³•ï¼ˆProfileï¼‰
extractor = create_extractor(
    model,
    tools=[UserProfile],
    tool_choice="UserProfile"
    # æ²¡æœ‰ enable_inserts
)
```

å¯¹äº Collectionï¼Œæˆ‘ä»¬éœ€è¦**æ·»åŠ æ–°é¡¹**å’Œ**æ›´æ–°ç°æœ‰é¡¹**ï¼š

```python
# 5.4 çš„ç”¨æ³•ï¼ˆCollectionï¼‰
extractor = create_extractor(
    model,
    tools=[Memory],
    tool_choice="Memory",
    enable_inserts=True  # å…³é”®ï¼
)
```

### 4.2 enable_inserts çš„ä½œç”¨

**`enable_inserts=True` å‘Šè¯‰ Trustcall**ï¼š

1. âœ… å¯ä»¥åˆ›å»ºæ–°çš„è®°å¿†é¡¹
2. âœ… å¯ä»¥æ›´æ–°ç°æœ‰çš„è®°å¿†é¡¹
3. âœ… å¯ä»¥åŒæ—¶è¿›è¡Œåˆ›å»ºå’Œæ›´æ–°ï¼ˆå¹¶è¡Œæ“ä½œï¼‰

**æ²¡æœ‰ enable_inserts**ï¼š
- åªèƒ½æ›´æ–°ç°æœ‰é¡¹
- ä¸èƒ½æ·»åŠ æ–°é¡¹
- é€‚åˆ Profile åœºæ™¯

**æœ‰ enable_inserts**ï¼š
- å¯ä»¥æ·»åŠ æ–°é¡¹
- ä¹Ÿå¯ä»¥æ›´æ–°ç°æœ‰é¡¹
- é€‚åˆ Collection åœºæ™¯

### 4.3 åˆ›å»º Trustcall Extractor

```python
from trustcall import create_extractor

# å®šä¹‰ Memory Schema
class Memory(BaseModel):
    content: str = Field(
        description="The main content of the memory. For example: User expressed interest in learning about French."
    )

# åˆ›å»ºæå–å™¨
trustcall_extractor = create_extractor(
    model,
    tools=[Memory],
    tool_choice="Memory",
    enable_inserts=True,  # å¯ç”¨æ’å…¥åŠŸèƒ½
)
```

---

## äº”ã€Trustcall å¤„ç† Collection

### 5.1 åŸºç¡€æå–ï¼ˆåˆ›å»ºæ–°è®°å¿†ï¼‰

```python
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

# æå–æŒ‡ä»¤
instruction = """Extract memories from the following conversation:"""

# å¯¹è¯
conversation = [
    HumanMessage(content="Hi, I'm Lance."),
    AIMessage(content="Nice to meet you, Lance."),
    HumanMessage(content="This morning I had a nice bike ride in San Francisco.")
]

# è°ƒç”¨æå–å™¨
result = trustcall_extractor.invoke({
    "messages": [SystemMessage(content=instruction)] + conversation
})
```

**æŸ¥çœ‹æ¶ˆæ¯ï¼ˆå·¥å…·è°ƒç”¨ï¼‰**ï¼š
```python
for m in result["messages"]:
    m.pretty_print()
```

**è¾“å‡º**ï¼š
```
================================== Ai Message ==================================
Tool Calls:
  Memory (call_Pj4kctFlpg9TgcMBfMH33N30)
 Call ID: call_Pj4kctFlpg9TgcMBfMH33N30
  Args:
    content: Lance had a nice bike ride in San Francisco this morning.
```

**æŸ¥çœ‹å“åº”ï¼ˆè§£æåçš„å¯¹è±¡ï¼‰**ï¼š
```python
for m in result["responses"]:
    print(m)
```

**è¾“å‡º**ï¼š
```
content='Lance had a nice bike ride in San Francisco this morning.'
```

**æŸ¥çœ‹å…ƒæ•°æ®**ï¼š
```python
for m in result["response_metadata"]:
    print(m)
```

**è¾“å‡º**ï¼š
```python
{'id': 'call_Pj4kctFlpg9TgcMBfMH33N30'}
```

### 5.2 æ›´æ–°å’Œæ’å…¥ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰

ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹ Trustcall å¦‚ä½•åŒæ—¶å¤„ç†**æ›´æ–°ç°æœ‰è®°å¿†**å’Œ**æ’å…¥æ–°è®°å¿†**ã€‚

#### 5.2.1 å‡†å¤‡ç°æœ‰è®°å¿†

```python
# æ›´æ–°åçš„å¯¹è¯
updated_conversation = [
    AIMessage(content="That's great, did you do after?"),
    HumanMessage(content="I went to Tartine and ate a croissant."),
    AIMessage(content="What else is on your mind?"),
    HumanMessage(content="I was thinking about my Japan, and going back this winter!"),
]

# æ›´æ–°æŒ‡ä»¤
system_msg = """Update existing memories and create new ones based on the following conversation:"""

# å‡†å¤‡ç°æœ‰è®°å¿†
tool_name = "Memory"
existing_memories = [
    (str(i), tool_name, memory.model_dump())
    for i, memory in enumerate(result["responses"])
] if result["responses"] else None

print(existing_memories)
```

**è¾“å‡º**ï¼š
```python
[
    (
        '0',                           # ID
        'Memory',                      # å·¥å…·å
        {'content': 'Lance had a nice bike ride in San Francisco this morning.'}  # æ•°æ®
    )
]
```

**æ•°æ®æ ¼å¼è¯´æ˜**ï¼š

Trustcall æœŸæœ›ç°æœ‰æ•°æ®çš„æ ¼å¼ï¼š
```python
[
    (id, tool_name, data),
    (id, tool_name, data),
    ...
]
```

- **id**ï¼šå­—ç¬¦ä¸²ï¼Œæ ‡è¯†è®°å¿†é¡¹ï¼ˆç”¨äºæ›´æ–°ï¼‰
- **tool_name**ï¼šå·¥å…·åç§°ï¼ˆ"Memory"ï¼‰
- **data**ï¼šå­—å…¸æ ¼å¼çš„æ•°æ®

**Python çŸ¥è¯†ç‚¹**ï¼š

**åˆ—è¡¨æ¨å¯¼å¼çš„å®Œæ•´å½¢å¼**ï¼š
```python
existing_memories = [
    (str(i), tool_name, memory.model_dump())
    for i, memory in enumerate(result["responses"])
] if result["responses"] else None

# å±•å¼€ç­‰ä»·äºï¼š
if result["responses"]:
    existing_memories = []
    for i, memory in enumerate(result["responses"]):
        existing_memories.append((str(i), tool_name, memory.model_dump()))
else:
    existing_memories = None
```

#### 5.2.2 è°ƒç”¨ Trustcall è¿›è¡Œæ›´æ–°å’Œæ’å…¥

```python
# è°ƒç”¨æå–å™¨
result = trustcall_extractor.invoke({
    "messages": updated_conversation,
    "existing": existing_memories
})
```

**æŸ¥çœ‹å·¥å…·è°ƒç”¨**ï¼š
```python
for m in result["messages"]:
    m.pretty_print()
```

**è¾“å‡º**ï¼š
```
================================== Ai Message ==================================
Tool Calls:
  Memory (call_vxks0YH1hwUxkghv4f5zdkTr)
 Call ID: call_vxks0YH1hwUxkghv4f5zdkTr
  Args:
    content: Lance had a nice bike ride in San Francisco this morning. He went to Tartine and ate a croissant. He was thinking about his trip to Japan and going back this winter!
  Memory (call_Y4S3poQgFmDfPy2ExPaMRk8g)
 Call ID: call_Y4S3poQgFmDfPy2ExPaMRk8g
  Args:
    content: Lance went to Tartine and ate a croissant. He was thinking about his trip to Japan and going back this winter!
```

**å…³é”®è§‚å¯Ÿ**ï¼š
- æœ‰ä¸¤ä¸ª Memory å·¥å…·è°ƒç”¨
- ç¬¬ä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰ä¿¡æ¯ï¼ˆæ›´æ–°ï¼‰
- ç¬¬äºŒä¸ªåªåŒ…å«æ–°ä¿¡æ¯ï¼ˆæ’å…¥ï¼‰

**æŸ¥çœ‹å“åº”**ï¼š
```python
for m in result["responses"]:
    print(m)
```

**è¾“å‡º**ï¼š
```
content='Lance had a nice bike ride in San Francisco this morning. He went to Tartine and ate a croissant. He was thinking about his trip to Japan and going back this winter!'
content='Lance went to Tartine and ate a croissant. He was thinking about his trip to Japan and going back this winter!'
```

**æŸ¥çœ‹å…ƒæ•°æ®ï¼ˆå…³é”®ï¼‰**ï¼š
```python
for m in result["response_metadata"]:
    print(m)
```

**è¾“å‡º**ï¼š
```python
{'id': 'call_vxks0YH1hwUxkghv4f5zdkTr', 'json_doc_id': '0'}
{'id': 'call_Y4S3poQgFmDfPy2ExPaMRk8g'}
```

**é‡ç‚¹åˆ†æ**ï¼š

| å“åº” | å…ƒæ•°æ® | å«ä¹‰ |
|------|--------|------|
| ç¬¬ä¸€ä¸ª | `'json_doc_id': '0'` | **æ›´æ–°**ç°æœ‰è®°å¿†ï¼ˆID ä¸º '0'ï¼‰ |
| ç¬¬äºŒä¸ª | æ²¡æœ‰ `json_doc_id` | **æ’å…¥**æ–°è®°å¿† |

### 5.3 Trustcall çš„æ™ºèƒ½å†³ç­–

Trustcall è‡ªåŠ¨å†³å®šå“ªäº›è®°å¿†åº”è¯¥æ›´æ–°ï¼Œå“ªäº›åº”è¯¥æ’å…¥ï¼š

```
åŸå§‹è®°å¿†ï¼š
- Lance had a nice bike ride in San Francisco this morning.

æ–°å¯¹è¯ï¼š
- I went to Tartine and ate a croissant.
- I was thinking about Japan, and going back this winter!

Trustcall çš„å†³ç­–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ›´æ–°è®°å¿† 0ï¼š                                     â”‚
â”‚ "Lance had a nice bike ride... He went to       â”‚
â”‚  Tartine... He was thinking about his trip..."   â”‚
â”‚ ï¼ˆæ•´åˆæ–°æ—§ä¿¡æ¯ï¼‰                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ’å…¥æ–°è®°å¿†ï¼š                                     â”‚
â”‚ "Lance went to Tartine... He was thinking       â”‚
â”‚  about his trip to Japan..."                     â”‚
â”‚ ï¼ˆç‹¬ç«‹çš„æ–°è®°å¿†ï¼‰                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

1. **ä¿¡æ¯æ•´åˆ**ï¼šç›¸å…³çš„ä¿¡æ¯æ›´æ–°åˆ°åŒä¸€æ¡è®°å¿†ä¸­
2. **ç‹¬ç«‹æ€§**ï¼šä¸ç›¸å…³æˆ–ç‹¬ç«‹çš„äº‹ä»¶åˆ›å»ºæ–°è®°å¿†
3. **é¿å…å†—ä½™**ï¼šä¸ä¼šåˆ›å»ºå®Œå…¨é‡å¤çš„è®°å¿†
4. **ä¿æŒçµæ´»æ€§**ï¼šæ ¹æ®å†…å®¹è‡ªåŠ¨å†³ç­–

---

## å…­ã€æ„å»ºå¸¦æœ‰ Collection Schema çš„èŠå¤©æœºå™¨äºº

### 6.1 å®Œæ•´çš„å®ç°

```python
from IPython.display import Image, display
import uuid
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.store.memory import InMemoryStore
from langchain_core.messages import merge_message_runs, HumanMessage, SystemMessage
from langchain_core.runnables.config import RunnableConfig
from langgraph.checkpoint.memory import MemorySaver
from langgraph.store.base import BaseStore
from langchain_openai import ChatOpenAI
from trustcall import create_extractor
from pydantic import BaseModel, Field

# åˆå§‹åŒ–æ¨¡å‹
model = ChatOpenAI(model="gpt-5-nano", temperature=0)

# Memory Schema
class Memory(BaseModel):
    content: str = Field(
        description="The main content of the memory. For example: User expressed interest in learning about French."
    )

# åˆ›å»º Trustcall æå–å™¨
trustcall_extractor = create_extractor(
    model,
    tools=[Memory],
    tool_choice="Memory",
    enable_inserts=True,  # å…è®¸æ’å…¥æ–°è®°å¿†
)

# ç³»ç»Ÿæç¤ºè¯
MODEL_SYSTEM_MESSAGE = """You are a helpful chatbot. You are designed to be a companion to a user.

You have a long term memory which keeps track of information you learn about the user over time.

Current Memory (may include updated memories from this conversation):

{memory}"""

TRUSTCALL_INSTRUCTION = """Reflect on following interaction.

Use the provided tools to retain any necessary memories about the user.

Use parallel tool calling to handle updates and insertions simultaneously:"""
```

### 6.2 call_model èŠ‚ç‚¹

```python
def call_model(state: MessagesState, config: RunnableConfig, store: BaseStore):
    """ä» store åŠ è½½è®°å¿†å¹¶ç”¨å®ƒä»¬æ¥ä¸ªæ€§åŒ–èŠå¤©æœºå™¨äººçš„å“åº”"""

    # è·å–ç”¨æˆ· ID
    user_id = config["configurable"]["user_id"]

    # ä» store æ£€ç´¢è®°å¿†
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    # æ ¼å¼åŒ–è®°å¿†ä¸ºç³»ç»Ÿæç¤º
    info = "\n".join(f"- {mem.value['content']}" for mem in memories)
    system_msg = MODEL_SYSTEM_MESSAGE.format(memory=info)

    # ä½¿ç”¨è®°å¿†å’ŒèŠå¤©å†å²ç”Ÿæˆå“åº”
    response = model.invoke([
        SystemMessage(content=system_msg)
    ] + state["messages"])

    return {"messages": response}
```

**ä»£ç åˆ†æ**ï¼š

**ç¬¬ 7-8 è¡Œ**ï¼šæ£€ç´¢æ‰€æœ‰è®°å¿†
```python
namespace = ("memories", user_id)
memories = store.search(namespace)
```
- ä½¿ç”¨ `search()` è€Œä¸æ˜¯ `get()`
- å› ä¸º Collection æœ‰å¤šä¸ªè®°å¿†é¡¹
- è¿”å›è¯¥å‘½åç©ºé—´ä¸‹çš„æ‰€æœ‰è®°å¿†

**ç¬¬ 10-11 è¡Œ**ï¼šæ ¼å¼åŒ–è®°å¿†
```python
info = "\n".join(f"- {mem.value['content']}" for mem in memories)
system_msg = MODEL_SYSTEM_MESSAGE.format(memory=info)
```

**æ ¼å¼åŒ–ç¤ºä¾‹**ï¼š
```python
# memories = [
#     Item(value={'content': "User's name is Lance."}),
#     Item(value={'content': 'Lance likes to bike around San Francisco.'})
# ]

info = """
- User's name is Lance.
- Lance likes to bike around San Francisco.
"""
```

**ç”Ÿæˆå™¨è¡¨è¾¾å¼è¯¦è§£**ï¼š
```python
"\n".join(f"- {mem.value['content']}" for mem in memories)

# ç­‰ä»·äºï¼š
result = []
for mem in memories:
    result.append(f"- {mem.value['content']}")
info = "\n".join(result)
```

### 6.3 write_memory èŠ‚ç‚¹

```python
def write_memory(state: MessagesState, config: RunnableConfig, store: BaseStore):
    """åæ€èŠå¤©å†å²å¹¶æ›´æ–°è®°å¿†é›†åˆ"""

    # è·å–ç”¨æˆ· ID
    user_id = config["configurable"]["user_id"]

    # å®šä¹‰å‘½åç©ºé—´
    namespace = ("memories", user_id)

    # æ£€ç´¢æœ€è¿‘çš„è®°å¿†ä½œä¸ºä¸Šä¸‹æ–‡
    existing_items = store.search(namespace)

    # ä¸º Trustcall æå–å™¨æ ¼å¼åŒ–ç°æœ‰è®°å¿†
    tool_name = "Memory"
    existing_memories = (
        [(existing_item.key, tool_name, existing_item.value)
         for existing_item in existing_items]
        if existing_items
        else None
    )

    # åˆå¹¶èŠå¤©å†å²å’ŒæŒ‡ä»¤
    updated_messages = list(merge_message_runs(
        messages=[SystemMessage(content=TRUSTCALL_INSTRUCTION)] + state["messages"]
    ))

    # è°ƒç”¨æå–å™¨
    result = trustcall_extractor.invoke({
        "messages": updated_messages,
        "existing": existing_memories
    })

    # ä¿å­˜ Trustcall çš„è®°å¿†åˆ° store
    for r, rmeta in zip(result["responses"], result["response_metadata"]):
        store.put(
            namespace,
            rmeta.get("json_doc_id", str(uuid.uuid4())),  # å…³é”®ï¼
            r.model_dump(mode="json"),
        )
```

**ä»£ç é€è¡Œè§£æ**ï¼š

**ç¬¬ 11 è¡Œ**ï¼šæ£€ç´¢ç°æœ‰è®°å¿†
```python
existing_items = store.search(namespace)
```
- è·å–æ‰€æœ‰ç°æœ‰è®°å¿†é¡¹
- ç”¨äº Trustcall çš„ä¸Šä¸‹æ–‡

**ç¬¬ 14-20 è¡Œ**ï¼šæ ¼å¼åŒ–ä¸º Trustcall æ ¼å¼
```python
tool_name = "Memory"
existing_memories = (
    [(existing_item.key, tool_name, existing_item.value)
     for existing_item in existing_items]
    if existing_items
    else None
)
```

**æ ¼å¼åŒ–ç»“æœç¤ºä¾‹**ï¼š
```python
[
    ('dee65880-...', 'Memory', {'content': "User's name is Lance."}),
    ('662195fc-...', 'Memory', {'content': 'Lance likes to bike...'})
]
```

**ç¬¬ 22-25 è¡Œ**ï¼šåˆå¹¶æ¶ˆæ¯
```python
updated_messages = list(merge_message_runs(
    messages=[SystemMessage(content=TRUSTCALL_INSTRUCTION)] + state["messages"]
))
```

**`merge_message_runs()` çš„ä½œç”¨**ï¼š
```python
# åˆå¹¶å‰ï¼š
[
    HumanMessage("Hi"),
    HumanMessage("How are you?"),
    AIMessage("I'm good"),
    AIMessage("Thanks for asking")
]

# åˆå¹¶åï¼š
[
    HumanMessage("Hi\nHow are you?"),
    AIMessage("I'm good\nThanks for asking")
]
```
- åˆå¹¶è¿ç»­çš„ç›¸åŒè§’è‰²æ¶ˆæ¯
- å‡å°‘æ¶ˆæ¯æ•°é‡
- æé«˜æ•ˆç‡

**ç¬¬ 28-32 è¡Œ**ï¼šè°ƒç”¨ Trustcall
```python
result = trustcall_extractor.invoke({
    "messages": updated_messages,
    "existing": existing_memories
})
```

**ç¬¬ 34-39 è¡Œ**ï¼šä¿å­˜ç»“æœï¼ˆå…³é”®é€»è¾‘ï¼‰
```python
for r, rmeta in zip(result["responses"], result["response_metadata"]):
    store.put(
        namespace,
        rmeta.get("json_doc_id", str(uuid.uuid4())),
        r.model_dump(mode="json"),
    )
```

**æ ¸å¿ƒé€»è¾‘è§£æ**ï¼š

```python
rmeta.get("json_doc_id", str(uuid.uuid4()))
```

**è¿™è¡Œä»£ç å†³å®šäº†æ˜¯æ›´æ–°è¿˜æ˜¯æ’å…¥**ï¼š

| æƒ…å†µ | `rmeta` å†…å®¹ | ä½¿ç”¨çš„é”® | æ“ä½œ |
|------|-------------|---------|------|
| æ›´æ–°ç°æœ‰è®°å¿† | `{'id': '...', 'json_doc_id': '0'}` | ç°æœ‰çš„é”®ï¼ˆä» `existing_memories`ï¼‰ | **æ›´æ–°** |
| æ’å…¥æ–°è®°å¿† | `{'id': '...'}` | æ–°çš„ UUID | **æ’å…¥** |

**ç¤ºä¾‹**ï¼š
```python
# æƒ…å†µ 1ï¼šæ›´æ–°
rmeta = {'id': 'call_xxx', 'json_doc_id': 'dee65880-...'}
key = rmeta.get("json_doc_id", str(uuid.uuid4()))
# key = 'dee65880-...'ï¼ˆç°æœ‰é”®ï¼‰
# â†’ æ›´æ–°ç°æœ‰è®°å¿†

# æƒ…å†µ 2ï¼šæ’å…¥
rmeta = {'id': 'call_yyy'}
key = rmeta.get("json_doc_id", str(uuid.uuid4()))
# key = 'æ–°çš„UUID'ï¼ˆä¾‹å¦‚ 'f1234567-...'ï¼‰
# â†’ æ’å…¥æ–°è®°å¿†
```

**Python çŸ¥è¯†ç‚¹**ï¼š

**`zip()` å‡½æ•°**ï¼š
```python
responses = [mem1, mem2]
metadata = [meta1, meta2]

for r, rmeta in zip(responses, metadata):
    # ç¬¬ä¸€æ¬¡è¿­ä»£ï¼šr=mem1, rmeta=meta1
    # ç¬¬äºŒæ¬¡è¿­ä»£ï¼šr=mem2, rmeta=meta2
    process(r, rmeta)
```

**`.get()` æ–¹æ³•çš„é»˜è®¤å€¼**ï¼š
```python
d = {'a': 1}
d.get('a', 0)  # è¿”å› 1ï¼ˆé”®å­˜åœ¨ï¼‰
d.get('b', 0)  # è¿”å› 0ï¼ˆé”®ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼‰
```

### 6.4 æ„å»ºå›¾

```python
# å®šä¹‰å›¾
builder = StateGraph(MessagesState)
builder.add_node("call_model", call_model)
builder.add_node("write_memory", write_memory)
builder.add_edge(START, "call_model")
builder.add_edge("call_model", "write_memory")
builder.add_edge("write_memory", END)

# é•¿æœŸè®°å¿†ï¼ˆè·¨çº¿ç¨‹ï¼‰
across_thread_memory = InMemoryStore()

# çŸ­æœŸè®°å¿†ï¼ˆçº¿ç¨‹å†…ï¼‰
within_thread_memory = MemorySaver()

# ç¼–è¯‘å›¾
graph = builder.compile(
    checkpointer=within_thread_memory,
    store=across_thread_memory
)
```

**å›¾ç»“æ„**ï¼š
```
START â†’ call_model â†’ write_memory â†’ END
```

---

## ä¸ƒã€å®æˆ˜æ¼”ç¤º

### 7.1 ç¬¬ä¸€æ¬¡äº¤äº’ï¼šåˆ›å»ºç¬¬ä¸€æ¡è®°å¿†

```python
# é…ç½®
config = {
    "configurable": {
        "thread_id": "1",
        "user_id": "1"
    }
}

# ç”¨æˆ·è¾“å…¥
input_messages = [HumanMessage(content="Hi, my name is Lance")]

# è¿è¡Œå›¾
for chunk in graph.stream({"messages": input_messages}, config, stream_mode="values"):
    chunk["messages"][-1].pretty_print()
```

**è¾“å‡º**ï¼š
```
================================ Human Message =================================
Hi, my name is Lance

================================== Ai Message ==================================
Hi Lance! It's great to meet you. How can I assist you today?
```

### 7.2 ç¬¬äºŒæ¬¡äº¤äº’ï¼šæ·»åŠ æ–°è®°å¿†

```python
# ç”¨æˆ·è¾“å…¥
input_messages = [HumanMessage(content="I like to bike around San Francisco")]

# è¿è¡Œå›¾
for chunk in graph.stream({"messages": input_messages}, config, stream_mode="values"):
    chunk["messages"][-1].pretty_print()
```

**è¾“å‡º**ï¼š
```
================================ Human Message =================================
I like to bike around San Francisco

================================== Ai Message ==================================
That sounds like a lot of fun! San Francisco has some beautiful routes for biking.
Do you have a favorite trail or area you like to explore?
```

### 7.3 æŸ¥çœ‹è®°å¿†é›†åˆ

```python
# å®šä¹‰å‘½åç©ºé—´
user_id = "1"
namespace = ("memories", user_id)

# æœç´¢æ‰€æœ‰è®°å¿†
memories = across_thread_memory.search(namespace)

# æ‰“å°æ¯æ¡è®°å¿†
for m in memories:
    print(m.dict())
```

**è¾“å‡º**ï¼š
```python
{
    'value': {'content': "User's name is Lance."},
    'key': 'dee65880-dd7d-4184-8ca1-1f7400f7596b',
    'namespace': ['memories', '1'],
    'created_at': '2024-10-30T22:18:52.413283+00:00',
    'updated_at': '2024-10-30T22:18:52.413284+00:00'
}
{
    'value': {'content': 'User likes to bike around San Francisco.'},
    'key': '662195fc-8ea4-4f64-a6b6-6b86d9cb85c0',
    'namespace': ['memories', '1'],
    'created_at': '2024-10-30T22:18:56.597813+00:00',
    'updated_at': '2024-10-30T22:18:56.597814+00:00'
}
```

**åˆ†æ**ï¼š
- æœ‰ä¸¤æ¡ç‹¬ç«‹çš„è®°å¿†
- æ¯æ¡è®°å¿†æœ‰å”¯ä¸€çš„ UUID é”®
- åˆ†åˆ«è®°å½•äº†åå­—å’Œçˆ±å¥½

### 7.4 ç»§ç»­æ·»åŠ è®°å¿†

```python
# ç”¨æˆ·è¾“å…¥
input_messages = [HumanMessage(content="I also enjoy going to bakeries")]

# è¿è¡Œå›¾
for chunk in graph.stream({"messages": input_messages}, config, stream_mode="values"):
    chunk["messages"][-1].pretty_print()
```

**è¾“å‡º**ï¼š
```
================================ Human Message =================================
I also enjoy going to bakeries

================================== Ai Message ==================================
Biking and bakeries make a great combination! Do you have a favorite bakery in
San Francisco, or are you on the hunt for new ones to try?
```

**ç°åœ¨åº”è¯¥æœ‰ä¸‰æ¡è®°å¿†**ï¼š
1. User's name is Lance.
2. Lance likes to bike around San Francisco.
3. Lance enjoys going to bakeries.

### 7.5 è·¨ä¼šè¯æµ‹è¯•

```python
# æ–°çš„çº¿ç¨‹ï¼Œç›¸åŒçš„ç”¨æˆ·
config = {
    "configurable": {
        "thread_id": "2",  # æ–°ä¼šè¯
        "user_id": "1"     # ç›¸åŒç”¨æˆ·
    }
}

# ç”¨æˆ·è¾“å…¥
input_messages = [HumanMessage(content="What bakeries do you recommend for me?")]

# è¿è¡Œå›¾
for chunk in graph.stream({"messages": input_messages}, config, stream_mode="values"):
    chunk["messages"][-1].pretty_print()
```

**è¾“å‡º**ï¼š
```
================================ Human Message =================================
What bakeries do you recommend for me?

================================== Ai Message ==================================
Since you enjoy biking around San Francisco, you might like to check out some of
these bakeries that are both delicious and located in areas that are great for a
bike ride:

1. **Tartine Bakery** - Located in the Mission District, it's famous for its
   bread and pastries. The area is vibrant and perfect for a leisurely ride.

2. **Arsicault Bakery** - Known for its incredible croissants, it's in the
   Richmond District, which offers a nice ride through Golden Gate Park.

3. **B. Patisserie** - Situated in Lower Pacific Heights, this bakery is renowned
   for its kouign-amann and other French pastries. The neighborhood is charming
   and bike-friendly.

4. **Mr. Holmes Bakehouse** - Famous for its cruffins, it's located in the
   Tenderloin, which is a bit more urban but still accessible by bike.

5. **Noe Valley Bakery** - A cozy spot in Noe Valley, perfect for a stop after
   exploring the hilly streets of the area.

Do any of these sound like a good fit for your next biking adventure?
```

**Collection çš„å¨åŠ›**ï¼š
1. âœ… AI è®°å¾—æ‰€æœ‰è®°å¿†ï¼ˆåå­—ã€éª‘è½¦ã€é¢åŒ…åº—ï¼‰
2. âœ… ç»“åˆå¤šæ¡è®°å¿†ç”Ÿæˆä¸ªæ€§åŒ–å»ºè®®
3. âœ… "Since you enjoy biking"ï¼ˆæ¥è‡ªè®°å¿† 2ï¼‰
4. âœ… æ¨èé€‚åˆéª‘è½¦å»çš„é¢åŒ…åº—ï¼ˆç»“åˆè®°å¿† 2 å’Œ 3ï¼‰

---

## å…«ã€Profile vs Collection æ·±å…¥å¯¹æ¯”

### 8.1 æ•°æ®ç»“æ„å¯¹æ¯”

**Profileï¼ˆ5.3ï¼‰**ï¼š
```python
# å•ä¸€å¯¹è±¡
{
    "user_name": "Lance",
    "user_location": "San Francisco",
    "interests": ["biking", "bakeries"]
}

# å­˜å‚¨æ–¹å¼
namespace = ("memory", user_id)
key = "user_memory"  # å›ºå®šé”®
store.put(namespace, key, profile_data)
```

**Collectionï¼ˆ5.4ï¼‰**ï¼š
```python
# å¤šä¸ªç‹¬ç«‹å¯¹è±¡
[
    {"content": "User's name is Lance."},
    {"content": "Lance likes biking."},
    {"content": "Lance enjoys bakeries."}
]

# å­˜å‚¨æ–¹å¼
namespace = ("memories", user_id)
for memory in memories:
    key = str(uuid.uuid4())  # æ¯ä¸ªè®°å¿†æœ‰å”¯ä¸€é”®
    store.put(namespace, key, memory)
```

### 8.2 æ›´æ–°æ“ä½œå¯¹æ¯”

**Profile æ›´æ–°**ï¼š
```python
# æ•´ä¸ªå¯¹è±¡è¢«æ›¿æ¢æˆ–å­—æ®µè¢«æ›´æ–°
old_profile = {
    "user_name": "Lance",
    "interests": ["biking"]
}

new_profile = {
    "user_name": "Lance",
    "interests": ["biking", "bakeries"]  # å­—æ®µæ›´æ–°
}

# è¦†ç›–æ•´ä¸ª Profile
store.put(namespace, "user_memory", new_profile)
```

**Collection æ›´æ–°**ï¼š
```python
# å¯ä»¥æ›´æ–°ç‰¹å®šè®°å¿†ï¼Œä¹Ÿå¯ä»¥æ·»åŠ æ–°è®°å¿†
# æ›´æ–°è®°å¿† 1
store.put(namespace, "existing-uuid-1", {
    "content": "Updated content"
})

# æ·»åŠ æ–°è®°å¿†
store.put(namespace, str(uuid.uuid4()), {
    "content": "New memory content"
})

# ç°æœ‰è®°å¿†ä¿æŒä¸å˜
```

### 8.3 æ£€ç´¢æ–¹å¼å¯¹æ¯”

**Profile æ£€ç´¢**ï¼š
```python
# ä½¿ç”¨ get() è·å–å•ä¸€å¯¹è±¡
profile = store.get(namespace, "user_memory")
if profile:
    user_name = profile.value.get("user_name")
    interests = profile.value.get("interests")
```

**Collection æ£€ç´¢**ï¼š
```python
# ä½¿ç”¨ search() è·å–æ‰€æœ‰è®°å¿†
memories = store.search(namespace)

# éå†æ‰€æœ‰è®°å¿†
for memory in memories:
    content = memory.value['content']
    print(content)

# æˆ–è€…æ ¼å¼åŒ–
info = "\n".join(f"- {mem.value['content']}" for mem in memories)
```

### 8.4 Trustcall å‚æ•°å¯¹æ¯”

| å‚æ•° | Profile (5.3) | Collection (5.4) |
|------|--------------|-----------------|
| **tools** | `[UserProfile]` | `[Memory]` |
| **tool_choice** | `"UserProfile"` | `"Memory"` |
| **enable_inserts** | âŒ ä¸éœ€è¦ | âœ… **å¿…é¡»**ï¼ˆ`True`ï¼‰ |
| **existing æ ¼å¼** | `{"UserProfile": data}` | `[(id, "Memory", data), ...]` |

### 8.5 ä½¿ç”¨åœºæ™¯å¯¹æ¯”

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|---------|------|
| ç”¨æˆ·èµ„æ–™ | Profile | å›ºå®šå­—æ®µï¼Œç»“æ„åŒ– |
| å¾…åŠäº‹é¡¹ | Collection | å¤šä¸ªç‹¬ç«‹ä»»åŠ¡ |
| ç³»ç»Ÿè®¾ç½® | Profile | æ˜ç¡®çš„é…ç½®é¡¹ |
| å­¦ä¹ ç¬”è®° | Collection | å¼€æ”¾å¼å†…å®¹ |
| å¯¹è¯è®°å½• | Collection | æŒç»­å¢é•¿ |
| è®¤è¯ä¿¡æ¯ | Profile | å›ºå®šå‡­è¯ |

### 8.6 æ€§èƒ½å’Œæ•ˆç‡å¯¹æ¯”

| æ–¹é¢ | Profile | Collection |
|------|---------|-----------|
| **å­˜å‚¨æ•ˆç‡** | âœ… å•ä¸€å¯¹è±¡ | âš ï¸ å¤šä¸ªå¯¹è±¡ |
| **æ›´æ–°æ•ˆç‡** | âš ï¸ å¯èƒ½æ›´æ–°æ•´ä¸ªå¯¹è±¡ | âœ… åªæ›´æ–°å˜åŒ–çš„é¡¹ |
| **æŸ¥è¯¢æ•ˆç‡** | âœ… ç›´æ¥ get | âš ï¸ éœ€è¦ search éå† |
| **æ‰©å±•æ€§** | âŒ å—å­—æ®µé™åˆ¶ | âœ… æ— é™æ‰©å±• |
| **Token ä½¿ç”¨** | âš ï¸ æ¯æ¬¡ä¼ é€’å…¨éƒ¨ | âœ… å¯ä»¥é€‰æ‹©æ€§ä¼ é€’ |

---

## ä¹ã€é«˜çº§ä¸»é¢˜

### 9.1 é€‰æ‹©æ€§è®°å¿†åŠ è½½

å½“è®°å¿†é›†åˆå¾ˆå¤§æ—¶ï¼Œä¸éœ€è¦æ¯æ¬¡éƒ½åŠ è½½æ‰€æœ‰è®°å¿†ï¼š

```python
def call_model_with_filtering(state, config, store):
    user_id = config["configurable"]["user_id"]
    namespace = ("memories", user_id)

    # è·å–æ‰€æœ‰è®°å¿†
    all_memories = store.search(namespace)

    # é€‰æ‹©æœ€è¿‘çš„ N æ¡è®°å¿†
    recent_memories = sorted(
        all_memories,
        key=lambda m: m.updated_at,
        reverse=True
    )[:10]  # åªä½¿ç”¨æœ€è¿‘ 10 æ¡

    # æˆ–è€…æ ¹æ®ç›¸å…³æ€§ç­›é€‰
    # relevant_memories = filter_by_relevance(
    #     memories=all_memories,
    #     current_query=state["messages"][-1].content
    # )

    # æ ¼å¼åŒ–è®°å¿†
    info = "\n".join(f"- {mem.value['content']}" for mem in recent_memories)
    system_msg = MODEL_SYSTEM_MESSAGE.format(memory=info)

    response = model.invoke([SystemMessage(content=system_msg)] + state["messages"])
    return {"messages": response}
```

**ä¼˜åŒ–ç­–ç•¥**ï¼š

1. **æ—¶é—´æ’åº**ï¼šä½¿ç”¨æœ€æ–°çš„è®°å¿†
2. **ç›¸å…³æ€§ç­›é€‰**ï¼šåªä½¿ç”¨ä¸å½“å‰å¯¹è¯ç›¸å…³çš„è®°å¿†
3. **é‡è¦æ€§è¯„åˆ†**ï¼šä¸ºè®°å¿†æ·»åŠ é‡è¦æ€§å­—æ®µ
4. **åˆ†ç±»è¿‡æ»¤**ï¼šæ ¹æ®è®°å¿†ç±»åˆ«ç­›é€‰

### 9.2 è®°å¿†çš„ç±»åˆ«åŒ–

æ‰©å±• Memory Schema ä»¥æ”¯æŒåˆ†ç±»ï¼š

```python
from typing import Optional

class Memory(BaseModel):
    content: str = Field(description="è®°å¿†çš„ä¸»è¦å†…å®¹")
    category: Optional[str] = Field(
        default=None,
        description="è®°å¿†ç±»åˆ«ï¼špersonal, preference, event, skill ç­‰"
    )
    importance: Optional[int] = Field(
        default=5,
        ge=1,
        le=10,
        description="é‡è¦æ€§è¯„åˆ†ï¼ˆ1-10ï¼‰"
    )
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
memories = [
    Memory(content="User's name is Lance", category="personal", importance=10),
    Memory(content="Lance likes biking", category="preference", importance=8),
    Memory(content="Lance visited Tartine", category="event", importance=5)
]
```

**ç­›é€‰ç‰¹å®šç±»åˆ«**ï¼š
```python
def get_memories_by_category(store, user_id, category):
    namespace = ("memories", user_id)
    all_memories = store.search(namespace)

    return [
        mem for mem in all_memories
        if mem.value.get('category') == category
    ]

# åªè·å–åå¥½ä¿¡æ¯
preferences = get_memories_by_category(store, "1", "preference")
```

### 9.3 è®°å¿†çš„åˆå¹¶å’Œå»é‡

é˜²æ­¢è®°å¿†è¿‡åº¦å†—ä½™ï¼š

```python
def deduplicate_memories(store, user_id):
    """å»é™¤é‡å¤æˆ–ç›¸ä¼¼çš„è®°å¿†"""
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    # ä½¿ç”¨ LLM è¯†åˆ«é‡å¤
    # ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„é€»è¾‘ï¼‰
    unique_memories = {}
    for mem in memories:
        content = mem.value['content'].lower()
        # ç®€å•çš„ç›¸ä¼¼åº¦æ£€æŸ¥
        is_duplicate = False
        for existing_content in unique_memories.keys():
            if content in existing_content or existing_content in content:
                is_duplicate = True
                break

        if not is_duplicate:
            unique_memories[content] = mem

    return list(unique_memories.values())
```

### 9.4 è®°å¿†çš„è‡ªåŠ¨æ‘˜è¦

å½“è®°å¿†è¿‡å¤šæ—¶ï¼Œè‡ªåŠ¨ç”Ÿæˆæ‘˜è¦ï¼š

```python
def summarize_memories(model, memories):
    """å°†å¤šæ¡è®°å¿†å‹ç¼©ä¸ºæ‘˜è¦"""
    content_list = [mem.value['content'] for mem in memories]
    all_content = "\n".join(f"- {c}" for c in content_list)

    prompt = f"""Please create a concise summary of the following memories:

{all_content}

Summary:"""

    summary = model.invoke([HumanMessage(content=prompt)])
    return summary.content
```

---

## åã€å®è·µå»ºè®®

### 10.1 ä½•æ—¶ä½¿ç”¨ Collection

**âœ… é€‚åˆ Collection çš„åœºæ™¯**ï¼š

1. **ä¿¡æ¯ç±»å‹ä¸å›ºå®š**
   ```python
   # ç”¨æˆ·å¯èƒ½åˆ†äº«ä»»ä½•ç±»å‹çš„ä¿¡æ¯
   memories = [
       "Lance likes coffee",
       "Lance visited Paris in 2020",
       "Lance is learning French",
       "Lance prefers morning meetings"
   ]
   ```

2. **éœ€è¦æŒç»­å¢é•¿**
   ```python
   # éšç€æ—¶é—´æ¨ç§»ä¸æ–­æ·»åŠ æ–°è®°å¿†
   day_1: ["Lance likes biking"]
   day_2: ["Lance likes biking", "Lance tried Tartine"]
   day_3: ["Lance likes biking", "Lance tried Tartine", "Lance planning Japan trip"]
   ```

3. **éœ€è¦ç‹¬ç«‹ç®¡ç†æ¯ä¸ªé¡¹ç›®**
   ```python
   # æ¯æ¡è®°å¿†å¯ä»¥ç‹¬ç«‹æ›´æ–°æˆ–åˆ é™¤
   store.delete(namespace, memory_id_1)  # åˆ é™¤ç‰¹å®šè®°å¿†
   store.put(namespace, memory_id_2, updated_content)  # æ›´æ–°ç‰¹å®šè®°å¿†
   ```

4. **ç±»ä¼¼æ—¥å¿—æˆ–äº‹ä»¶æµ**
   ```python
   # è®°å½•ç”¨æˆ·çš„æ´»åŠ¨æµ
   "User logged in"
   "User completed tutorial"
   "User made first purchase"
   ```

### 10.2 Profile å’Œ Collection çš„ç»“åˆä½¿ç”¨

æœ€ä½³å®è·µï¼š**åŒæ—¶ä½¿ç”¨ä¸¤è€…**ï¼

```python
# Profileï¼šç»“æ„åŒ–çš„åŸºæœ¬ä¿¡æ¯
profile_namespace = ("profile", user_id)
profile = {
    "user_name": "Lance",
    "user_location": "San Francisco",
    "created_at": "2024-01-01"
}
store.put(profile_namespace, "user_profile", profile)

# Collectionï¼šçµæ´»çš„è¡¥å……ä¿¡æ¯
collection_namespace = ("memories", user_id)
memories = [
    {"content": "Lance likes biking"},
    {"content": "Lance visited Tartine bakery"},
    {"content": "Lance is planning a Japan trip"}
]
for memory in memories:
    store.put(collection_namespace, str(uuid.uuid4()), memory)
```

**åœ¨èŠå¤©æœºå™¨äººä¸­ä½¿ç”¨**ï¼š
```python
def call_model(state, config, store):
    user_id = config["configurable"]["user_id"]

    # åŠ è½½ Profile
    profile = store.get(("profile", user_id), "user_profile")
    profile_info = f"Name: {profile.value['user_name']}, Location: {profile.value['user_location']}"

    # åŠ è½½ Collection
    memories = store.search(("memories", user_id))
    memories_info = "\n".join(f"- {m.value['content']}" for m in memories)

    # ç»„åˆä¿¡æ¯
    system_msg = f"""You are a helpful assistant.

User Profile:
{profile_info}

Additional Memories:
{memories_info}"""

    response = model.invoke([SystemMessage(content=system_msg)] + state["messages"])
    return {"messages": response}
```

### 10.3 è®°å¿†ç®¡ç†æœ€ä½³å®è·µ

**1. å®šæœŸæ¸…ç†**ï¼š
```python
def cleanup_old_memories(store, user_id, days=90):
    """åˆ é™¤è¶…è¿‡ N å¤©çš„æ—§è®°å¿†"""
    from datetime import datetime, timedelta

    namespace = ("memories", user_id)
    memories = store.search(namespace)

    cutoff_date = datetime.now() - timedelta(days=days)

    for mem in memories:
        if datetime.fromisoformat(mem.created_at) < cutoff_date:
            store.delete(namespace, mem.key)
```

**2. é™åˆ¶è®°å¿†æ•°é‡**ï¼š
```python
MAX_MEMORIES = 100

def add_memory_with_limit(store, user_id, new_memory):
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    if len(memories) >= MAX_MEMORIES:
        # åˆ é™¤æœ€æ—§çš„è®°å¿†
        oldest = min(memories, key=lambda m: m.created_at)
        store.delete(namespace, oldest.key)

    # æ·»åŠ æ–°è®°å¿†
    store.put(namespace, str(uuid.uuid4()), new_memory)
```

**3. è®°å¿†è´¨é‡æ§åˆ¶**ï¼š
```python
def is_valuable_memory(content: str) -> bool:
    """åˆ¤æ–­è®°å¿†æ˜¯å¦æœ‰ä»·å€¼"""
    # è¿‡æ»¤å¤ªçŸ­çš„è®°å¿†
    if len(content) < 10:
        return False

    # è¿‡æ»¤æ— æ„ä¹‰çš„è®°å¿†
    useless_phrases = ["hello", "hi", "ok", "thanks", "bye"]
    if content.lower() in useless_phrases:
        return False

    return True

# åœ¨ write_memory ä¸­ä½¿ç”¨
for r in result["responses"]:
    if is_valuable_memory(r.content):
        store.put(namespace, str(uuid.uuid4()), r.model_dump())
```

---

## åä¸€ã€å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### 11.1 è®°å¿†è¿‡å¤šå¯¼è‡´ä¸Šä¸‹æ–‡è¿‡é•¿

**é—®é¢˜**ï¼š
```python
# æœ‰ 1000 æ¡è®°å¿†
memories = store.search(namespace)
# len(memories) = 1000

# å…¨éƒ¨ä¼ ç»™ LLM ä¼šè¶…å‡ºä¸Šä¸‹æ–‡é™åˆ¶
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

**æ–¹æ¡ˆ 1ï¼šé™åˆ¶æ•°é‡**
```python
# åªä½¿ç”¨æœ€è¿‘çš„ N æ¡
recent_memories = sorted(memories, key=lambda m: m.updated_at, reverse=True)[:20]
```

**æ–¹æ¡ˆ 2ï¼šè¯­ä¹‰æœç´¢**
```python
# ä½¿ç”¨å‘é‡æ•°æ®åº“æŸ¥æ‰¾ç›¸å…³è®°å¿†
from langchain.vectorstores import Chroma

# åˆ›å»ºå‘é‡å­˜å‚¨
vectorstore = Chroma.from_texts(
    [m.value['content'] for m in memories],
    embeddings
)

# æŸ¥è¯¢ç›¸å…³è®°å¿†
current_query = state["messages"][-1].content
relevant_memories = vectorstore.similarity_search(current_query, k=10)
```

**æ–¹æ¡ˆ 3ï¼šåˆ†å±‚æ‘˜è¦**
```python
# å¯¹æ—§è®°å¿†è¿›è¡Œæ‘˜è¦
old_memories_summary = summarize_memories(model, old_memories)
recent_memories_full = [m.value['content'] for m in recent_memories]

info = f"""Summary of older memories:
{old_memories_summary}

Recent memories:
{'\n'.join(recent_memories_full)}"""
```

### 11.2 é‡å¤è®°å¿†

**é—®é¢˜**ï¼š
```python
# ç”¨æˆ·å¤šæ¬¡æåˆ°åŒä¸€ä»¶äº‹
memories = [
    "Lance likes biking",
    "Lance enjoys biking",
    "Lance loves to bike"
]
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

**åœ¨ Trustcall æŒ‡ä»¤ä¸­æ˜ç¡®è¦æ±‚**ï¼š
```python
TRUSTCALL_INSTRUCTION = """Reflect on the following interaction.

Create or update memories, avoiding duplicates.

If a memory is similar to an existing one, UPDATE the existing memory instead of creating a new one.

Use parallel tool calling to handle updates and insertions simultaneously."""
```

**æˆ–è€…å®šæœŸå»é‡**ï¼š
```python
def merge_similar_memories(model, store, user_id):
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    # ä½¿ç”¨ LLM è¯†åˆ«ç›¸ä¼¼è®°å¿†
    content_list = [m.value['content'] for m in memories]

    prompt = f"""Identify groups of similar memories that should be merged:

{'\n'.join(f"{i}. {c}" for i, c in enumerate(content_list))}

Output groups of similar memory indices."""

    result = model.invoke([HumanMessage(content=prompt)])
    # å¤„ç†ç»“æœå¹¶åˆå¹¶...
```

### 11.3 è®°å¿†æ›´æ–°å¤±è´¥

**é—®é¢˜**ï¼š
```python
# Trustcall æ²¡æœ‰æ­£ç¡®è¯†åˆ«åº”è¯¥æ›´æ–°çš„è®°å¿†
# å¯¼è‡´åˆ›å»ºäº†æ–°è®°å¿†è€Œä¸æ˜¯æ›´æ–°ç°æœ‰è®°å¿†
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

**ç¡®ä¿ existing_memories æ ¼å¼æ­£ç¡®**ï¼š
```python
# æ­£ç¡®æ ¼å¼
existing_memories = [
    (mem.key, "Memory", mem.value)  # ä½¿ç”¨ mem.keyï¼Œä¸æ˜¯ str(i)
    for mem in store.search(namespace)
]

# é”™è¯¯æ ¼å¼ï¼ˆå¯èƒ½å¯¼è‡´æ›´æ–°å¤±è´¥ï¼‰
existing_memories = [
    (str(i), "Memory", mem.value)  # ä½¿ç”¨ç´¢å¼•è€Œä¸æ˜¯å®é™…çš„ key
    for i, mem in enumerate(...)
]
```

**æä¾›æ›´æ˜ç¡®çš„æ›´æ–°æŒ‡ä»¤**ï¼š
```python
TRUSTCALL_INSTRUCTION = """Review the existing memories and the new conversation.

For each piece of information:
1. If it's related to an existing memory, UPDATE that memory
2. If it's completely new information, CREATE a new memory

Prefer updating existing memories over creating new ones when possible."""
```

---

## åäºŒã€æ€§èƒ½ä¼˜åŒ–

### 12.1 æ‰¹é‡æ“ä½œ

**é—®é¢˜**ï¼šé€ä¸ªä¿å­˜è®°å¿†æ•ˆç‡ä½

**ä¼˜åŒ–**ï¼š
```python
# ä¸å¥½çš„åšæ³•
for memory in memories:
    store.put(namespace, str(uuid.uuid4()), memory)

# æ›´å¥½çš„åšæ³•ï¼ˆå¦‚æœ Store æ”¯æŒï¼‰
# ä½¿ç”¨æ‰¹é‡ API
items = [
    (namespace, str(uuid.uuid4()), mem.model_dump())
    for mem in result["responses"]
]
store.batch_put(items)  # å‡è®¾æœ‰æ‰¹é‡ API
```

### 12.2 ç¼“å­˜ç­–ç•¥

```python
from functools import lru_cache
from datetime import datetime, timedelta

# ç¼“å­˜è®°å¿†æŸ¥è¯¢
_memory_cache = {}
_cache_ttl = timedelta(minutes=5)

def get_memories_cached(store, user_id):
    cache_key = f"memories_{user_id}"

    if cache_key in _memory_cache:
        cached_data, cached_time = _memory_cache[cache_key]
        if datetime.now() - cached_time < _cache_ttl:
            return cached_data

    # ç¼“å­˜è¿‡æœŸæˆ–ä¸å­˜åœ¨ï¼Œé‡æ–°æŸ¥è¯¢
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    _memory_cache[cache_key] = (memories, datetime.now())
    return memories
```

### 12.3 å¼‚æ­¥å¤„ç†

```python
import asyncio

async def write_memory_async(state, config, store):
    """å¼‚æ­¥ä¿å­˜è®°å¿†"""
    # ... è·å– user_id å’Œå¤„ç† ...

    # å¼‚æ­¥è°ƒç”¨ Trustcall
    result = await trustcall_extractor.ainvoke({
        "messages": updated_messages,
        "existing": existing_memories
    })

    # å¼‚æ­¥ä¿å­˜
    tasks = [
        store.aput(namespace, key, value)
        for key, value in zip(keys, values)
    ]
    await asyncio.gather(*tasks)
```

---

## åä¸‰ã€æ€»ç»“

### 13.1 æ ¸å¿ƒè¦ç‚¹

1. **Collection æ˜¯å¤šä¸ªç‹¬ç«‹è®°å¿†é¡¹çš„é›†åˆ**
   - æ¯ä¸ªè®°å¿†æœ‰å”¯ä¸€çš„ UUID é”®
   - å¯ä»¥æ— é™æ‰©å±•
   - çµæ´»ä¸”å¼€æ”¾

2. **`enable_inserts=True` æ˜¯å…³é”®å‚æ•°**
   - å…è®¸ Trustcall æ’å…¥æ–°è®°å¿†
   - åŒæ—¶æ”¯æŒæ›´æ–°ç°æœ‰è®°å¿†
   - å®ç°å¹¶è¡Œæ›´æ–°å’Œæ’å…¥

3. **UUID ç®¡ç†è®°å¿†é¡¹**
   - `uuid.uuid4()` ç”Ÿæˆå”¯ä¸€æ ‡è¯†
   - æ”¯æŒç‹¬ç«‹çš„å¢åˆ æ”¹æŸ¥
   - é¿å…é”®å†²çª

4. **Trustcall æ™ºèƒ½å†³ç­–**
   - è‡ªåŠ¨åˆ¤æ–­æ›´æ–°è¿˜æ˜¯æ’å…¥
   - `json_doc_id` æ ‡è¯†æ›´æ–°æ“ä½œ
   - ä¿æŒä¿¡æ¯ä¸€è‡´æ€§

5. **Profile å’Œ Collection äº’è¡¥**
   - Profileï¼šå›ºå®šç»“æ„çš„æ ¸å¿ƒä¿¡æ¯
   - Collectionï¼šçµæ´»æ‰©å±•çš„è¡¥å……ä¿¡æ¯
   - ç»„åˆä½¿ç”¨æ•ˆæœæœ€ä½³

### 13.2 å­¦åˆ°çš„æŠ€èƒ½

**Python æŠ€èƒ½**ï¼š
- UUID çš„ç”Ÿæˆå’Œä½¿ç”¨
- ç”Ÿæˆå™¨è¡¨è¾¾å¼å’Œåˆ—è¡¨æ¨å¯¼å¼
- `zip()` å‡½æ•°çš„å¹¶è¡Œè¿­ä»£
- `.get()` æ–¹æ³•çš„é»˜è®¤å€¼å¤„ç†
- `merge_message_runs()` çš„ä½¿ç”¨

**LangChain/LangGraph æŠ€èƒ½**ï¼š
- Collection Schema çš„å®šä¹‰
- `enable_inserts=True` å‚æ•°
- Store çš„ `search()` vs `get()`
- Trustcall çš„é«˜çº§ç”¨æ³•
- è®°å¿†æ ¼å¼åŒ–å’Œå±•ç¤º

**ç³»ç»Ÿè®¾è®¡**ï¼š
- Profile vs Collection çš„é€‰æ‹©
- è®°å¿†ç®¡ç†ç­–ç•¥
- æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- æ‰©å±•æ€§è€ƒè™‘

### 13.3 Profile vs Collection å†³ç­–æ ‘

```
éœ€è¦ä¿å­˜ä¿¡æ¯
    â†“
ä¿¡æ¯ç»“æ„æ˜¯å¦å›ºå®šï¼Ÿ
    â†“
  Yes                    No
    â†“                     â†“
å­—æ®µæ•°é‡æ˜¯å¦æœ‰é™ï¼Ÿ    ä¿¡æ¯æ˜¯å¦æŒç»­å¢é•¿ï¼Ÿ
    â†“                     â†“
  Yes        No         Yes        No
    â†“         â†“           â†“          â†“
  Profile   è€ƒè™‘      Collection   è€ƒè™‘
            Profile+                 Profile
            Collection              (å¦‚æœçœŸçš„å›ºå®š)
```

### 13.4 æœ€ä½³å®è·µæ€»ç»“

| åœºæ™¯ | å»ºè®® |
|------|------|
| **çº¯ç»“æ„åŒ–æ•°æ®** | ä½¿ç”¨ Profile |
| **çº¯å¼€æ”¾å¼æ•°æ®** | ä½¿ç”¨ Collection |
| **æ··åˆåœºæ™¯** | Profile + Collection |
| **å¤§é‡è®°å¿†** | Collection + ç­›é€‰/æ‘˜è¦ |
| **æ€§èƒ½å…³é”®** | ç¼“å­˜ + æ‰¹é‡æ“ä½œ |
| **éœ€è¦æœç´¢** | Collection + å‘é‡æ•°æ®åº“ |

### 13.5 ä¸‹ä¸€æ­¥

**è¿›é˜¶ä¸»é¢˜**ï¼š
1. **å‘é‡æœç´¢**ï¼šä½¿ç”¨ Embedding å’Œå‘é‡æ•°æ®åº“æ£€ç´¢ç›¸å…³è®°å¿†
2. **è®°å¿†å›¾**ï¼šå»ºç«‹è®°å¿†ä¹‹é—´çš„å…³ç³»ç½‘ç»œ
3. **è‡ªåŠ¨å½’æ¡£**ï¼šæ™ºèƒ½ç®¡ç†è®°å¿†çš„ç”Ÿå‘½å‘¨æœŸ
4. **å¤šæ¨¡æ€è®°å¿†**ï¼šä¸ä»…æ˜¯æ–‡æœ¬ï¼Œè¿˜åŒ…æ‹¬å›¾ç‰‡ã€éŸ³é¢‘ç­‰

**å®é™…åº”ç”¨**ï¼š
1. **ä¸ªäºº AI åŠ©ç†**ï¼šç»“åˆ Profile å’Œ Collection
2. **å®¢æœæœºå™¨äºº**ï¼šè®°å½•ç”¨æˆ·å†å²å’Œåå¥½
3. **æ•™è‚²è¾…å¯¼**ï¼šè¿½è¸ªå­¦ç”Ÿçš„å­¦ä¹ è¿›åº¦
4. **å†…å®¹æ¨è**ï¼šåŸºäºè®°å¿†çš„ä¸ªæ€§åŒ–æ¨è

---

## åå››ã€é™„å½•

### A.1 å®Œæ•´ä»£ç æ¸…å•

```python
# å¯¼å…¥ä¾èµ–
from IPython.display import Image, display
import uuid
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.store.memory import InMemoryStore
from langchain_core.messages import merge_message_runs, HumanMessage, SystemMessage
from langchain_core.runnables.config import RunnableConfig
from langgraph.checkpoint.memory import MemorySaver
from langgraph.store.base import BaseStore
from langchain_openai import ChatOpenAI
from trustcall import create_extractor
from pydantic import BaseModel, Field

# åˆå§‹åŒ–æ¨¡å‹
model = ChatOpenAI(model="gpt-5-nano", temperature=0)

# Memory Schema
class Memory(BaseModel):
    content: str = Field(
        description="The main content of the memory. For example: User expressed interest in learning about French."
    )

# åˆ›å»º Trustcall æå–å™¨
trustcall_extractor = create_extractor(
    model,
    tools=[Memory],
    tool_choice="Memory",
    enable_inserts=True,
)

# ç³»ç»Ÿæç¤ºè¯
MODEL_SYSTEM_MESSAGE = """You are a helpful chatbot. You are designed to be a companion to a user.

You have a long term memory which keeps track of information you learn about the user over time.

Current Memory (may include updated memories from this conversation):

{memory}"""

TRUSTCALL_INSTRUCTION = """Reflect on following interaction.

Use the provided tools to retain any necessary memories about the user.

Use parallel tool calling to handle updates and insertions simultaneously:"""

# å®šä¹‰èŠ‚ç‚¹
def call_model(state: MessagesState, config: RunnableConfig, store: BaseStore):
    user_id = config["configurable"]["user_id"]
    namespace = ("memories", user_id)
    memories = store.search(namespace)

    info = "\n".join(f"- {mem.value['content']}" for mem in memories)
    system_msg = MODEL_SYSTEM_MESSAGE.format(memory=info)

    response = model.invoke([SystemMessage(content=system_msg)] + state["messages"])
    return {"messages": response}

def write_memory(state: MessagesState, config: RunnableConfig, store: BaseStore):
    user_id = config["configurable"]["user_id"]
    namespace = ("memories", user_id)
    existing_items = store.search(namespace)

    tool_name = "Memory"
    existing_memories = (
        [(existing_item.key, tool_name, existing_item.value)
         for existing_item in existing_items]
        if existing_items
        else None
    )

    updated_messages = list(merge_message_runs(
        messages=[SystemMessage(content=TRUSTCALL_INSTRUCTION)] + state["messages"]
    ))

    result = trustcall_extractor.invoke({
        "messages": updated_messages,
        "existing": existing_memories
    })

    for r, rmeta in zip(result["responses"], result["response_metadata"]):
        store.put(
            namespace,
            rmeta.get("json_doc_id", str(uuid.uuid4())),
            r.model_dump(mode="json"),
        )

# æ„å»ºå›¾
builder = StateGraph(MessagesState)
builder.add_node("call_model", call_model)
builder.add_node("write_memory", write_memory)
builder.add_edge(START, "call_model")
builder.add_edge("call_model", "write_memory")
builder.add_edge("write_memory", END)

# ç¼–è¯‘å›¾
across_thread_memory = InMemoryStore()
within_thread_memory = MemorySaver()
graph = builder.compile(
    checkpointer=within_thread_memory,
    store=across_thread_memory
)

# ä½¿ç”¨ç¤ºä¾‹
config = {"configurable": {"thread_id": "1", "user_id": "1"}}
input_messages = [HumanMessage(content="Hi, my name is Lance")]

for chunk in graph.stream({"messages": input_messages}, config, stream_mode="values"):
    chunk["messages"][-1].pretty_print()
```

### A.2 å¸¸ç”¨æ“ä½œé€ŸæŸ¥è¡¨

```python
# åˆ›å»º Collection æå–å™¨
extractor = create_extractor(
    model,
    tools=[Memory],
    tool_choice="Memory",
    enable_inserts=True  # å…³é”®ï¼
)

# æå–è®°å¿†ï¼ˆåˆ›å»ºï¼‰
result = extractor.invoke({
    "messages": [...]
})

# æå–è®°å¿†ï¼ˆæ›´æ–°+æ’å…¥ï¼‰
result = extractor.invoke(
    {"messages": [...]},
    {"existing": [(key, "Memory", data), ...]}
)

# ä¿å­˜è®°å¿†åˆ° Store
for r, rmeta in zip(result["responses"], result["response_metadata"]):
    store.put(
        namespace,
        rmeta.get("json_doc_id", str(uuid.uuid4())),
        r.model_dump(mode="json")
    )

# æ£€ç´¢æ‰€æœ‰è®°å¿†
memories = store.search(namespace)

# æ ¼å¼åŒ–è®°å¿†
info = "\n".join(f"- {m.value['content']}" for m in memories)

# åˆ é™¤ç‰¹å®šè®°å¿†
store.delete(namespace, memory_key)
```

### A.3 Profile + Collection æ¨¡æ¿

```python
def call_model_hybrid(state, config, store):
    """åŒæ—¶ä½¿ç”¨ Profile å’Œ Collection"""
    user_id = config["configurable"]["user_id"]

    # åŠ è½½ Profile
    profile = store.get(("profile", user_id), "user_profile")
    if profile:
        profile_info = f"""User Profile:
- Name: {profile.value['user_name']}
- Location: {profile.value['user_location']}"""
    else:
        profile_info = "No profile information available."

    # åŠ è½½ Collection
    memories = store.search(("memories", user_id))
    if memories:
        memories_info = "Additional Memories:\n" + "\n".join(
            f"- {m.value['content']}" for m in memories
        )
    else:
        memories_info = "No additional memories available."

    # ç»„åˆä¿¡æ¯
    system_msg = f"""You are a helpful assistant.

{profile_info}

{memories_info}

Use this information to personalize your responses."""

    response = model.invoke([SystemMessage(content=system_msg)] + state["messages"])
    return {"messages": response}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0
**æœ€åæ›´æ–°**ï¼š2024-11-05
**ä½œè€…**ï¼šAI Assistant
**åŸºäº**ï¼šLangChain Academy Module-5 Lesson 5.4

æ­å–œä½ å®Œæˆäº† Module-5 çš„æ‰€æœ‰å†…å®¹ï¼å¸Œæœ›è¿™ä»½è¯¦ç»†è§£è¯»èƒ½å¸®åŠ©ä½ å®Œå…¨æŒæ¡ LangGraph çš„ Collection Schema å’Œè®°å¿†ç®¡ç†ç³»ç»Ÿï¼ğŸ‰
