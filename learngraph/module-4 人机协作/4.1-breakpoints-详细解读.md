# LangGraph Breakpoints è¯¦ç»†è§£è¯»

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è§£è¯» LangGraph ä¸­çš„ **Breakpointsï¼ˆæ–­ç‚¹ï¼‰** æœºåˆ¶ã€‚Breakpoints æ˜¯å®ç° **Human-in-the-Loopï¼ˆäººæœºååŒï¼‰** çš„åŸºç¡€å·¥å…·ï¼Œå…è®¸æˆ‘ä»¬åœ¨ Agent æ‰§è¡Œè¿‡ç¨‹ä¸­æš‚åœï¼Œè·å–ç”¨æˆ·ç¡®è®¤ï¼Œå¹¶ç»§ç»­æ‰§è¡Œã€‚è¿™æ˜¯æ„å»ºå¯æ§ã€å¯ä¿¡ AI åº”ç”¨çš„å…³é”®æŠ€æœ¯ã€‚

---

## ğŸ“š æœ¯è¯­è¡¨

| æœ¯è¯­åç§° | LangGraph å®šä¹‰å’Œè§£è¯» | Python å®šä¹‰å’Œè¯´æ˜ | é‡è¦ç¨‹åº¦ |
|---------|---------------------|------------------|---------|
| **Breakpoint** | å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­çš„ä¸»åŠ¨æš‚åœç‚¹ï¼Œå¯åœ¨èŠ‚ç‚¹æ‰§è¡Œå‰/åä¸­æ–­ï¼Œç­‰å¾…äººå·¥å¹²é¢„åç»§ç»­æ‰§è¡Œ | N/A (LangGraph ç‰¹æœ‰æ¦‚å¿µ) | â­â­â­â­â­ |
| **interrupt_before** | ç¼–è¯‘æ—¶è®¾ç½®çš„æ–­ç‚¹å‚æ•°ï¼Œåœ¨æŒ‡å®šèŠ‚ç‚¹æ‰§è¡Œå‰æš‚åœå›¾çš„è¿è¡Œ | `graph.compile(interrupt_before=["node"])` çš„å…³é”®å­—å‚æ•° | â­â­â­â­â­ |
| **interrupt_after** | ç¼–è¯‘æ—¶è®¾ç½®çš„æ–­ç‚¹å‚æ•°ï¼Œåœ¨æŒ‡å®šèŠ‚ç‚¹æ‰§è¡Œåæš‚åœå›¾çš„è¿è¡Œ | `graph.compile(interrupt_after=["node"])` çš„å…³é”®å­—å‚æ•° | â­â­â­â­ |
| **Checkpointer** | çŠ¶æ€æŒä¹…åŒ–ç®¡ç†å™¨ï¼Œè‡ªåŠ¨ä¿å­˜å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­çš„çŠ¶æ€å¿«ç…§ï¼Œæ”¯æŒæ–­ç‚¹æ¢å¤å’ŒçŠ¶æ€å›æº¯ | å®ç°æ£€æŸ¥ç‚¹åè®®çš„ç±»ï¼Œå¦‚ `MemorySaver()` | â­â­â­â­â­ |
| **MemorySaver** | å†…å­˜ä¸­çš„ checkpointer å®ç°ï¼Œé€‚ç”¨äºå¼€å‘æµ‹è¯•ï¼Œè¿›ç¨‹é‡å¯åæ•°æ®ä¸¢å¤± | `from langgraph.checkpoint.memory import MemorySaver` | â­â­â­â­ |
| **get_state()** | è·å–å›¾å½“å‰çŠ¶æ€çš„æ–¹æ³•ï¼Œè¿”å› StateSnapshot å¯¹è±¡ï¼ŒåŒ…å«çŠ¶æ€å€¼ã€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ç­‰ä¿¡æ¯ | `state = graph.get_state(config)` | â­â­â­â­â­ |
| **StateSnapshot** | çŠ¶æ€å¿«ç…§å¯¹è±¡ï¼ŒåŒ…å« values(çŠ¶æ€æ•°æ®)ã€next(ä¸‹ä¸€èŠ‚ç‚¹)ã€tasks(å¾…æ‰§è¡Œä»»åŠ¡)ç­‰å±æ€§ | TypedDict æˆ–ç±»ä¼¼ç»“æ„ï¼ŒåŒ…å«å¤šä¸ªå±æ€§å­—æ®µ | â­â­â­â­ |
| **stream(None)** | ä»æ–­ç‚¹æ¢å¤æ‰§è¡Œçš„å…³é”®ç”¨æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¼ å…¥ None è¡¨ç¤ºä¸æ·»åŠ æ–°è¾“å…¥ï¼Œä½¿ç”¨å½“å‰çŠ¶æ€ç»§ç»­ | `for event in graph.stream(None, config)` | â­â­â­â­â­ |
| **Thread** | çº¿ç¨‹é…ç½®ï¼Œç”¨äºæ ‡è¯†å’Œéš”ç¦»ä¸åŒçš„ä¼šè¯ï¼Œé€šè¿‡ thread_id åŒºåˆ†ä¸åŒç”¨æˆ·æˆ–å¯¹è¯ | `config = {"configurable": {"thread_id": "1"}}` å­—å…¸ç»“æ„ | â­â­â­â­â­ |
| **tools_condition** | LangGraph é¢„å®šä¹‰çš„æ¡ä»¶å‡½æ•°ï¼Œåˆ¤æ–­ AI æ¶ˆæ¯æ˜¯å¦åŒ…å«å·¥å…·è°ƒç”¨ï¼Œè‡ªåŠ¨è·¯ç”±åˆ°å·¥å…·èŠ‚ç‚¹æˆ–ç»“æŸ | `from langgraph.prebuilt import tools_condition` | â­â­â­â­ |
| **ToolNode** | LangGraph é¢„å®šä¹‰çš„å·¥å…·æ‰§è¡ŒèŠ‚ç‚¹ï¼Œè‡ªåŠ¨æ‰§è¡Œ AI æ¶ˆæ¯ä¸­çš„å·¥å…·è°ƒç”¨å¹¶è¿”å›ç»“æœ | `from langgraph.prebuilt import ToolNode` | â­â­â­â­ |
| **Human-in-the-Loop** | äººæœºååŒæ¨¡å¼ï¼ŒåŒ…æ‹¬å®¡æ‰¹(Approval)ã€è°ƒè¯•(Debugging)ã€ç¼–è¾‘(Editing)ä¸‰å¤§åº”ç”¨åœºæ™¯ | N/A (è®¾è®¡æ¨¡å¼æ¦‚å¿µ) | â­â­â­â­â­ |

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### ä»€ä¹ˆæ˜¯ Breakpointsï¼Ÿ

Breakpointsï¼ˆæ–­ç‚¹ï¼‰æ˜¯ LangGraph æä¾›çš„ä¸€ç§æœºåˆ¶ï¼Œå…è®¸ä½ åœ¨å›¾çš„æ‰§è¡Œè¿‡ç¨‹ä¸­**ä¸»åŠ¨æš‚åœ**ï¼Œå¹¶åœ¨ç‰¹å®šèŠ‚ç‚¹å‰**ç­‰å¾…äººå·¥å¹²é¢„**ã€‚

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
1. **æš‚åœæ‰§è¡Œ**ï¼šåœ¨æŒ‡å®šèŠ‚ç‚¹å‰åœæ­¢å›¾çš„æ‰§è¡Œ
2. **æ£€æŸ¥çŠ¶æ€**ï¼šæŸ¥çœ‹å½“å‰å›¾çš„çŠ¶æ€
3. **äººå·¥å†³ç­–**ï¼šç”±äººç±»å†³å®šæ˜¯å¦ç»§ç»­æ‰§è¡Œ
4. **æ¢å¤æ‰§è¡Œ**ï¼šæ‰¹å‡†åï¼Œä»æ–­ç‚¹å¤„ç»§ç»­è¿è¡Œ

### Human-in-the-Loop ä¸‰å¤§åº”ç”¨åœºæ™¯

æ ¹æ®æ•™ç¨‹ä»‹ç»ï¼ŒHuman-in-the-Loop æœ‰ä¸‰ä¸ªä¸»è¦åº”ç”¨åœºæ™¯ï¼š

#### 1. Approvalï¼ˆå®¡æ‰¹ï¼‰
- **åœºæ™¯**ï¼šAgent åœ¨æ‰§è¡Œæ•æ„Ÿæ“ä½œå‰ï¼Œéœ€è¦è·å¾—äººå·¥æ‰¹å‡†
- **ç¤ºä¾‹**ï¼š
  - è°ƒç”¨æ”¯ä»˜ API å‰ç¡®è®¤
  - åˆ é™¤æ•°æ®å‰ç¡®è®¤
  - å‘é€é‚®ä»¶å‰å®¡æŸ¥å†…å®¹
  - æ‰§è¡Œå·¥å…·è°ƒç”¨å‰éªŒè¯

#### 2. Debuggingï¼ˆè°ƒè¯•ï¼‰
- **åœºæ™¯**ï¼šå›æ”¾å›¾çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œå®šä½é—®é¢˜
- **ç¤ºä¾‹**ï¼š
  - æ£€æŸ¥æŸä¸ªèŠ‚ç‚¹çš„è¾“å…¥è¾“å‡º
  - åˆ†æ Agent çš„å†³ç­–è·¯å¾„
  - é‡ç°é”™è¯¯åœºæ™¯

#### 3. Editingï¼ˆç¼–è¾‘ï¼‰
- **åœºæ™¯**ï¼šåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€
- **ç¤ºä¾‹**ï¼š
  - çº æ­£ Agent çš„é”™è¯¯åˆ¤æ–­
  - è°ƒæ•´å·¥å…·è°ƒç”¨å‚æ•°
  - ä¿®æ”¹ä¸­é—´ç»“æœ

**æœ¬æ•™ç¨‹é‡ç‚¹ï¼š** æˆ‘ä»¬å°†èšç„¦äº **Approvalï¼ˆå®¡æ‰¹ï¼‰** åœºæ™¯ï¼Œå­¦ä¹ å¦‚ä½•ä½¿ç”¨ Breakpoints å®ç°å·¥å…·è°ƒç”¨å®¡æ‰¹ã€‚

---

## ğŸ­ å®æˆ˜æ¡ˆä¾‹ï¼šå¸¦å®¡æ‰¹çš„æ•°å­¦åŠ©æ‰‹

æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªæ•°å­¦è®¡ç®— Agentï¼Œåœ¨è°ƒç”¨ä»»ä½•å·¥å…·å‰ï¼Œéƒ½éœ€è¦è·å¾—ç”¨æˆ·æ‰¹å‡†ã€‚

### ç³»ç»Ÿæ¶æ„å›¾

```
ç”¨æˆ·è¾“å…¥: "Multiply 2 and 3"
        â†“
   [assistant] ç”Ÿæˆå·¥å…·è°ƒç”¨
        â†“
   ğŸ›‘ BREAKPOINT (interrupt_before=["tools"])
        â†“
   ç­‰å¾…ç”¨æˆ·æ‰¹å‡†...
        â†“
   ç”¨æˆ·è¾“å…¥: "yes"
        â†“
   [tools] æ‰§è¡Œå·¥å…· (multiply)
        â†“
   [assistant] ç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ
        â†“
   è¾“å‡º: "The result is 6"
```

---

## ğŸ”§ ä»£ç å®ç°è¯¦è§£

### 1. å®šä¹‰å·¥å…·å’Œæ¨¡å‹

```python
from langchain_openai import ChatOpenAI

def multiply(a: int, b: int) -> int:
    """Multiply a and b.

    Args:
        a: first int
        b: second int
    """
    return a * b

def add(a: int, b: int) -> int:
    """Adds a and b.

    Args:
        a: first int
        b: second int
    """
    return a + b

def divide(a: int, b: int) -> float:
    """Divide a by b.

    Args:
        a: first int
        b: second int
    """
    return a / b

tools = [add, multiply, divide]
llm = ChatOpenAI(model="gpt-5-nano")
llm_with_tools = llm.bind_tools(tools)
```

**è¯´æ˜ï¼š**
- å®šä¹‰äº†ä¸‰ä¸ªç®€å•çš„æ•°å­¦å·¥å…·
- `llm.bind_tools(tools)` å°†å·¥å…·ç»‘å®šåˆ° LLMï¼Œä½¿å…¶èƒ½å¤Ÿç”Ÿæˆå·¥å…·è°ƒç”¨

**Python çŸ¥è¯†ç‚¹ï¼šå‡½æ•°æ–‡æ¡£å­—ç¬¦ä¸²ï¼ˆDocstringï¼‰**

```python
def multiply(a: int, b: int) -> int:
    """Multiply a and b.  # â† ç®€çŸ­æè¿°

    Args:              # â† å‚æ•°è¯´æ˜
        a: first int
        b: second int
    """
    return a * b
```

åœ¨ LangChain ä¸­ï¼Œè¿™ä¸ª docstring ä¼šè¢«ä¼ é€’ç»™ LLMï¼Œå¸®åŠ©å®ƒç†è§£å¦‚ä½•ä½¿ç”¨å·¥å…·ï¼š
- **æè¿°**ï¼šå‘Šè¯‰ LLM è¿™ä¸ªå·¥å…·çš„ä½œç”¨
- **å‚æ•°**ï¼šè¯´æ˜æ¯ä¸ªå‚æ•°çš„å«ä¹‰å’Œç±»å‹
- **LLM åˆ©ç”¨**ï¼šLLM ä¼šæ ¹æ®è¿™äº›ä¿¡æ¯å†³å®šä½•æ—¶è°ƒç”¨å·¥å…·ï¼Œä»¥åŠä¼ é€’ä»€ä¹ˆå‚æ•°

---

### 2. å®šä¹‰çŠ¶æ€

```python
from langgraph.graph import MessagesState
```

**LangGraph çŸ¥è¯†ç‚¹ï¼šMessagesState**

`MessagesState` æ˜¯ LangGraph é¢„å®šä¹‰çš„çŠ¶æ€ç±»ï¼Œä¸“é—¨ç”¨äºèŠå¤©åœºæ™¯ï¼š

```python
class MessagesState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
```

**å…³é”®ç‰¹æ€§ï¼š**
1. **è‡ªåŠ¨æ¶ˆæ¯ç®¡ç†**ï¼šä½¿ç”¨ `add_messages` reducerï¼Œè‡ªåŠ¨å¤„ç†æ¶ˆæ¯è¿½åŠ 
2. **æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹**ï¼š`HumanMessage`ã€`AIMessage`ã€`ToolMessage`ã€`SystemMessage`
3. **å»é‡å’Œæ›´æ–°**ï¼šæ ¹æ®æ¶ˆæ¯ ID è‡ªåŠ¨å»é‡å’Œæ›´æ–°

**ç­‰ä»·çš„æ‰‹åŠ¨å®šä¹‰ï¼š**
```python
from typing import Annotated
from typing_extensions import TypedDict
from langgraph.graph.message import add_messages

class MessagesState(TypedDict):
    messages: Annotated[list, add_messages]
```

---

### 3. å®šä¹‰èŠ‚ç‚¹

```python
from langchain_core.messages import AIMessage, HumanMessage, SystemMessage

# System message
sys_msg = SystemMessage(content="You are a helpful assistant tasked with performing arithmetic on a set of inputs.")

# Node
def assistant(state: MessagesState):
    return {"messages": [llm_with_tools.invoke([sys_msg] + state["messages"])]}
```

**åŠŸèƒ½ï¼š**
- æ¥æ”¶å½“å‰å¯¹è¯å†å² (`state["messages"]`)
- æ·»åŠ ç³»ç»Ÿæç¤ºè¯
- è°ƒç”¨ LLM ç”Ÿæˆå“åº”ï¼ˆå¯èƒ½åŒ…å«å·¥å…·è°ƒç”¨ï¼‰
- è¿”å›æ–°çš„ AIMessage

**Python çŸ¥è¯†ç‚¹ï¼šåˆ—è¡¨æ‹¼æ¥**

```python
[sys_msg] + state["messages"]
# ç›¸å½“äºï¼š
# [SystemMessage(...), HumanMessage(...), AIMessage(...), ...]
```

è¿™æ ·å¯ä»¥ç¡®ä¿ç³»ç»Ÿæç¤ºè¯æ€»æ˜¯åœ¨å¯¹è¯å†å²çš„å¼€å¤´ã€‚

---

### 4. æ„å»ºå›¾ï¼ˆæ ¸å¿ƒï¼šæ·»åŠ  Breakpointï¼‰

```python
from IPython.display import Image, display
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import START, StateGraph
from langgraph.prebuilt import tools_condition, ToolNode

# Graph
builder = StateGraph(MessagesState)

# Define nodes: these do the work
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))

# Define edges: these determine the control flow
builder.add_edge(START, "assistant")
builder.add_conditional_edges(
    "assistant",
    tools_condition,
)
builder.add_edge("tools", "assistant")

memory = MemorySaver()
graph = builder.compile(interrupt_before=["tools"], checkpointer=memory)

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
display(Image(graph.get_graph().draw_mermaid_png()))
```

**å…³é”®ç‚¹åˆ†æï¼š**

#### (1) interrupt_before=["tools"]

è¿™æ˜¯å®ç° Breakpoint çš„æ ¸å¿ƒï¼

```python
graph = builder.compile(interrupt_before=["tools"], checkpointer=memory)
#                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
#                      åœ¨ "tools" èŠ‚ç‚¹å‰ä¸­æ–­
```

**æ•ˆæœï¼š**
- å½“å›¾æ‰§è¡Œåˆ° `tools` èŠ‚ç‚¹å‰æ—¶ï¼Œ**è‡ªåŠ¨æš‚åœ**
- çŠ¶æ€è¢«ä¿å­˜åˆ° checkpoint
- ç­‰å¾…ç”¨æˆ·è°ƒç”¨ `graph.stream(None, ...)` ç»§ç»­æ‰§è¡Œ

**å…¶ä»–é€‰é¡¹ï¼š**
```python
# åœ¨èŠ‚ç‚¹åä¸­æ–­
interrupt_after=["assistant"]

# åŒæ—¶ä½¿ç”¨
interrupt_before=["tools"]
interrupt_after=["assistant"]
```

#### (2) checkpointer=memory

**ä¸ºä»€ä¹ˆéœ€è¦ checkpointerï¼Ÿ**

Breakpoints ä¾èµ–äºçŠ¶æ€æŒä¹…åŒ–ï¼š
- **æš‚åœæ—¶**ï¼šå°†å½“å‰çŠ¶æ€ä¿å­˜åˆ° checkpoint
- **æ¢å¤æ—¶**ï¼šä» checkpoint åŠ è½½çŠ¶æ€ï¼Œç»§ç»­æ‰§è¡Œ

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()  # å†…å­˜å­˜å‚¨ï¼ˆå¼€å‘æµ‹è¯•ç”¨ï¼‰
# ç”Ÿäº§ç¯å¢ƒå¯ä»¥ä½¿ç”¨ï¼š
# - PostgresSaver (æ•°æ®åº“æŒä¹…åŒ–)
# - RedisSaver (Redis æŒä¹…åŒ–)
```

#### (3) tools_condition

è¿™æ˜¯ LangGraph é¢„å®šä¹‰çš„æ¡ä»¶å‡½æ•°ï¼š

```python
from langgraph.prebuilt import tools_condition
```

**åŠŸèƒ½ï¼š**
- æ£€æŸ¥æœ€æ–°çš„ AIMessage æ˜¯å¦åŒ…å«å·¥å…·è°ƒç”¨
- å¦‚æœæœ‰å·¥å…·è°ƒç”¨ â†’ è·¯ç”±åˆ° `tools` èŠ‚ç‚¹
- å¦‚æœæ²¡æœ‰å·¥å…·è°ƒç”¨ â†’ è·¯ç”±åˆ° `END`

**ç­‰ä»·çš„æ‰‹åŠ¨å®ç°ï¼š**
```python
def tools_condition(state: MessagesState):
    last_message = state["messages"][-1]
    if isinstance(last_message, AIMessage) and last_message.tool_calls:
        return "tools"
    return END
```

#### (4) ToolNode

è¿™æ˜¯ LangGraph é¢„å®šä¹‰çš„å·¥å…·æ‰§è¡ŒèŠ‚ç‚¹ï¼š

```python
from langgraph.prebuilt import ToolNode

tools_node = ToolNode(tools)
```

**åŠŸèƒ½ï¼š**
- è‡ªåŠ¨æ‰§è¡Œ AIMessage ä¸­çš„å·¥å…·è°ƒç”¨
- è¿”å› ToolMessage ç»“æœ
- æ”¯æŒå¹¶è¡Œå·¥å…·è°ƒç”¨
- å†…ç½®é”™è¯¯å¤„ç†

---

### 5. ç¬¬ä¸€æ¬¡æ‰§è¡Œï¼šè§¦å‘ Breakpoint

```python
# Input
initial_input = {"messages": HumanMessage(content="Multiply 2 and 3")}

# Thread
thread = {"configurable": {"thread_id": "1"}}

# Run the graph until the first interruption
for event in graph.stream(initial_input, thread, stream_mode="values"):
    event['messages'][-1].pretty_print()
```

**è¾“å‡ºï¼š**
```
================================ Human Message =================================
Multiply 2 and 3

================================== Ai Message ==================================
Tool Calls:
  multiply (call_oFkGpnO8CuwW9A1rk49nqBpY)
 Call ID: call_oFkGpnO8CuwW9A1rk49nqBpY
  Args:
    a: 2
    b: 3
```

**æ‰§è¡Œæµç¨‹ï¼š**
1. ç”¨æˆ·è¾“å…¥ "Multiply 2 and 3"
2. `assistant` èŠ‚ç‚¹ç”Ÿæˆ AIMessageï¼ŒåŒ…å« `multiply` å·¥å…·è°ƒç”¨
3. å›¾å‡†å¤‡è¿›å…¥ `tools` èŠ‚ç‚¹
4. **è§¦å‘ breakpoint**ï¼Œæ‰§è¡Œæš‚åœ ğŸ›‘
5. è¿”å›å½“å‰çŠ¶æ€ï¼ˆåŒ…å«å·¥å…·è°ƒç”¨çš„ AIMessageï¼‰

**LangGraph çŸ¥è¯†ç‚¹ï¼šThread å’ŒçŠ¶æ€éš”ç¦»**

```python
thread = {"configurable": {"thread_id": "1"}}
```

**Thread çš„ä½œç”¨ï¼š**
- æ¯ä¸ª `thread_id` å¯¹åº”ä¸€ä¸ªç‹¬ç«‹çš„å¯¹è¯ä¼šè¯
- ä¸åŒ thread çš„çŠ¶æ€å®Œå…¨éš”ç¦»
- æ”¯æŒå¹¶å‘æ‰§è¡Œå¤šä¸ªå¯¹è¯

**ç¤ºä¾‹ï¼š**
```python
# Thread 1
thread1 = {"configurable": {"thread_id": "1"}}
graph.stream({"messages": [HumanMessage("Hi")]}, thread1)

# Thread 2ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
thread2 = {"configurable": {"thread_id": "2"}}
graph.stream({"messages": [HumanMessage("Hello")]}, thread2)
```

---

### 6. æ£€æŸ¥çŠ¶æ€

```python
state = graph.get_state(thread)
print(state.next)
```

**è¾“å‡ºï¼š**
```
('tools',)
```

**LangGraph çŸ¥è¯†ç‚¹ï¼šget_state()**

```python
state = graph.get_state(thread)
```

**è¿”å›çš„ state å¯¹è±¡åŒ…å«ï¼š**
- `state.values`ï¼šå½“å‰çŠ¶æ€æ•°æ®ï¼ˆå¦‚ `messages`ï¼‰
- `state.next`ï¼šä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰ breakpointï¼‰
- `state.tasks`ï¼šå¾…æ‰§è¡Œçš„ä»»åŠ¡
- `state.config`ï¼šé…ç½®ä¿¡æ¯

**ç”¨é€”ï¼š**
- æ£€æŸ¥å›¾æ˜¯å¦åœ¨ breakpoint å¤„æš‚åœ
- æŸ¥çœ‹å½“å‰çŠ¶æ€
- ç”¨äºè°ƒè¯•å’Œç›‘æ§

---

### 7. æ¢å¤æ‰§è¡Œï¼šç»§ç»­ä»æ–­ç‚¹æ‰§è¡Œ

![Resuming from Breakpoint](https://cdn.prod.website-files.com/65b8cd72835ceeacd4449a53/66dbae7985b747dfed67775d_breakpoints1.png)

```python
for event in graph.stream(None, thread, stream_mode="values"):
    event['messages'][-1].pretty_print()
```

**æ ¸å¿ƒæŠ€å·§ï¼šä¼ å…¥ `None` ä½œä¸ºè¾“å…¥ï¼**

```python
graph.stream(None, thread, stream_mode="values")
#            ^^^^
#            å…³é”®ï¼šä½¿ç”¨ None
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ `None`ï¼Ÿ**

- `None` å‘Šè¯‰ LangGraphï¼š"ä¸æ·»åŠ æ–°è¾“å…¥ï¼Œä»ä¸Šæ¬¡æš‚åœçš„åœ°æ–¹ç»§ç»­"
- å›¾ä¼šä» checkpoint åŠ è½½çŠ¶æ€
- ä» `state.next` æŒ‡å®šçš„èŠ‚ç‚¹ï¼ˆ`tools`ï¼‰ç»§ç»­æ‰§è¡Œ

**è¾“å‡ºï¼š**
```
================================== Ai Message ==================================
Tool Calls:
  multiply (call_oFkGpnO8CuwW9A1rk49nqBpY)
 Call ID: call_oFkGpnO8CuwW9A1rk49nqBpY
  Args:
    a: 2
    b: 3

================================= Tool Message =================================
Name: multiply

6

================================== Ai Message ==================================
The result of multiplying 2 and 3 is 6.
```

**æ‰§è¡Œæµç¨‹ï¼š**
1. **é‡æ–°å‘å‡ºå½“å‰çŠ¶æ€**ï¼šé¦–å…ˆè¿”å›ä¸Šæ¬¡æš‚åœæ—¶çš„ AIMessageï¼ˆåŒ…å«å·¥å…·è°ƒç”¨ï¼‰
2. **æ‰§è¡Œ tools èŠ‚ç‚¹**ï¼šè°ƒç”¨ `multiply(2, 3)`ï¼Œè¿”å› `6`
3. **å›åˆ° assistant èŠ‚ç‚¹**ï¼šç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ
4. **ç»“æŸ**ï¼šæ²¡æœ‰æ›´å¤šå·¥å…·è°ƒç”¨ï¼Œæµç¨‹ç»“æŸ

**é‡è¦æç¤ºï¼šä¸ºä»€ä¹ˆä¼šé‡æ–°å‘å‡º AIMessageï¼Ÿ**

LangGraph çš„è®¾è®¡å“²å­¦ï¼š
> "When we invoke the graph with `None`, it will re-emit the current state, which contains the `AIMessage` with tool call."

è¿™æ ·åšçš„å¥½å¤„ï¼š
- **å®Œæ•´æ€§**ï¼šç¡®ä¿ç”¨æˆ·çœ‹åˆ°å®Œæ•´çš„æ‰§è¡Œæµç¨‹
- **é€æ˜æ€§**ï¼šæ¸…æ¥šåœ°çœ‹åˆ°ä»å“ªé‡Œæ¢å¤çš„
- **è°ƒè¯•å‹å¥½**ï¼šä¾¿äºç†è§£å›¾çš„æ‰§è¡ŒçŠ¶æ€

---

### 8. å®Œæ•´çš„ç”¨æˆ·å®¡æ‰¹æµç¨‹

```python
# Input
initial_input = {"messages": HumanMessage(content="Multiply 2 and 3")}

# Thread
thread = {"configurable": {"thread_id": "2"}}

# Run the graph until the first interruption
for event in graph.stream(initial_input, thread, stream_mode="values"):
    event['messages'][-1].pretty_print()

# Get user feedback
user_approval = input("Do you want to call the tool? (yes/no): ")

# Check approval
if user_approval.lower() == "yes":
    # If approved, continue the graph execution
    for event in graph.stream(None, thread, stream_mode="values"):
        event['messages'][-1].pretty_print()
else:
    print("Operation cancelled by user.")
```

**æµç¨‹æ€»ç»“ï¼š**

```
1. æ‰§è¡Œå›¾ â†’ è§¦å‘ breakpoint
2. æ˜¾ç¤ºå·¥å…·è°ƒç”¨ä¿¡æ¯
3. è¯¢é—®ç”¨æˆ·æ‰¹å‡† â†’ input("yes/no")
4. å¦‚æœæ‰¹å‡† â†’ stream(None, thread) ç»§ç»­æ‰§è¡Œ
5. å¦‚æœæ‹’ç» â†’ å–æ¶ˆæ“ä½œ
```

**å®é™…è¾“å‡ºç¤ºä¾‹ï¼š**
```
================================ Human Message =================================
Multiply 2 and 3

================================== Ai Message ==================================
Tool Calls:
  multiply (call_tpHvTmsHSjSpYnymzdx553SU)
 Call ID: call_tpHvTmsHSjSpYnymzdx553SU
  Args:
    a: 2
    b: 3

Do you want to call the tool? (yes/no): yes

================================== Ai Message ==================================
Tool Calls:
  multiply (call_tpHvTmsHSjSpYnymzdx553SU)
 Call ID: call_tpHvTmsHSjSpYnymzdx553SU
  Args:
    a: 2
    b: 3

================================= Tool Message =================================
Name: multiply

6

================================== Ai Message ==================================
The result of multiplying 2 and 3 is 6.
```

---

## ğŸŒ ä½¿ç”¨ LangGraph API å®ç° Breakpoints

æ•™ç¨‹çš„ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†å¦‚ä½•åœ¨ **LangGraph Studio** ä¸­ä½¿ç”¨ Breakpointsã€‚

### LangGraph Studio æœ¬åœ°å¼€å‘æœåŠ¡å™¨

**å¯åŠ¨æ–¹å¼ï¼š**

åœ¨ `/module-3/studio` ç›®å½•ä¸‹è¿è¡Œï¼š

```bash
langgraph dev
```

**è¾“å‡ºï¼š**
```
- ğŸš€ API: http://127.0.0.1:2024
- ğŸ¨ Studio UI: https://smith.langchain.com/studio/?baseUrl=http://127.0.0.1:2024
- ğŸ“š API Docs: http://127.0.0.1:2024/docs
```

**è®¿é—®ï¼š**
åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ `https://smith.langchain.com/studio/?baseUrl=http://127.0.0.1:2024`

---

### ä½¿ç”¨ SDK è¿æ¥åˆ° API

```python
from langgraph_sdk import get_client

client = get_client(url="http://127.0.0.1:2024")
```

**LangGraph SDK çŸ¥è¯†ç‚¹ï¼š**

LangGraph SDK æä¾›äº†å®Œæ•´çš„ API å®¢æˆ·ç«¯ï¼Œç”¨äºï¼š
- **åˆ›å»º threads**ï¼š`client.threads.create()`
- **è¿è¡Œå›¾**ï¼š`client.runs.stream()`
- **è·å–çŠ¶æ€**ï¼š`client.threads.get_state()`
- **æ›´æ–°çŠ¶æ€**ï¼š`client.threads.update_state()`

---

### API æ–¹å¼æ‰§è¡Œå¸¦ Breakpoint çš„å›¾

```python
initial_input = {"messages": HumanMessage(content="Multiply 2 and 3")}
thread = await client.threads.create()

async for chunk in client.runs.stream(
    thread["thread_id"],
    assistant_id="agent",
    input=initial_input,
    stream_mode="values",
    interrupt_before=["tools"],
):
    print(f"Receiving new event of type: {chunk.event}...")
    messages = chunk.data.get('messages', [])
    if messages:
        print(messages[-1])
    print("-" * 50)
```

**å…³é”®ç‚¹ï¼š**

#### (1) interrupt_before å‚æ•°

```python
async for chunk in client.runs.stream(
    thread["thread_id"],
    assistant_id="agent",
    input=initial_input,
    stream_mode="values",
    interrupt_before=["tools"],  # â† åŠ¨æ€æŒ‡å®š breakpoint
):
```

**ä¸¤ç§æ–¹å¼å¯¹æ¯”ï¼š**

| æ–¹å¼ | è®¾ç½®ä½ç½® | çµæ´»æ€§ |
|------|---------|-------|
| **ç¼–è¯‘æ—¶** | `graph.compile(interrupt_before=["tools"])` | å›ºå®šï¼Œé€‚åˆå§‹ç»ˆéœ€è¦ä¸­æ–­çš„åœºæ™¯ |
| **è¿è¡Œæ—¶** | `client.runs.stream(..., interrupt_before=["tools"])` | çµæ´»ï¼Œå¯ä»¥æ ¹æ®è¯·æ±‚åŠ¨æ€å†³å®š |

**æœ€ä½³å®è·µï¼š**
- **å¼€å‘/æµ‹è¯•**ï¼šä½¿ç”¨ç¼–è¯‘æ—¶è®¾ç½®
- **ç”Ÿäº§ç¯å¢ƒ**ï¼šä½¿ç”¨è¿è¡Œæ—¶è®¾ç½®ï¼Œå…è®¸ä¸åŒç”¨æˆ·æœ‰ä¸åŒçš„ä¸­æ–­ç­–ç•¥

#### (2) async for æµå¼è¾“å‡º

```python
async for chunk in client.runs.stream(...):
    print(chunk)
```

**Python çŸ¥è¯†ç‚¹ï¼šå¼‚æ­¥è¿­ä»£å™¨**

- `async for` ç”¨äºå¼‚æ­¥è¿­ä»£
- é€‚åˆå¤„ç†æµå¼æ•°æ®ï¼ˆå¦‚ LLM è¾“å‡ºã€ç½‘ç»œè¯·æ±‚ï¼‰
- ä¸ `for` çš„åŒºåˆ«ï¼šå¯ä»¥åœ¨ç­‰å¾…æ•°æ®æ—¶ä¸é˜»å¡å…¶ä»–æ“ä½œ

**åŒæ­¥ç‰ˆæœ¬ï¼ˆå¦‚æœéœ€è¦ï¼‰ï¼š**
```python
for chunk in client.runs.stream_sync(...):  # æ³¨æ„æ˜¯ stream_sync
    print(chunk)
```

---

### API æ–¹å¼æ¢å¤æ‰§è¡Œ

```python
async for chunk in client.runs.stream(
    thread["thread_id"],
    "agent",
    input=None,  # â† å…³é”®ï¼šä½¿ç”¨ None
    stream_mode="values",
    interrupt_before=["tools"],
):
    print(f"Receiving new event of type: {chunk.event}...")
    messages = chunk.data.get('messages', [])
    if messages:
        print(messages[-1])
    print("-" * 50)
```

**ä¸æœ¬åœ°ç‰ˆæœ¬å®Œå…¨ä¸€è‡´ï¼š**
- ä½¿ç”¨ `input=None` ä»æ–­ç‚¹æ¢å¤
- å›¾ä¼šä»ä¸Šæ¬¡æš‚åœçš„åœ°æ–¹ç»§ç»­æ‰§è¡Œ

---

## ğŸ“ æ ¸å¿ƒçŸ¥è¯†ç‚¹æ€»ç»“

### LangGraph ç‰¹æœ‰æ¦‚å¿µ

#### 1. Breakpoints æœºåˆ¶

**ç¼–è¯‘æ—¶è®¾ç½®ï¼š**
```python
graph.compile(
    interrupt_before=["node1", "node2"],  # èŠ‚ç‚¹å‰ä¸­æ–­
    interrupt_after=["node3"],            # èŠ‚ç‚¹åä¸­æ–­
    checkpointer=memory                    # å¿…éœ€ï¼šçŠ¶æ€æŒä¹…åŒ–
)
```

**è¿è¡Œæ—¶è®¾ç½®ï¼š**
```python
client.runs.stream(
    thread_id,
    assistant_id,
    input=data,
    interrupt_before=["node1"]  # åŠ¨æ€è®¾ç½®
)
```

#### 2. æ¢å¤æ‰§è¡Œçš„æŠ€å·§

```python
# å…³é”®ï¼šä½¿ç”¨ None ä½œä¸ºè¾“å…¥
graph.stream(None, thread, stream_mode="values")
```

**åŸç†ï¼š**
- ä» checkpoint åŠ è½½çŠ¶æ€
- ä» `state.next` æŒ‡å®šçš„èŠ‚ç‚¹ç»§ç»­
- ä¸æ·»åŠ æ–°çš„è¾“å…¥æ¶ˆæ¯

#### 3. çŠ¶æ€æ£€æŸ¥

```python
state = graph.get_state(thread)

# æ£€æŸ¥æ˜¯å¦åœ¨ breakpoint å¤„
if state.next:
    print(f"Paused before: {state.next}")

# æŸ¥çœ‹å½“å‰çŠ¶æ€
print(state.values)
```

#### 4. Thread å’Œä¼šè¯ç®¡ç†

```python
thread = {"configurable": {"thread_id": "unique-id"}}
```

**æœ€ä½³å®è·µï¼š**
- æ¯ä¸ªç”¨æˆ·ä¼šè¯ä½¿ç”¨å”¯ä¸€çš„ `thread_id`
- ä½¿ç”¨ UUID æˆ–æ—¶é—´æˆ³ç”Ÿæˆ ID
- åœ¨æ•°æ®åº“ä¸­å…³è” `thread_id` å’Œç”¨æˆ·ä¿¡æ¯

```python
import uuid

# ä¸ºæ¯ä¸ªæ–°ä¼šè¯ç”Ÿæˆå”¯ä¸€ ID
thread_id = str(uuid.uuid4())
thread = {"configurable": {"thread_id": thread_id}}
```

---

### Python ç‰¹æœ‰çŸ¥è¯†ç‚¹

#### 1. å‡½æ•°ç±»å‹æ³¨è§£

```python
def multiply(a: int, b: int) -> int:
    """..."""
    return a * b
```

**ç±»å‹æ³¨è§£çš„ä½œç”¨ï¼š**
- **IDE æ”¯æŒ**ï¼šä»£ç è¡¥å…¨ã€é”™è¯¯æ£€æŸ¥
- **LangChain å·¥å…·**ï¼šè‡ªåŠ¨ç”Ÿæˆå·¥å…· schema
- **æ–‡æ¡£**ï¼šæ¸…æ™°çš„æ¥å£å®šä¹‰

#### 2. Docstring ä¸å·¥å…·é›†æˆ

```python
def multiply(a: int, b: int) -> int:
    """Multiply a and b.  # â† LLM ä¼šè¯»å–è¿™ä¸ªæè¿°

    Args:
        a: first int   # â† LLM ä¼šç†è§£å‚æ•°å«ä¹‰
        b: second int
    """
    return a * b
```

**LangChain å¦‚ä½•ä½¿ç”¨ Docstringï¼š**
```python
tools = [multiply]
llm_with_tools = llm.bind_tools(tools)

# LangChain ä¼šè‡ªåŠ¨å°† docstring è½¬æ¢ä¸ºå·¥å…·æè¿°ï¼š
# {
#   "name": "multiply",
#   "description": "Multiply a and b.",
#   "parameters": {
#     "a": {"type": "integer", "description": "first int"},
#     "b": {"type": "integer", "description": "second int"}
#   }
# }
```

#### 3. åˆ—è¡¨æ¨å¯¼å¼

```python
[sys_msg] + state["messages"]

# ç­‰ä»·äºï¼š
result = [sys_msg]
result.extend(state["messages"])
```

**ç”¨é€”ï¼š** å¿«é€Ÿæ„å»ºæ–°åˆ—è¡¨ï¼Œä¿æŒåŸåˆ—è¡¨ä¸å˜ï¼ˆä¸å¯å˜æ€§ï¼‰

#### 4. å¼‚æ­¥ç¼–ç¨‹åŸºç¡€

```python
# å¼‚æ­¥å‡½æ•°å®šä¹‰
async def my_function():
    result = await some_async_operation()
    return result

# å¼‚æ­¥è¿­ä»£
async for item in async_iterator:
    process(item)

# è¿è¡Œå¼‚æ­¥ä»£ç 
import asyncio
asyncio.run(my_function())
```

**ä½•æ—¶ä½¿ç”¨å¼‚æ­¥ï¼š**
- API è¯·æ±‚ï¼ˆå¦‚ LangGraph APIï¼‰
- æ•°æ®åº“æ“ä½œ
- I/O å¯†é›†å‹ä»»åŠ¡
- éœ€è¦å¹¶å‘å¤„ç†å¤šä¸ªä»»åŠ¡

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½•æ—¶ä½¿ç”¨ Breakpointsï¼Ÿ

âœ… **æ¨èåœºæ™¯ï¼š**

1. **æ•æ„Ÿæ“ä½œå®¡æ‰¹**
   ```python
   # æ”¯ä»˜ã€åˆ é™¤ã€å‘é€é‚®ä»¶ç­‰æ“ä½œå‰
   interrupt_before=["payment_tool", "delete_tool", "email_tool"]
   ```

2. **ç”¨æˆ·ç¡®è®¤**
   ```python
   # é‡è¦å†³ç­–å‰è®©ç”¨æˆ·ç¡®è®¤
   interrupt_before=["book_flight", "submit_order"]
   ```

3. **è°ƒè¯•å’Œå¼€å‘**
   ```python
   # æ£€æŸ¥æ¯ä¸€æ­¥çš„è¾“å‡º
   interrupt_after=["every", "single", "node"]
   ```

4. **å®‰å…¨æ§åˆ¶**
   ```python
   # é˜²æ­¢ Agent æ‰§è¡Œå±é™©æ“ä½œ
   interrupt_before=["system_command", "file_operations"]
   ```

âŒ **ä¸æ¨èåœºæ™¯ï¼š**

- é«˜é¢‘ã€ä½é£é™©æ“ä½œï¼ˆä¼šä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒï¼‰
- å®Œå…¨è‡ªåŠ¨åŒ–çš„åå°ä»»åŠ¡
- éœ€è¦å®æ—¶å“åº”çš„åœºæ™¯

### 2. Breakpoint ä½ç½®é€‰æ‹©

**interrupt_before vs interrupt_after**

| æ—¶æœº | é€‚ç”¨åœºæ™¯ | ç¤ºä¾‹ |
|------|---------|------|
| `interrupt_before` | åœ¨æ‰§è¡Œå‰å®¡æ‰¹ | å·¥å…·è°ƒç”¨å‰ç¡®è®¤ |
| `interrupt_after` | æŸ¥çœ‹æ‰§è¡Œç»“æœ | æ£€æŸ¥ç”Ÿæˆçš„å†…å®¹ |

**ç¤ºä¾‹ï¼š**

```python
# åœºæ™¯ 1ï¼šå®¡æ‰¹å·¥å…·è°ƒç”¨
interrupt_before=["tools"]  # åœ¨å·¥å…·æ‰§è¡Œå‰ä¸­æ–­

# åœºæ™¯ 2ï¼šå®¡æŸ¥ç”Ÿæˆå†…å®¹
interrupt_after=["generate_response"]  # ç”Ÿæˆåä¸­æ–­ï¼Œå…è®¸ç¼–è¾‘

# åœºæ™¯ 3ï¼šç»„åˆä½¿ç”¨
interrupt_before=["risky_operation"]
interrupt_after=["data_processing"]
```

### 3. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

#### æŠ€å·§ 1ï¼šæä¾›æ¸…æ™°çš„ä¸Šä¸‹æ–‡ä¿¡æ¯

```python
for event in graph.stream(initial_input, thread, stream_mode="values"):
    last_msg = event['messages'][-1]

    if isinstance(last_msg, AIMessage) and last_msg.tool_calls:
        # æ˜¾ç¤ºå³å°†æ‰§è¡Œçš„å·¥å…·
        tool = last_msg.tool_calls[0]
        print(f"Agent wants to call: {tool['name']}")
        print(f"With arguments: {tool['args']}")

        # è¯¢é—®ç”¨æˆ·
        approval = input("Approve? (yes/no): ")

        if approval.lower() == "yes":
            # ç»§ç»­æ‰§è¡Œ
            for event in graph.stream(None, thread, stream_mode="values"):
                event['messages'][-1].pretty_print()
        else:
            print("Operation cancelled.")
```

#### æŠ€å·§ 2ï¼šæä¾›æ‰¹å‡†é€‰é¡¹

```python
def get_user_approval(tool_call):
    print(f"\nAgent wants to: {tool_call['name']}({tool_call['args']})")
    print("Options:")
    print("  1. Approve")
    print("  2. Reject")
    print("  3. Edit parameters")

    choice = input("Choose (1/2/3): ")

    if choice == "1":
        return "approve"
    elif choice == "2":
        return "reject"
    elif choice == "3":
        return "edit"
    else:
        return "reject"  # é»˜è®¤æ‹’ç»
```

#### æŠ€å·§ 3ï¼šè¶…æ—¶è‡ªåŠ¨å¤„ç†

```python
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("User approval timeout")

def get_approval_with_timeout(timeout=30):
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)  # 30 ç§’è¶…æ—¶

    try:
        approval = input("Approve? (yes/no): ")
        signal.alarm(0)  # å–æ¶ˆè¶…æ—¶
        return approval.lower() == "yes"
    except TimeoutError:
        print("\nTimeout! Auto-rejecting...")
        return False
```

### 4. é”™è¯¯å¤„ç†

```python
try:
    # æ‰§è¡Œå›¾
    for event in graph.stream(initial_input, thread, stream_mode="values"):
        event['messages'][-1].pretty_print()

    # è·å–ç”¨æˆ·æ‰¹å‡†
    approval = input("Approve? (yes/no): ")

    if approval.lower() == "yes":
        # ç»§ç»­æ‰§è¡Œ
        for event in graph.stream(None, thread, stream_mode="values"):
            event['messages'][-1].pretty_print()
    else:
        print("Operation cancelled by user.")

except KeyboardInterrupt:
    print("\nInterrupted by user. Cleaning up...")
    # æ¸…ç†èµ„æº

except Exception as e:
    print(f"Error: {e}")
    # è®°å½•é”™è¯¯æ—¥å¿—
```

---

## ğŸš€ è¿›é˜¶æŠ€å·§

### 1. æ¡ä»¶æ€§ Breakpoint

æ ¹æ®ä¸åŒæ¡ä»¶å†³å®šæ˜¯å¦ä¸­æ–­ï¼š

```python
def should_interrupt(state: MessagesState) -> bool:
    """æ ¹æ®çŠ¶æ€å†³å®šæ˜¯å¦éœ€è¦äººå·¥å®¡æ‰¹"""
    last_msg = state["messages"][-1]

    if isinstance(last_msg, AIMessage) and last_msg.tool_calls:
        tool_name = last_msg.tool_calls[0]['name']

        # é«˜é£é™©å·¥å…·éœ€è¦å®¡æ‰¹
        high_risk_tools = ["delete", "payment", "send_email"]
        return tool_name in high_risk_tools

    return False

# åœ¨è¿è¡Œæ—¶åŠ¨æ€å†³å®š
if should_interrupt(state):
    # ä½¿ç”¨ breakpoint
    graph_with_interrupt = graph.compile(interrupt_before=["tools"], checkpointer=memory)
else:
    # ä¸ä½¿ç”¨ breakpoint
    graph_with_interrupt = graph.compile(checkpointer=memory)
```

**æ³¨æ„ï¼š** LangGraph æœ¬èº«ä¸æ”¯æŒåŠ¨æ€æ¡ä»¶ breakpointï¼Œéœ€è¦åœ¨åº”ç”¨å±‚å®ç°ã€‚

### 2. å¤šçº§å®¡æ‰¹

å¯¹äºå…³é”®æ“ä½œï¼Œå¯ä»¥å®ç°å¤šçº§å®¡æ‰¹ï¼š

```python
# Level 1: è‡ªåŠ¨æ£€æŸ¥
def auto_check(state):
    """è‡ªåŠ¨å®‰å…¨æ£€æŸ¥"""
    if not is_safe(state):
        return "reject"
    return "need_human_approval"

# Level 2: äººå·¥å®¡æ‰¹
def human_approval(state):
    """äººå·¥å®¡æ‰¹"""
    approval = input("Level 1 passed. Final approval? (yes/no): ")
    return approval.lower() == "yes"

# åœ¨å›¾ä¸­å®ç°
builder.add_conditional_edges(
    "auto_check",
    auto_check,
    {
        "reject": END,
        "need_human_approval": "human_approval_node"
    }
)
```

### 3. å®¡æ‰¹å†å²è®°å½•

è®°å½•æ‰€æœ‰å®¡æ‰¹å†³ç­–ï¼š

```python
from datetime import datetime

approval_log = []

def log_approval(tool_call, approved, user_id):
    """è®°å½•å®¡æ‰¹å†å²"""
    approval_log.append({
        "timestamp": datetime.now().isoformat(),
        "tool": tool_call['name'],
        "args": tool_call['args'],
        "approved": approved,
        "user": user_id
    })

# ä½¿ç”¨
approval = input("Approve? (yes/no): ")
approved = approval.lower() == "yes"
log_approval(tool_call, approved, user_id="user123")

# æŸ¥çœ‹å†å²
for log in approval_log:
    print(f"{log['timestamp']}: {log['tool']} - {'âœ“' if log['approved'] else 'âœ—'}")
```

### 4. ä¸ UI é›†æˆ

åœ¨ Web åº”ç”¨ä¸­ä½¿ç”¨ Breakpointsï¼š

```python
# FastAPI ç¤ºä¾‹
from fastapi import FastAPI, WebSocket

app = FastAPI()

@app.websocket("/ws/{thread_id}")
async def websocket_endpoint(websocket: WebSocket, thread_id: str):
    await websocket.accept()

    # å¯åŠ¨å›¾æ‰§è¡Œ
    thread = {"configurable": {"thread_id": thread_id}}

    for event in graph.stream(initial_input, thread, stream_mode="values"):
        # å‘é€æ¶ˆæ¯åˆ°å‰ç«¯
        await websocket.send_json({
            "type": "message",
            "data": event['messages'][-1]
        })

    # è§¦å‘ breakpointï¼Œè¯·æ±‚æ‰¹å‡†
    await websocket.send_json({
        "type": "approval_required",
        "tool": tool_call
    })

    # ç­‰å¾…å‰ç«¯å“åº”
    approval = await websocket.receive_json()

    if approval["approved"]:
        # ç»§ç»­æ‰§è¡Œ
        for event in graph.stream(None, thread, stream_mode="values"):
            await websocket.send_json({
                "type": "message",
                "data": event['messages'][-1]
            })
```

---

## ğŸ¯ å®é™…åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹ 1ï¼šæ™ºèƒ½å®¢æœå·¥å•ç³»ç»Ÿ

**éœ€æ±‚ï¼š** Agent å¯ä»¥æŸ¥è¯¢å·¥å•ã€åˆ›å»ºå·¥å•ï¼Œä½†æäº¤å·¥å•éœ€è¦äººå·¥ç¡®è®¤ã€‚

```python
# å·¥å…·å®šä¹‰
def query_ticket(ticket_id: str) -> dict:
    """æŸ¥è¯¢å·¥å•ä¿¡æ¯ï¼ˆä½é£é™©ï¼Œæ— éœ€å®¡æ‰¹ï¼‰"""
    return {"ticket_id": ticket_id, "status": "open"}

def create_ticket(title: str, description: str) -> dict:
    """åˆ›å»ºå·¥å•ï¼ˆé«˜é£é™©ï¼Œéœ€è¦å®¡æ‰¹ï¼‰"""
    return {"ticket_id": "T123", "title": title}

tools = [query_ticket, create_ticket]

# åªå¯¹ create_ticket è®¾ç½® breakpoint
# å®ç°æ–¹å¼ï¼šä½¿ç”¨è‡ªå®šä¹‰èŠ‚ç‚¹
def tools_with_approval(state: MessagesState):
    """å¸¦å®¡æ‰¹çš„å·¥å…·èŠ‚ç‚¹"""
    tool_call = state["messages"][-1].tool_calls[0]

    # é«˜é£é™©å·¥å…·éœ€è¦å®¡æ‰¹
    if tool_call['name'] == 'create_ticket':
        # è§¦å‘ breakpoint é€»è¾‘
        return {"needs_approval": True}
    else:
        # ç›´æ¥æ‰§è¡Œ
        result = execute_tool(tool_call)
        return {"messages": [ToolMessage(content=result, tool_call_id=tool_call['id'])]}
```

### æ¡ˆä¾‹ 2ï¼šä»£ç éƒ¨ç½²åŠ©æ‰‹

**éœ€æ±‚ï¼š** Agent å¯ä»¥æ£€æŸ¥ä»£ç ã€è¿è¡Œæµ‹è¯•ï¼Œä½†éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒéœ€è¦äººå·¥æ‰¹å‡†ã€‚

```python
# æ„å»ºå›¾
builder = StateGraph(MessagesState)
builder.add_node("assistant", assistant)
builder.add_node("run_tests", run_tests_node)
builder.add_node("deploy", deploy_node)  # éƒ¨ç½²èŠ‚ç‚¹

# åªåœ¨éƒ¨ç½²å‰ä¸­æ–­
graph = builder.compile(
    interrupt_before=["deploy"],  # åªåœ¨éƒ¨ç½²å‰éœ€è¦æ‰¹å‡†
    checkpointer=memory
)

# æ‰§è¡Œ
for event in graph.stream({"messages": [HumanMessage("Deploy to production")]}, thread):
    print(event)

# æ£€æŸ¥å³å°†éƒ¨ç½²çš„ç‰ˆæœ¬
state = graph.get_state(thread)
print(f"About to deploy version: {state.values['version']}")

# è·å–æ‰¹å‡†
approval = input("Deploy to production? (yes/no): ")
if approval.lower() == "yes":
    for event in graph.stream(None, thread):
        print(event)
```

### æ¡ˆä¾‹ 3ï¼šæ•°æ®åˆ†æåŠ©æ‰‹

**éœ€æ±‚ï¼š** Agent å¯ä»¥æŸ¥è¯¢æ•°æ®ã€ç”ŸæˆæŠ¥å‘Šï¼Œä½†åˆ é™¤æ•°æ®éœ€è¦äººå·¥ç¡®è®¤ã€‚

```python
def analyze_data(query: str) -> str:
    """åˆ†ææ•°æ®ï¼ˆå®‰å…¨æ“ä½œï¼‰"""
    return "Analysis result..."

def delete_data(table: str, condition: str) -> str:
    """åˆ é™¤æ•°æ®ï¼ˆå±é™©æ“ä½œï¼‰"""
    return f"Deleted rows from {table}"

# ä½¿ç”¨ interrupt_before
graph = builder.compile(
    interrupt_before=["delete_data_node"],
    checkpointer=memory
)

# æ‰§è¡Œæ—¶
for event in graph.stream(initial_input, thread):
    last_msg = event['messages'][-1]

    if isinstance(last_msg, AIMessage) and last_msg.tool_calls:
        tool = last_msg.tool_calls[0]

        if tool['name'] == 'delete_data':
            # æ˜¾ç¤ºå³å°†åˆ é™¤çš„æ•°æ®
            print(f"âš ï¸  WARNING: About to delete data!")
            print(f"   Table: {tool['args']['table']}")
            print(f"   Condition: {tool['args']['condition']}")

            # éœ€è¦è¾“å…¥ç¡®è®¤æ–‡æœ¬
            confirmation = input("Type 'DELETE' to confirm: ")

            if confirmation == "DELETE":
                for event in graph.stream(None, thread):
                    print(event)
            else:
                print("Operation cancelled.")
```

---

## ğŸ“Š Breakpoints vs å…¶ä»–æ§åˆ¶æœºåˆ¶

### å¯¹æ¯”è¡¨

| ç‰¹æ€§ | Breakpoints | æ¡ä»¶è¾¹ | äººå·¥èŠ‚ç‚¹ |
|------|------------|--------|---------|
| **æš‚åœæ‰§è¡Œ** | âœ… è‡ªåŠ¨ | âŒ ä¸æš‚åœ | âœ… æ‰‹åŠ¨ |
| **ç»§ç»­æ‰§è¡Œ** | `stream(None)` | è‡ªåŠ¨æµè½¬ | æ˜¾å¼è°ƒç”¨ |
| **ç”¨æˆ·äº¤äº’** | åœ¨å›¾å¤–éƒ¨ | åœ¨å›¾å†…éƒ¨ | åœ¨èŠ‚ç‚¹å†…éƒ¨ |
| **çµæ´»æ€§** | é«˜ | ä¸­ | ä½ |
| **å¤æ‚åº¦** | ä½ | ä¸­ | é«˜ |
| **é€‚ç”¨åœºæ™¯** | å·¥å…·å®¡æ‰¹ã€è°ƒè¯• | è·¯ç”±å†³ç­– | å¤æ‚äº¤äº’ |

### ä½¿ç”¨å»ºè®®

**ä½¿ç”¨ Breakpointsï¼š**
```python
# ç®€å•çš„æ‰¹å‡†/æ‹’ç»åœºæ™¯
graph.compile(interrupt_before=["tools"], checkpointer=memory)
```

**ä½¿ç”¨æ¡ä»¶è¾¹ï¼š**
```python
# åŸºäºçŠ¶æ€çš„è‡ªåŠ¨è·¯ç”±
def should_continue(state):
    if state["ready"]:
        return "continue"
    return "wait"

builder.add_conditional_edges("check", should_continue, {"continue": "next", "wait": END})
```

**ä½¿ç”¨äººå·¥èŠ‚ç‚¹ï¼š**
```python
# éœ€è¦åœ¨å›¾å†…éƒ¨å¤„ç†ç”¨æˆ·è¾“å…¥
def human_input_node(state):
    user_input = get_user_input()  # è‡ªå®šä¹‰è¾“å…¥é€»è¾‘
    return {"user_feedback": user_input}

builder.add_node("human_input", human_input_node)
```

---

## ğŸ” å¸¸è§é—®é¢˜

### Q1: Breakpoint è§¦å‘åï¼Œå¯ä»¥å–æ¶ˆæ‰§è¡Œå—ï¼Ÿ

**æ˜¯çš„ï¼** åªéœ€ä¸è°ƒç”¨ `stream(None)`ï¼š

```python
# è§¦å‘ breakpoint
for event in graph.stream(initial_input, thread):
    print(event)

# è·å–æ‰¹å‡†
approval = input("Continue? (yes/no): ")

if approval.lower() == "yes":
    # ç»§ç»­æ‰§è¡Œ
    for event in graph.stream(None, thread):
        print(event)
else:
    # ä¸è°ƒç”¨ stream(None)ï¼Œæ‰§è¡Œå°±åœæ­¢äº†
    print("Execution cancelled.")
```

**çŠ¶æ€ï¼š** å›¾çš„çŠ¶æ€ä»ç„¶ä¿å­˜åœ¨ checkpoint ä¸­ï¼Œå¯ä»¥ç¨åæ¢å¤ã€‚

### Q2: å¯ä»¥ä¿®æ”¹çŠ¶æ€åå†ç»§ç»­æ‰§è¡Œå—ï¼Ÿ

**å¯ä»¥ï¼** ä½¿ç”¨ `update_state()`ï¼š

```python
# è§¦å‘ breakpoint
for event in graph.stream(initial_input, thread):
    print(event)

# ä¿®æ”¹çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œä¿®æ”¹å·¥å…·å‚æ•°ï¼‰
state = graph.get_state(thread)
modified_messages = state.values["messages"].copy()

# ä¿®æ”¹æœ€åä¸€æ¡ AIMessage çš„å·¥å…·è°ƒç”¨å‚æ•°
last_msg = modified_messages[-1]
last_msg.tool_calls[0]['args']['a'] = 10  # ä¿®æ”¹å‚æ•°

# æ›´æ–°çŠ¶æ€
graph.update_state(thread, {"messages": modified_messages})

# ç»§ç»­æ‰§è¡Œï¼ˆä½¿ç”¨ä¿®æ”¹åçš„çŠ¶æ€ï¼‰
for event in graph.stream(None, thread):
    print(event)
```

**æ³¨æ„ï¼š** è¿™æ˜¯ **Editingï¼ˆç¼–è¾‘ï¼‰** åœºæ™¯ï¼Œåç»­æ•™ç¨‹ä¼šè¯¦ç»†è®²è§£ã€‚

### Q3: å¯ä»¥åœ¨åŒä¸€ä¸ªå›¾ä¸­è®¾ç½®å¤šä¸ª Breakpoints å—ï¼Ÿ

**å¯ä»¥ï¼**

```python
graph = builder.compile(
    interrupt_before=["tools", "generate_report", "send_email"],
    checkpointer=memory
)
```

**æ‰§è¡Œæµç¨‹ï¼š**
- æ¯æ¬¡é‡åˆ°è¿™äº›èŠ‚ç‚¹æ—¶ï¼Œéƒ½ä¼šè§¦å‘ breakpoint
- éœ€è¦å¤šæ¬¡è°ƒç”¨ `stream(None)` æ‰èƒ½å®Œæˆæ•´ä¸ªæµç¨‹

**ç¤ºä¾‹ï¼š**
```python
# ç¬¬ä¸€ä¸ª breakpointï¼ˆtools å‰ï¼‰
for event in graph.stream(initial_input, thread):
    print(event)

approval1 = input("Approve tool call? (yes/no): ")
if approval1.lower() == "yes":
    # ç¬¬äºŒä¸ª breakpointï¼ˆgenerate_report å‰ï¼‰
    for event in graph.stream(None, thread):
        print(event)

    approval2 = input("Approve report generation? (yes/no): ")
    if approval2.lower() == "yes":
        # ç»§ç»­æ‰§è¡Œ
        for event in graph.stream(None, thread):
            print(event)
```

### Q4: Breakpoint å’Œ streaming å…¼å®¹å—ï¼Ÿ

**å®Œå…¨å…¼å®¹ï¼**

```python
# æµå¼è¾“å‡º + Breakpoint
for event in graph.stream(initial_input, thread, stream_mode="values"):
    # å®æ—¶æ˜¾ç¤ºæ¯ä¸€æ­¥çš„è¾“å‡º
    event['messages'][-1].pretty_print()

# è§¦å‘ breakpoint åï¼Œç»§ç»­æµå¼è¾“å‡º
for event in graph.stream(None, thread, stream_mode="values"):
    event['messages'][-1].pretty_print()
```

### Q5: å¦‚ä½•åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ Breakpointsï¼Ÿ

**æ¨èæ¶æ„ï¼š**

```
ç”¨æˆ·è¯·æ±‚
   â†“
Web Server (FastAPI/Flask)
   â†“
LangGraph (with breakpoint)
   â†“
è§¦å‘ breakpoint
   â†“
ä¿å­˜çŠ¶æ€åˆ°æ•°æ®åº“
   â†“
è¿”å›å®¡æ‰¹è¯·æ±‚ç»™ç”¨æˆ·
   â†“
ç”¨æˆ·æ‰¹å‡†
   â†“
ä»æ•°æ®åº“åŠ è½½çŠ¶æ€
   â†“
ç»§ç»­æ‰§è¡Œ (stream with None)
   â†“
è¿”å›ç»“æœ
```

**å…³é”®ç‚¹ï¼š**
1. **å¼‚æ­¥å¤„ç†**ï¼šä¸è¦é˜»å¡ Web è¯·æ±‚
2. **æŒä¹…åŒ–**ï¼šä½¿ç”¨æ•°æ®åº“ checkpoint (PostgreSQL, Redis)
3. **é€šçŸ¥æœºåˆ¶**ï¼šé€šè¿‡ WebSocket æˆ–è½®è¯¢é€šçŸ¥ç”¨æˆ·
4. **è¶…æ—¶å¤„ç†**ï¼šè®¾ç½®å®¡æ‰¹è¶…æ—¶è‡ªåŠ¨æ‹’ç»

**ç¤ºä¾‹ä»£ç ï¼š**
```python
from langgraph.checkpoint.postgres import PostgresSaver

# ä½¿ç”¨ PostgreSQL æŒä¹…åŒ–
checkpointer = PostgresSaver(connection_string="postgresql://...")

graph = builder.compile(
    interrupt_before=["tools"],
    checkpointer=checkpointer  # ç”Ÿäº§çº§æŒä¹…åŒ–
)

# å¼‚æ­¥æ‰§è¡Œ
@app.post("/execute")
async def execute_graph(request: Request):
    thread_id = str(uuid.uuid4())
    thread = {"configurable": {"thread_id": thread_id}}

    # åå°æ‰§è¡Œ
    asyncio.create_task(run_graph(thread))

    # ç«‹å³è¿”å› thread_id
    return {"thread_id": thread_id, "status": "started"}

@app.post("/approve/{thread_id}")
async def approve(thread_id: str):
    thread = {"configurable": {"thread_id": thread_id}}

    # ç»§ç»­æ‰§è¡Œ
    for event in graph.stream(None, thread):
        # å¤„ç†ç»“æœ
        pass

    return {"status": "completed"}
```

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [LangGraph Breakpoints å®˜æ–¹æ–‡æ¡£](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/breakpoints/)
- [LangGraph Human-in-the-Loop æŒ‡å—](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/)
- [LangGraph Checkpointing](https://langchain-ai.github.io/langgraph/concepts/persistence/)
- [LangGraph Studio æ–‡æ¡£](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/)

---

## ğŸ‰ æ€»ç»“

Breakpoints æ˜¯ LangGraph å®ç° Human-in-the-Loop çš„åŸºç¡€å·¥å…·ï¼š

1. **ç®€å•æ˜“ç”¨**ï¼šåªéœ€åœ¨ `compile()` æ—¶æ·»åŠ  `interrupt_before/after` å‚æ•°
2. **çµæ´»æ§åˆ¶**ï¼šå¯ä»¥åœ¨ç¼–è¯‘æ—¶æˆ–è¿è¡Œæ—¶è®¾ç½® breakpoint
3. **æ— ç¼æ¢å¤**ï¼šä½¿ç”¨ `stream(None)` è½»æ¾æ¢å¤æ‰§è¡Œ
4. **çŠ¶æ€æŒä¹…åŒ–**ï¼šä¾èµ– checkpointerï¼Œæ”¯æŒé•¿æ—¶é—´å¼‚æ­¥å®¡æ‰¹

**æ ¸å¿ƒæŠ€å·§ï¼š**
- `interrupt_before=["node"]` åœ¨èŠ‚ç‚¹å‰æš‚åœ
- `stream(None, thread)` ä»æ–­ç‚¹ç»§ç»­
- `get_state(thread)` æ£€æŸ¥æš‚åœçŠ¶æ€
- é…åˆ checkpointer å®ç°ç”Ÿäº§çº§åº”ç”¨

é€šè¿‡ Breakpointsï¼Œæˆ‘ä»¬å¯ä»¥æ„å»º**å¯æ§ã€å¯ä¿¡ã€å®‰å…¨**çš„ AI åº”ç”¨ï¼Œç¡®ä¿å…³é”®æ“ä½œå§‹ç»ˆåœ¨äººç±»ç›‘ç£ä¸‹æ‰§è¡Œï¼
