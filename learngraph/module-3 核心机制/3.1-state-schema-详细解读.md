# LangGraph State Schema è¯¦ç»†è§£è¯»
>  ç½‘ç«™ä½¿ç”¨è¯´æ˜
> - æœ¬ç½‘ç«™å¯ä»¥å…ç™»é™†è¿è¡Œ Python ä»£ç 
> - Python ä»£ç å¯ä»¥ç¼–è¾‘å¹¶ä¸´æ—¶ä¿å­˜ï¼Œä½†ä¸ä¼šæ°¸ä¹…ä¿å­˜ï¼Œç½‘é¡µåˆ·æ–°åä¼šè‡ªåŠ¨è¿˜åŸ
> - å¯¹ç½‘ç«™çš„ä½¿ç”¨æœ‰ä»»ä½•é—®é¢˜ï¼Œå¯ä»¥åˆ° [é—®é¢˜åé¦ˆ](http://localhost:5173/feedback.html) ï¼ˆæŒ‰é’®åœ¨æ¯ä¸ªé¡µé¢çš„å³ä¸‹è§’ï¼‰å…ç™»å½•è¿›è¡Œè¯„è®º
> - è¿è¡Œ `LangGraph/LangChain`ä»£ç ï¼Œéœ€è¦ç”¨æˆ·è¾“å…¥è‡ªå·±çš„ [API Key](http://localhost:5173/python-run.html)
> - é‡è¦å£°æ˜ï¼šæœ¬ç½‘ç«™ä¸ä¼šä¿å­˜ç”¨æˆ·çš„ API Key æ•°æ®ï¼Œè¯·æ”¾å¿ƒè¾“å…¥

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è§£è¯» LangGraph ä¸­çš„ **State Schemaï¼ˆçŠ¶æ€æ¨¡å¼ï¼‰**ã€‚çŠ¶æ€æ˜¯ LangGraph çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒå®šä¹‰äº†å›¾ä¸­æ•°æ®çš„ç»“æ„å’Œç±»å‹ã€‚ç†è§£çŠ¶æ€æ¨¡å¼æ˜¯æŒæ¡ LangGraph çš„å…³é”®ä¸€æ­¥ã€‚

---

## ğŸ“š æœ¯è¯­è¡¨

| æœ¯è¯­åç§° | LangGraph å®šä¹‰å’Œè§£è¯» | Python å®šä¹‰å’Œè¯´æ˜ | é‡è¦ç¨‹åº¦ |
|---------|---------------------|------------------|---------|
| **State Schema** | LangGraph ä¸­å®šä¹‰å›¾æ•°æ®ç»“æ„å’Œç±»å‹çš„æ¨¡å¼ï¼Œå†³å®šèŠ‚ç‚¹é—´å¦‚ä½•ä¼ é€’å’Œæ›´æ–°æ•°æ® | å¯ä»¥ç”¨ TypedDictã€Dataclass æˆ– Pydantic BaseModel å®šä¹‰çš„æ•°æ®ç»“æ„ | â­â­â­â­â­ |
| **TypedDict** | LangGraph æœ€å¸¸ç”¨çš„çŠ¶æ€å®šä¹‰æ–¹å¼ï¼Œæä¾›ç±»å‹æç¤ºä½†æ— è¿è¡Œæ—¶éªŒè¯ | Python æ ‡å‡†åº“ç±»å‹ï¼Œä¸ºå­—å…¸æ·»åŠ ç±»å‹æ³¨è§£ï¼Œè®¿é—®é€šè¿‡ `state["key"]` | â­â­â­â­â­ |
| **Dataclass** | LangGraph çŠ¶æ€å®šä¹‰çš„ç¬¬äºŒç§æ–¹å¼ï¼Œæ”¯æŒé»˜è®¤å€¼å’Œæ–¹æ³• | Python 3.7+ çš„ `@dataclass` è£…é¥°å™¨ï¼Œè®¿é—®é€šè¿‡ `state.key` | â­â­â­â­ |
| **Pydantic BaseModel** | LangGraph çŠ¶æ€å®šä¹‰çš„ç¬¬ä¸‰ç§æ–¹å¼ï¼Œæä¾›è¿è¡Œæ—¶éªŒè¯å’Œå¤æ‚æ ¡éªŒ | ç¬¬ä¸‰æ–¹åº“ Pydantic çš„æ ¸å¿ƒç±»ï¼Œè‡ªåŠ¨è¿›è¡Œæ•°æ®éªŒè¯å’Œç±»å‹è½¬æ¢ | â­â­â­â­ |
| **Channel** | LangGraph ä¸­ State çš„æ¯ä¸ªå­—æ®µéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹é€šé“ï¼ŒèŠ‚ç‚¹å¯ä»¥è¯»å†™ä»»ä½•é€šé“ | çŠ¶æ€å­—å…¸ä¸­çš„é”®å€¼å¯¹ï¼Œå¤šä¸ªèŠ‚ç‚¹å¯ä»¥ç‹¬ç«‹æ›´æ–°ä¸åŒçš„é€šé“ | â­â­â­â­â­ |
| **Literal** | é™å®šå­—æ®µå€¼åªèƒ½æ˜¯æŒ‡å®šçš„å­—é¢é‡ä¹‹ä¸€ï¼Œæä¾›ç±»å‹å®‰å…¨ | Python `typing` æ¨¡å—çš„ç±»å‹ï¼Œå¦‚ `Literal["happy", "sad"]` | â­â­â­â­ |
| **Annotated** | ä¸ºç±»å‹æ·»åŠ å…ƒæ•°æ®çš„ Python ç±»å‹æç¤ºå·¥å…·ï¼ŒLangGraph ç”¨äºæŒ‡å®š Reducer | Python `typing` çš„æ³›å‹ç±»å‹ï¼Œæ ¼å¼ä¸º `Annotated[ç±»å‹, å…ƒæ•°æ®]` | â­â­â­â­â­ |
| **StateGraph** | LangGraph çš„æ ¸å¿ƒå›¾ç±»ï¼Œæ¥å— State Schema ä½œä¸ºå‚æ•°æ¥åˆ›å»ºçŠ¶æ€åŒ–çš„å›¾ | æ„é€ æ—¶ä¼ å…¥çŠ¶æ€ç±»ï¼š`StateGraph(MyState)` | â­â­â­â­â­ |
| **field_validator** | Pydantic è£…é¥°å™¨ï¼Œç”¨äºä¸º BaseModel å­—æ®µæ·»åŠ è‡ªå®šä¹‰éªŒè¯é€»è¾‘ | è£…é¥°å™¨å‡½æ•°ï¼Œåœ¨å­—æ®µèµ‹å€¼æ—¶è‡ªåŠ¨æ‰§è¡ŒéªŒè¯ï¼Œå¤±è´¥æŠ›å‡º ValidationError | â­â­â­ |
| **partial update** | LangGraph èŠ‚ç‚¹å¯ä»¥åªè¿”å›éƒ¨åˆ†å­—æ®µï¼Œæœªè¿”å›çš„å­—æ®µä¿æŒä¸å˜ | èŠ‚ç‚¹è¿”å›å­—å…¸ä¼šä¸ç°æœ‰çŠ¶æ€åˆå¹¶ï¼Œè€Œä¸æ˜¯å®Œå…¨è¦†ç›– | â­â­â­â­â­ |

---

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ï¼š
- ä»€ä¹ˆæ˜¯ State Schema
- ä¸‰ç§å®šä¹‰çŠ¶æ€çš„æ–¹å¼ï¼ˆTypedDictã€Dataclassã€Pydanticï¼‰
- æ¯ç§æ–¹å¼çš„ä¼˜ç¼ºç‚¹å’Œé€‚ç”¨åœºæ™¯
- å®æˆ˜ä»£ç è¯¦è§£

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### ä»€ä¹ˆæ˜¯ State Schemaï¼Ÿ

åœ¨ LangGraph ä¸­ï¼Œ**State Schema** å®šä¹‰äº†ï¼š
1. **æ•°æ®ç»“æ„**ï¼šå›¾ä¸­å­˜å‚¨å“ªäº›æ•°æ®
2. **æ•°æ®ç±»å‹**ï¼šæ¯ä¸ªå­—æ®µçš„ç±»å‹æ˜¯ä»€ä¹ˆ
3. **é€šä¿¡åè®®**ï¼šèŠ‚ç‚¹ä¹‹é—´å¦‚ä½•ä¼ é€’å’Œæ›´æ–°æ•°æ®

å¯ä»¥æŠŠ State æƒ³è±¡æˆä¸€ä¸ª**å…±äº«çš„æ•°æ®å®¹å™¨**ï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½å¯ä»¥è¯»å–å’Œæ›´æ–°å®ƒã€‚

### æ ¸å¿ƒç‰¹æ€§

#### 1. Channelï¼ˆé€šé“ï¼‰æ¦‚å¿µ

State ä¸­çš„æ¯ä¸ªé”®ï¼ˆkeyï¼‰å°±æ˜¯ä¸€ä¸ª**é€šé“ï¼ˆchannelï¼‰**ï¼š

```
State = {
    "name": "Alice",    # name é€šé“
    "mood": "happy"     # mood é€šé“
}
```

- æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥è¯»å–ä»»ä½•é€šé“çš„å€¼
- æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æ›´æ–°ä¸€ä¸ªæˆ–å¤šä¸ªé€šé“
- é€šé“ä¹‹é—´ç›¸äº’ç‹¬ç«‹

#### 2. èŠ‚ç‚¹æ›´æ–°æœºåˆ¶

```python
def node_1(state):
    # è¯»å– name é€šé“
    current_name = state["name"]

    # æ›´æ–° name é€šé“ï¼ˆè¿”å›å­—å…¸ï¼‰
    return {"name": current_name + " is happy"}
```

å…³é”®ç‚¹ï¼š
- **è¾“å…¥**ï¼šèŠ‚ç‚¹æ¥æ”¶å®Œæ•´çš„ State
- **è¾“å‡º**ï¼šèŠ‚ç‚¹è¿”å›è¦æ›´æ–°çš„å­—æ®µï¼ˆéƒ¨åˆ†æ›´æ–°ï¼‰
- **åˆå¹¶**ï¼šLangGraph è‡ªåŠ¨å°†è¿”å›å€¼åˆå¹¶åˆ° State ä¸­

---

## ğŸ”§ ä¸‰ç§å®šä¹‰æ–¹å¼

LangGraph æ”¯æŒä¸‰ç§å®šä¹‰ State Schema çš„æ–¹å¼ï¼Œæ¯ç§éƒ½æœ‰ç‹¬ç‰¹çš„ä¼˜åŠ¿ã€‚

### æ–¹å¼ 1: TypedDict â­

è¿™æ˜¯æœ€å¸¸ç”¨ã€æœ€ç®€å•çš„æ–¹å¼ã€‚

#### åŸºç¡€ç”¨æ³•

```python
from typing_extensions import TypedDict

class TypedDictState(TypedDict):
    foo: str
    bar: str
```

**ç‰¹ç‚¹ï¼š**
- âœ… è¯­æ³•ç®€æ´
- âœ… IDE æ”¯æŒå¥½ï¼ˆè‡ªåŠ¨è¡¥å…¨ã€ç±»å‹æç¤ºï¼‰
- âœ… æ€§èƒ½æœ€ä¼˜ï¼ˆæ— è¿è¡Œæ—¶éªŒè¯ï¼‰
- âŒ ä¸åšè¿è¡Œæ—¶ç±»å‹æ£€æŸ¥

#### è¿›é˜¶ç”¨æ³•ï¼šLiteral ç±»å‹

```python
from typing import Literal

class TypedDictState(TypedDict):
    name: str
    mood: Literal["happy", "sad"]  # é™å®šåªèƒ½æ˜¯è¿™ä¸¤ä¸ªå€¼ä¹‹ä¸€
```

**Literal è¯¦è§£ï¼š**

`Literal` æ˜¯ Python çš„ç±»å‹æç¤ºå·¥å…·ï¼Œç”¨äºé™åˆ¶å€¼çš„èŒƒå›´ï¼š

```python
# âœ… æ­£ç¡®
state = {"name": "Alice", "mood": "happy"}

# âŒ IDE ä¼šè­¦å‘Šï¼ˆä½†è¿è¡Œæ—¶ä¸æŠ¥é”™ï¼‰
state = {"name": "Alice", "mood": "angry"}  # angry ä¸åœ¨å…è®¸çš„å€¼ä¸­
```

#### åœ¨ LangGraph ä¸­ä½¿ç”¨

```python
from langgraph.graph import StateGraph, START, END

# 1. å®šä¹‰çŠ¶æ€
class TypedDictState(TypedDict):
    name: str
    mood: Literal["happy", "sad"]

# 2. å®šä¹‰èŠ‚ç‚¹
def node_1(state):
    return {"name": state["name"] + " is ... "}

# 3. åˆ›å»ºå›¾
builder = StateGraph(TypedDictState)  # ä¼ å…¥çŠ¶æ€ç±»
builder.add_node("node_1", node_1)
builder.add_edge(START, "node_1")
builder.add_edge("node_1", END)

# 4. ç¼–è¯‘å’Œè¿è¡Œ
graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

result = graph.invoke({"name": "Lance"})  # ç”¨å­—å…¸åˆå§‹åŒ–
```

**ç”Ÿæˆçš„æµç¨‹å›¾ï¼š**

![Flow Diagram](images/3.1-state-schema-output-8-0.jpg)


**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨ `StateGraph(TypedDictState)` æŒ‡å®šçŠ¶æ€æ¨¡å¼
- ç”¨å­—å…¸è°ƒç”¨ `graph.invoke({"name": "Lance"})`
- èŠ‚ç‚¹é€šè¿‡ `state["key"]` è®¿é—®å­—æ®µ

---

### æ–¹å¼ 2: Dataclass

Python 3.7+ æä¾›çš„æ•°æ®ç±»è£…é¥°å™¨ã€‚

#### åŸºç¡€ç”¨æ³•

```python
from dataclasses import dataclass

@dataclass
class DataclassState:
    name: str
    mood: Literal["happy", "sad"]
```

#### ä¸ TypedDict çš„åŒºåˆ«

| ç‰¹æ€§ | TypedDict | Dataclass |
|------|-----------|-----------|
| è®¿é—®æ–¹å¼ | `state["name"]` | `state.name` |
| åˆå§‹åŒ– | å­—å…¸ | ç±»å®ä¾‹ |
| æ€§èƒ½ | æ›´å¿« | ç¨æ…¢ |
| åŠŸèƒ½ | åŸºç¡€ | æ›´å¤šï¼ˆé»˜è®¤å€¼ã€æ–¹æ³•ç­‰ï¼‰ |

#### åœ¨ LangGraph ä¸­ä½¿ç”¨

```python
# å®šä¹‰èŠ‚ç‚¹ - æ³¨æ„è®¿é—®æ–¹å¼æ”¹å˜
def node_1(state):
    # âœ… ä½¿ç”¨ç‚¹å·è®¿é—®ï¼ˆä¸æ˜¯ state["name"]ï¼‰
    return {"name": state.name + " is ... "}

# åˆ›å»ºå›¾
builder = StateGraph(DataclassState)
builder.add_node("node_1", node_1)
builder.add_edge(START, "node_1")
builder.add_edge("node_1", END)

graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

# ç”¨ dataclass å®ä¾‹åˆå§‹åŒ–
result = graph.invoke(DataclassState(name="Lance", mood="sad"))
```

**ç”Ÿæˆçš„æµç¨‹å›¾ï¼š**

![Flow Diagram](images/3.1-state-schema-output-14-0.jpg)


**é‡è¦ç»†èŠ‚ï¼š**

è™½ç„¶ state æ˜¯ dataclassï¼Œä½†èŠ‚ç‚¹ä»ç„¶è¿”å›**å­—å…¸**ï¼š

```python
def node_1(state):
    # è¾“å…¥ï¼šdataclass
    name = state.name  # ç‚¹å·è®¿é—®

    # è¾“å‡ºï¼šå­—å…¸ï¼
    return {"name": name + " updated"}  # âœ… æ­£ç¡®
    # return DataclassState(...)  # âŒ ä¸éœ€è¦
```

**ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·ï¼Ÿ**

LangGraph å†…éƒ¨å°† state çš„æ¯ä¸ªå­—æ®µå­˜å‚¨ä¸ºç‹¬ç«‹çš„ channelã€‚èŠ‚ç‚¹è¿”å›çš„å­—å…¸åªéœ€è¦æœ‰åŒ¹é…çš„é”®ï¼Œå°±èƒ½æ›´æ–°å¯¹åº”çš„ channelã€‚

---

### æ–¹å¼ 3: Pydantic BaseModel â­â­

æœ€å¼ºå¤§çš„æ–¹å¼ï¼Œæä¾›è¿è¡Œæ—¶éªŒè¯ã€‚

#### ä»€ä¹ˆæ˜¯ Pydanticï¼Ÿ

Pydantic æ˜¯ Python çš„æ•°æ®éªŒè¯åº“ï¼Œæ ¸å¿ƒç±»æ˜¯ `BaseModel`ï¼š

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# âœ… è‡ªåŠ¨ç±»å‹è½¬æ¢
user = User(name="Alice", age="25")  # "25" è‡ªåŠ¨è½¬ä¸º 25
print(user.age)  # 25 (int)

# âŒ éªŒè¯å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸
user = User(name="Alice", age="invalid")  # ValidationError
```

#### TypedDict vs Pydantic å¯¹æ¯”

```python
# TypedDict - ä¸åšè¿è¡Œæ—¶æ£€æŸ¥
class DataclassState:
    name: str
    mood: Literal["happy", "sad"]

# âŒ è¿™æ®µä»£ç å¯ä»¥è¿è¡Œï¼ˆè™½ç„¶ IDE ä¼šè­¦å‘Šï¼‰
state = DataclassState(name="Lance", mood="angry")  # æ²¡æœ‰æŠ¥é”™
```

```python
# Pydantic - è¿è¡Œæ—¶éªŒè¯
from pydantic import BaseModel, field_validator

class PydanticState(BaseModel):
    name: str
    mood: str

    @field_validator('mood')
    @classmethod
    def validate_mood(cls, value):
        if value not in ["happy", "sad"]:
            raise ValueError("Mood must be 'happy' or 'sad'")
        return value

# âœ… æ­£ç¡®çš„å€¼
state = PydanticState(name="Lance", mood="happy")  # OK

# âŒ é”™è¯¯çš„å€¼ä¼šæŠ›å‡ºå¼‚å¸¸
state = PydanticState(name="Lance", mood="angry")  # ValidationError!
```

#### è‡ªå®šä¹‰éªŒè¯å™¨è¯¦è§£

```python
from pydantic import BaseModel, field_validator, ValidationError

class PydanticState(BaseModel):
    name: str
    mood: str

    @field_validator('mood')  # è£…é¥°å™¨ï¼šæŒ‡å®šè¦éªŒè¯çš„å­—æ®µ
    @classmethod  # å¿…é¡»æ˜¯ç±»æ–¹æ³•
    def validate_mood(cls, value):
        # value æ˜¯ä¼ å…¥çš„å€¼
        if value not in ["happy", "sad"]:
            raise ValueError("Each mood must be either 'happy' or 'sad'")
        return value  # è¿”å›éªŒè¯åçš„å€¼

# æµ‹è¯•éªŒè¯
try:
    state = PydanticState(name="John", mood="mad")
except ValidationError as e:
    print("Validation Error:", e)
    # è¾“å‡ºï¼šValidation Error: 1 validation error for PydanticState
    #      mood
    #        Input should be 'happy' or 'sad'
```

**éªŒè¯å™¨çš„å·¥ä½œæµç¨‹ï¼š**

```
ä¼ å…¥å€¼ â†’ field_validator â†’ æ£€æŸ¥é€»è¾‘ â†’ è¿”å›å€¼æˆ–æŠ›å‡ºå¼‚å¸¸
   â†“                                        â†“
"mad"                                   ValueError
                                           â†“
                                    ValidationError
```

#### åœ¨ LangGraph ä¸­ä½¿ç”¨

```python
# åˆ›å»ºå›¾ï¼ˆä¸ä¹‹å‰å®Œå…¨ç›¸åŒï¼‰
builder = StateGraph(PydanticState)
builder.add_node("node_1", node_1)
builder.add_edge(START, "node_1")
builder.add_edge("node_1", END)

graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

# ç”¨ Pydantic å®ä¾‹åˆå§‹åŒ–
result = graph.invoke(PydanticState(name="Lance", mood="sad"))
```

**ç”Ÿæˆçš„æµç¨‹å›¾ï¼š**

![Flow Diagram](images/3.1-state-schema-output-22-0.jpg)


---

## ğŸ­ å®æˆ˜æ¡ˆä¾‹ï¼šæƒ…ç»ªå†³ç­–ç³»ç»Ÿ

è®©æˆ‘ä»¬æ„å»ºä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿï¼Œå±•ç¤ºä¸‰ç§çŠ¶æ€å®šä¹‰æ–¹å¼çš„ä½¿ç”¨ã€‚

### ç³»ç»Ÿæ¶æ„

```
ç”¨æˆ·è¾“å…¥å§“å
     â†“
[node_1] ç”Ÿæˆæè¿°
     â†“
 (éšæœºå†³ç­–)
     â†“
    / \
   /   \
  â†“     â†“
[node_2] [node_3]
(happy)  (sad)
  â†“      â†“
  \      /
   \    /
    â†“  â†“
   è¿”å›ç»“æœ
```

### å®Œæ•´ä»£ç å®ç°

```python
import random
from typing import Literal
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END

# 1. å®šä¹‰çŠ¶æ€
class TypedDictState(TypedDict):
    name: str
    mood: Literal["happy", "sad"]

# 2. å®šä¹‰èŠ‚ç‚¹
def node_1(state):
    print("---Node 1---")
    return {"name": state["name"] + " is ... "}

def node_2(state):
    print("---Node 2---")
    return {"mood": "happy"}

def node_3(state):
    print("---Node 3---")
    return {"mood": "sad"}

# 3. æ¡ä»¶å‡½æ•°
def decide_mood(state) -> Literal["node_2", "node_3"]:
    """50/50 éšæœºé€‰æ‹©"""
    if random.random() < 0.5:
        return "node_2"  # 50% æ¦‚ç‡é€‰æ‹© happy
    return "node_3"      # 50% æ¦‚ç‡é€‰æ‹© sad

# 4. æ„å»ºå›¾
builder = StateGraph(TypedDictState)

# æ·»åŠ èŠ‚ç‚¹
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)

# æ·»åŠ è¾¹
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_mood)  # æ¡ä»¶è¾¹
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

# 5. ç¼–è¯‘å’Œè¿è¡Œ
graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

result = graph.invoke({"name": "Lance"})

print(result)
# è¾“å‡ºï¼š
# ---Node 1---
# ---Node 2---  (æˆ– ---Node 3---)
# {'name': 'Lance is ... ', 'mood': 'happy'}  (æˆ– 'sad')
```

### ä»£ç è¯¦è§£

#### 1. æ¡ä»¶è¾¹çš„å·¥ä½œåŸç†

```python
builder.add_conditional_edges("node_1", decide_mood)
#                             ^^^^^^^^^  ^^^^^^^^^^^
#                             æºèŠ‚ç‚¹      æ¡ä»¶å‡½æ•°
```

**æ‰§è¡Œæµç¨‹ï¼š**

```
1. æ‰§è¡Œ node_1
2. è°ƒç”¨ decide_mood(state)
3. decide_mood è¿”å› "node_2" æˆ– "node_3"
4. è·¯ç”±åˆ°å¯¹åº”çš„èŠ‚ç‚¹
5. æ‰§è¡Œ node_2 æˆ– node_3
6. åˆ°è¾¾ END
```

#### 2. Literal åœ¨æ¡ä»¶å‡½æ•°ä¸­çš„ä½œç”¨

```python
def decide_mood(state) -> Literal["node_2", "node_3"]:
    #                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
    #                    è¿”å›ç±»å‹æç¤ºï¼šåªèƒ½æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ä¹‹ä¸€
    return "node_2"  # âœ… æ­£ç¡®
    return "node_5"  # âŒ IDE ä¼šè­¦å‘Š
```

è¿™ä¸ä»…æ˜¯ç±»å‹æç¤ºï¼Œè¿˜å¸®åŠ© LangGraph ç†è§£å¯èƒ½çš„è·¯ç”±ç›®æ ‡ã€‚

#### 3. çŠ¶æ€æ›´æ–°çš„æ‰§è¡Œé¡ºåº

```python
åˆå§‹çŠ¶æ€: {"name": "Lance", "mood": None}
         â†“
node_1: è¿”å› {"name": "Lance is ... "}
åˆå¹¶å: {"name": "Lance is ... ", "mood": None}
         â†“
node_2: è¿”å› {"mood": "happy"}
åˆå¹¶å: {"name": "Lance is ... ", "mood": "happy"}  â† æœ€ç»ˆç»“æœ
```

---

## ğŸ“ æ ¸å¿ƒçŸ¥è¯†ç‚¹æ€»ç»“

### LangGraph ç‰¹æœ‰æ¦‚å¿µ

#### 1. State Schema çš„ä½œç”¨

| ä½œç”¨ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **å®šä¹‰æ•°æ®ç»“æ„** | æŒ‡å®šæœ‰å“ªäº›å­—æ®µ | `name: str, mood: str` |
| **ç±»å‹æç¤º** | IDE è‡ªåŠ¨è¡¥å…¨ | è¾“å…¥ `state.` è‡ªåŠ¨æç¤ºå­—æ®µ |
| **éªŒè¯ï¼ˆå¯é€‰ï¼‰** | Pydantic è¿è¡Œæ—¶æ£€æŸ¥ | é˜»æ­¢æ— æ•ˆæ•°æ® |
| **èŠ‚ç‚¹é€šä¿¡** | ç»Ÿä¸€çš„æ•°æ®æ¥å£ | æ‰€æœ‰èŠ‚ç‚¹ä½¿ç”¨ç›¸åŒç»“æ„ |

#### 2. Channelï¼ˆé€šé“ï¼‰æ¨¡å‹

```python
State = {
    "name": ...,  # name é€šé“
    "mood": ...   # mood é€šé“
}

# èŠ‚ç‚¹å¯ä»¥æ›´æ–°éƒ¨åˆ†é€šé“
def node(state):
    return {"name": "new_value"}  # åªæ›´æ–° name é€šé“
```

**å…³é”®ç‰¹æ€§ï¼š**
- æ¯ä¸ªå­—æ®µæ˜¯ç‹¬ç«‹çš„é€šé“
- èŠ‚ç‚¹å¯ä»¥åªæ›´æ–°éƒ¨åˆ†é€šé“
- æœªè¿”å›çš„é€šé“ä¿æŒä¸å˜

#### 3. ä¸‰ç§çŠ¶æ€æ–¹å¼å¯¹æ¯”

| ç‰¹æ€§ | TypedDict | Dataclass | Pydantic |
|------|-----------|-----------|----------|
| **è¯­æ³•å¤æ‚åº¦** | â­ ç®€å• | â­â­ ä¸­ç­‰ | â­â­ ä¸­ç­‰ |
| **è®¿é—®æ–¹å¼** | `state["key"]` | `state.key` | `state.key` |
| **è¿è¡Œæ—¶éªŒè¯** | âŒ æ—  | âŒ æ—  | âœ… æœ‰ |
| **æ€§èƒ½** | æœ€å¿« | å¿« | ç¨æ…¢ï¼ˆæœ‰éªŒè¯ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | ç®€å•ç±»å‹ | éœ€è¦é»˜è®¤å€¼/æ–¹æ³• | éœ€è¦ä¸¥æ ¼éªŒè¯ |
| **åˆå§‹åŒ–æ–¹å¼** | å­—å…¸ | ç±»å®ä¾‹ | ç±»å®ä¾‹ |

**é€‰æ‹©å»ºè®®ï¼š**

```python
# ç®€å•é¡¹ç›® â†’ TypedDict
class State(TypedDict):
    message: str

# éœ€è¦é»˜è®¤å€¼ â†’ Dataclass
@dataclass
class State:
    message: str = "default"

# éœ€è¦éªŒè¯ â†’ Pydantic
class State(BaseModel):
    message: str

    @field_validator('message')
    @classmethod
    def validate_message(cls, v):
        if len(v) < 1:
            raise ValueError("Message cannot be empty")
        return v
```

### Python ç‰¹æœ‰çŸ¥è¯†ç‚¹

#### 1. TypedDict è¯¦è§£

```python
from typing_extensions import TypedDict

# åŸºç¡€ç”¨æ³•
class State(TypedDict):
    name: str
    age: int

# å¯é€‰å­—æ®µ
from typing import Optional

class State(TypedDict):
    name: str
    age: Optional[int]  # å¯ä»¥æ˜¯ int æˆ– None

# total=False ä½¿æ‰€æœ‰å­—æ®µå¯é€‰
class State(TypedDict, total=False):
    name: str  # å¯é€‰
    age: int   # å¯é€‰
```

#### 2. Literal ç±»å‹è¯¦è§£

```python
from typing import Literal

# é™åˆ¶å­—ç¬¦ä¸²å€¼
def set_mood(mood: Literal["happy", "sad"]):
    ...

set_mood("happy")  # âœ…
set_mood("angry")  # âŒ IDE è­¦å‘Š

# é™åˆ¶å¤šç§ç±»å‹
def process(value: Literal[1, 2, "auto"]):
    ...

process(1)      # âœ…
process("auto") # âœ…
process(3)      # âŒ IDE è­¦å‘Š
```

#### 3. Pydantic Validator è¯¦è§£

```python
from pydantic import BaseModel, field_validator, validator

class State(BaseModel):
    name: str
    age: int

    # æ–¹å¼ 1: field_validator (æ¨è)
    @field_validator('age')
    @classmethod
    def validate_age(cls, v):
        if v < 0:
            raise ValueError('Age must be positive')
        return v

    # æ–¹å¼ 2: å¤šå­—æ®µéªŒè¯
    @field_validator('name', 'age')
    @classmethod
    def validate_both(cls, v, info):
        # info.field_name å¯ä»¥çŸ¥é“æ˜¯å“ªä¸ªå­—æ®µ
        if info.field_name == 'name' and len(v) < 1:
            raise ValueError('Name cannot be empty')
        return v
```

#### 4. Dataclass è¿›é˜¶ç”¨æ³•

```python
from dataclasses import dataclass, field

@dataclass
class State:
    name: str
    mood: str = "neutral"  # é»˜è®¤å€¼

    # åˆ—è¡¨å­—æ®µéœ€è¦ç”¨ field(default_factory)
    tags: list = field(default_factory=list)

    # è®¡ç®—å±æ€§
    @property
    def display_name(self):
        return f"{self.name} ({self.mood})"

state = State(name="Alice")
print(state.mood)          # "neutral"
print(state.display_name)  # "Alice (neutral)"
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½•æ—¶ä½¿ç”¨å“ªç§çŠ¶æ€å®šä¹‰ï¼Ÿ

#### âœ… TypedDict - å¤§å¤šæ•°æƒ…å†µ

```python
# æ¨èç”¨äºï¼š
# - ç®€å•çš„æ•°æ®ç»“æ„
# - æ€§èƒ½æ•æ„Ÿçš„åº”ç”¨
# - ä¸éœ€è¦è¿è¡Œæ—¶éªŒè¯çš„åœºæ™¯

class State(TypedDict):
    messages: list
    user_id: str
```

#### âœ… Dataclass - éœ€è¦é»˜è®¤å€¼æˆ–æ–¹æ³•

```python
# æ¨èç”¨äºï¼š
# - éœ€è¦é»˜è®¤å€¼
# - éœ€è¦è®¡ç®—å±æ€§
# - é¢å‘å¯¹è±¡è®¾è®¡

@dataclass
class State:
    messages: list = field(default_factory=list)
    retries: int = 3

    def should_retry(self):
        return self.retries > 0
```

#### âœ… Pydantic - éœ€è¦ä¸¥æ ¼éªŒè¯

```python
# æ¨èç”¨äºï¼š
# - å¤–éƒ¨è¾“å…¥ï¼ˆAPIã€ç”¨æˆ·è¾“å…¥ï¼‰
# - å…³é”®æ•°æ®ï¼ˆé…ç½®ã€å‡­è¯ï¼‰
# - éœ€è¦å¤æ‚éªŒè¯é€»è¾‘

class State(BaseModel):
    api_key: str
    max_retries: int

    @field_validator('api_key')
    @classmethod
    def validate_key(cls, v):
        if not v.startswith('sk-'):
            raise ValueError('Invalid API key format')
        return v

    @field_validator('max_retries')
    @classmethod
    def validate_retries(cls, v):
        if v < 1 or v > 10:
            raise ValueError('Retries must be between 1 and 10')
        return v
```

### 2. çŠ¶æ€è®¾è®¡åŸåˆ™

#### åŸåˆ™ 1: æœ€å°åŒ–çŠ¶æ€

```python
# âŒ ä¸å¥½ - åŒ…å«å†—ä½™æ•°æ®
class State(TypedDict):
    user_input: str
    user_input_lower: str  # å¯ä»¥ä» user_input è®¡ç®—
    user_input_length: int  # å¯ä»¥ä» user_input è®¡ç®—

# âœ… å¥½ - åªå­˜å‚¨å¿…éœ€æ•°æ®
class State(TypedDict):
    user_input: str

def node(state):
    # éœ€è¦æ—¶å†è®¡ç®—
    lower = state["user_input"].lower()
    length = len(state["user_input"])
```

#### åŸåˆ™ 2: ä½¿ç”¨æ˜ç¡®çš„ç±»å‹

```python
# âŒ ä¸å¥½ - ç±»å‹æ¨¡ç³Š
class State(TypedDict):
    data: dict  # ä»€ä¹ˆ dictï¼Ÿ

# âœ… å¥½ - ç±»å‹æ˜ç¡®
from typing import List, Dict

class Message(TypedDict):
    role: str
    content: str

class State(TypedDict):
    messages: List[Message]
    user_info: Dict[str, str]
```

#### åŸåˆ™ 3: åˆ†ç»„ç›¸å…³å­—æ®µ

```python
# âŒ ä¸å¥½ - å¹³é“ºæ‰€æœ‰å­—æ®µ
class State(TypedDict):
    user_name: str
    user_age: int
    user_email: str
    config_api_key: str
    config_timeout: int

# âœ… å¥½ - ä½¿ç”¨åµŒå¥—ç»“æ„
class UserInfo(TypedDict):
    name: str
    age: int
    email: str

class Config(TypedDict):
    api_key: str
    timeout: int

class State(TypedDict):
    user: UserInfo
    config: Config
```

### 3. å¸¸è§é™·é˜±

#### é™·é˜± 1: ä¿®æ”¹å¯å˜å¯¹è±¡

```python
# âŒ é”™è¯¯ - ç›´æ¥ä¿®æ”¹ state
def node(state):
    state["messages"].append("new message")  # å±é™©ï¼
    return state

# âœ… æ­£ç¡® - è¿”å›æ–°å¯¹è±¡
def node(state):
    new_messages = state["messages"] + ["new message"]
    return {"messages": new_messages}
```

#### é™·é˜± 2: å¿˜è®°åˆå§‹åŒ–

```python
# âŒ é”™è¯¯ - å­—æ®µæœªåˆå§‹åŒ–
class State(TypedDict):
    messages: list

graph.invoke({})  # æŠ¥é”™ï¼messages æœªå®šä¹‰

# âœ… æ­£ç¡® - æä¾›åˆå§‹å€¼
graph.invoke({"messages": []})

# æˆ–ä½¿ç”¨ Dataclass æä¾›é»˜è®¤å€¼
@dataclass
class State:
    messages: list = field(default_factory=list)

graph.invoke(State())  # OK
```

#### é™·é˜± 3: Pydantic éªŒè¯æ€§èƒ½

```python
# âŒ æ€§èƒ½é—®é¢˜ - å¤æ‚éªŒè¯
class State(BaseModel):
    data: list

    @field_validator('data')
    @classmethod
    def validate_data(cls, v):
        # æ¯æ¬¡æ›´æ–°éƒ½è¿è¡Œï¼
        for item in v:
            complex_validation(item)  # æ…¢ï¼
        return v

# âœ… ä¼˜åŒ– - åªåœ¨å¿…è¦æ—¶éªŒè¯
class State(TypedDict):
    data: list

def validate_once(state):
    # åªåœ¨ç‰¹å®šèŠ‚ç‚¹éªŒè¯ä¸€æ¬¡
    for item in state["data"]:
        complex_validation(item)
    return state
```

---

## ğŸš€ è¿›é˜¶æŠ€å·§

### 1. æ··åˆä½¿ç”¨å¤šç§çŠ¶æ€

```python
# å…¨å±€çŠ¶æ€ç”¨ TypedDictï¼ˆæ€§èƒ½ï¼‰
class OverallState(TypedDict):
    messages: list
    user_id: str

# ç‰¹å®šèŠ‚ç‚¹ç”¨ Pydanticï¼ˆéªŒè¯ï¼‰
class ValidatedInput(BaseModel):
    query: str

    @field_validator('query')
    @classmethod
    def validate_query(cls, v):
        if len(v) < 3:
            raise ValueError("Query too short")
        return v

def validation_node(state: OverallState):
    # éªŒè¯è¾“å…¥
    validated = ValidatedInput(query=state["messages"][-1])
    return {"messages": state["messages"]}
```

### 2. åŠ¨æ€çŠ¶æ€å­—æ®µ

```python
# ä½¿ç”¨ Dict å­˜å‚¨åŠ¨æ€æ•°æ®
class State(TypedDict):
    metadata: Dict[str, Any]  # åŠ¨æ€å­—æ®µ

def node(state):
    # å¯ä»¥åŠ¨æ€æ·»åŠ ä»»æ„é”®
    metadata = state.get("metadata", {})
    metadata["timestamp"] = time.time()
    metadata["custom_field"] = "value"
    return {"metadata": metadata}
```

### 3. çŠ¶æ€ç‰ˆæœ¬ç®¡ç†

```python
# æ·»åŠ ç‰ˆæœ¬å­—æ®µè·Ÿè¸ªçŠ¶æ€å˜åŒ–
class State(TypedDict):
    data: str
    version: int

def node_1(state):
    return {
        "data": state["data"] + " updated",
        "version": state["version"] + 1
    }

# å¯ä»¥æ ¹æ® version åšæ¡ä»¶åˆ¤æ–­
def should_continue(state):
    return "continue" if state["version"] < 5 else "stop"
```

---

## ğŸ“Š ä¸‰ç§æ–¹å¼å¯¹æ¯”æ€»ç»“

### åŠŸèƒ½å¯¹æ¯”è¡¨

| åŠŸèƒ½ | TypedDict | Dataclass | Pydantic |
|------|-----------|-----------|----------|
| ç±»å‹æç¤º | âœ… | âœ… | âœ… |
| IDE æ”¯æŒ | âœ… | âœ… | âœ… |
| è¿è¡Œæ—¶éªŒè¯ | âŒ | âŒ | âœ… |
| é»˜è®¤å€¼ | âŒ | âœ… | âœ… |
| è‡ªå®šä¹‰æ–¹æ³• | âŒ | âœ… | âœ… |
| è®¿é—®æ–¹å¼ | `["key"]` | `.key` | `.key` |
| åˆå§‹åŒ– | å­—å…¸ | å®ä¾‹ | å®ä¾‹ |
| æ€§èƒ½ | æœ€å¿« | å¿« | ä¸­ç­‰ |
| å­¦ä¹ æ›²çº¿ | ä½ | ä¸­ | ä¸­ |

### ä½¿ç”¨åœºæ™¯æ€»ç»“

```python
# ğŸ¯ é€‰æ‹©å†³ç­–æ ‘

# 1. éœ€è¦è¿è¡Œæ—¶éªŒè¯ï¼Ÿ
#    æ˜¯ â†’ Pydantic
#    å¦ â†’ ç»§ç»­

# 2. éœ€è¦é»˜è®¤å€¼æˆ–æ–¹æ³•ï¼Ÿ
#    æ˜¯ â†’ Dataclass
#    å¦ â†’ ç»§ç»­

# 3. è¿½æ±‚æœ€ä½³æ€§èƒ½ï¼Ÿ
#    æ˜¯ â†’ TypedDict
```

### å®é™…é¡¹ç›®å»ºè®®

**å°å‹é¡¹ç›®ï¼ˆ< 10 ä¸ªèŠ‚ç‚¹ï¼‰ï¼š**
```python
# å…¨ç”¨ TypedDict
class State(TypedDict):
    messages: list
    config: dict
```

**ä¸­å‹é¡¹ç›®ï¼ˆ10-50 ä¸ªèŠ‚ç‚¹ï¼‰ï¼š**
```python
# ä¸»çŠ¶æ€ç”¨ TypedDictï¼Œé…ç½®ç”¨ Pydantic
class State(TypedDict):
    messages: list
    config: AppConfig  # Pydantic model

class AppConfig(BaseModel):
    api_key: str
    timeout: int
```

**å¤§å‹é¡¹ç›®ï¼ˆ> 50 ä¸ªèŠ‚ç‚¹ï¼‰ï¼š**
```python
# åˆ†å±‚è®¾è®¡
class BaseState(TypedDict):
    # æ ¸å¿ƒå­—æ®µ
    messages: list

class ValidatedState(BaseModel):
    # éœ€éªŒè¯çš„å­—æ®µ
    user_input: str

@dataclass
class CachedState:
    # éœ€é»˜è®¤å€¼çš„å­—æ®µ
    cache: dict = field(default_factory=dict)
```

---

## ğŸ” å¸¸è§é—®é¢˜

### Q1: TypedDict çš„ç±»å‹æç¤ºä¸èµ·ä½œç”¨æ€ä¹ˆåŠï¼Ÿ

**åŸå› ï¼š** TypedDict åªæä¾›é™æ€ç±»å‹æ£€æŸ¥ï¼Œä¸åšè¿è¡Œæ—¶éªŒè¯ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
1. ä½¿ç”¨ IDEï¼ˆVSCodeã€PyCharmï¼‰è¿›è¡Œé™æ€æ£€æŸ¥
2. ä½¿ç”¨ mypy è¿›è¡Œç±»å‹æ£€æŸ¥ï¼š
   ```bash
   pip install mypy
   mypy your_script.py
   ```
3. å¦‚éœ€è¿è¡Œæ—¶éªŒè¯ï¼Œæ”¹ç”¨ Pydantic

### Q2: ä¸ºä»€ä¹ˆ Dataclass èŠ‚ç‚¹è¿˜è¦è¿”å›å­—å…¸ï¼Ÿ

**åŸå› ï¼š** LangGraph å°†çŠ¶æ€æŒ‰å­—æ®µï¼ˆchannelï¼‰å­˜å‚¨ï¼ŒèŠ‚ç‚¹è¿”å›çš„å­—å…¸ä¼šè‡ªåŠ¨æ˜ å°„åˆ°å¯¹åº”çš„ channelã€‚

**ç¤ºä¾‹ï¼š**
```python
@dataclass
class State:
    name: str
    age: int

def node(state):
    # state æ˜¯ dataclassï¼Œè®¿é—®ç”¨ç‚¹å·
    updated_name = state.name + " Smith"

    # è¿”å›å­—å…¸ï¼ŒLangGraph ä¼šè‡ªåŠ¨æ›´æ–°å¯¹åº” channel
    return {"name": updated_name}  # âœ… æ­£ç¡®
```

### Q3: Pydantic éªŒè¯å¤±è´¥ä¼šå¯¼è‡´å›¾å´©æºƒå—ï¼Ÿ

**æ˜¯çš„ã€‚** Pydantic éªŒè¯å¤±è´¥ä¼šæŠ›å‡º `ValidationError`ï¼Œå¯¼è‡´å›¾æ‰§è¡Œä¸­æ–­ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
```python
def node(state):
    try:
        validated = MyModel(**state)
        return {"data": validated.data}
    except ValidationError as e:
        # å¤„ç†é”™è¯¯
        return {"error": str(e), "data": None}
```

### Q4: å¯ä»¥åœ¨è¿è¡Œæ—¶æ”¹å˜çŠ¶æ€ç»“æ„å—ï¼Ÿ

**ä¸æ¨èã€‚** State Schema åº”è¯¥åœ¨å®šä¹‰å›¾æ—¶ç¡®å®šã€‚

**å¦‚æœéœ€è¦åŠ¨æ€å­—æ®µï¼š**
```python
# ä½¿ç”¨ Dict å­˜å‚¨åŠ¨æ€æ•°æ®
class State(TypedDict):
    static_field: str
    dynamic_data: Dict[str, Any]  # åŠ¨æ€å­—æ®µæ”¾è¿™é‡Œ
```

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [LangGraph State å®˜æ–¹æ–‡æ¡£](https://langchain-ai.github.io/langgraph/concepts/low_level/#state)
- [TypedDict å®˜æ–¹æ–‡æ¡£](https://docs.python.org/3/library/typing.html#typing.TypedDict)
- [Dataclasses å®˜æ–¹æ–‡æ¡£](https://docs.python.org/3/library/dataclasses.html)
- [Pydantic å®˜æ–¹æ–‡æ¡£](https://docs.pydantic.dev/)

---

## ğŸ¯ å®è·µç»ƒä¹ 

### ç»ƒä¹  1: å®ç°èŠå¤©æœºå™¨äººçŠ¶æ€

**éœ€æ±‚ï¼š**
- å­˜å‚¨å¯¹è¯å†å²ï¼ˆæ¶ˆæ¯åˆ—è¡¨ï¼‰
- å­˜å‚¨ç”¨æˆ·ä¿¡æ¯ï¼ˆå§“åã€å¹´é¾„ï¼‰
- å­˜å‚¨é…ç½®ï¼ˆAPI keyã€æ¨¡å‹åç§°ï¼‰

**æŒ‘æˆ˜ï¼š** åˆ†åˆ«ç”¨ TypedDictã€Dataclassã€Pydantic å®ç°ï¼Œå¯¹æ¯”ä¼˜ç¼ºç‚¹ã€‚

### ç»ƒä¹  2: çŠ¶æ€éªŒè¯

**éœ€æ±‚ï¼š**
- åˆ›å»ºä¸€ä¸ª Pydantic çŠ¶æ€
- æ·»åŠ éªŒè¯å™¨ç¡®ä¿ï¼š
  - å¹´é¾„åœ¨ 0-150 ä¹‹é—´
  - é‚®ç®±æ ¼å¼æ­£ç¡®
  - å¯†ç é•¿åº¦ >= 8

### ç»ƒä¹  3: åµŒå¥—çŠ¶æ€

**éœ€æ±‚ï¼š**
- åˆ›å»ºåµŒå¥—çš„çŠ¶æ€ç»“æ„ï¼ˆç”¨æˆ· â†’ åœ°å€ â†’ åŸå¸‚/è¡—é“ï¼‰
- å®ç°èŠ‚ç‚¹æ›´æ–°åµŒå¥—å­—æ®µ

---

**æ€»ç»“**ï¼šState Schema æ˜¯ LangGraph çš„åŸºç¡€ã€‚ç†è§£ä¸‰ç§å®šä¹‰æ–¹å¼çš„ä¼˜ç¼ºç‚¹ï¼Œèƒ½å¸®åŠ©ä½ è®¾è®¡å‡ºæ›´å¥å£®ã€é«˜æ•ˆçš„ AI åº”ç”¨ã€‚é€‰æ‹©åˆé€‚çš„çŠ¶æ€å®šä¹‰æ–¹å¼ï¼Œæ˜¯æ„å»ºå¯ç»´æŠ¤ LangGraph åº”ç”¨çš„ç¬¬ä¸€æ­¥ï¼
