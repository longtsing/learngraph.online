# 2.4.2 Agent Builder - 无代码智能体构建器

> **难度级别**: 高级
> **前置知识**: Agent 基础概念、LangGraph 状态管理、工具调用
> **预计阅读时间**: 45 分钟

---

## 目录

1. [概述](#概述)
2. [核心概念](#核心概念)
3. [环境配置](#环境配置)
4. [内置工具](#内置工具)
5. [MCP 框架](#mcp-框架)
6. [Slack 应用集成](#slack-应用集成)
7. [Deep Agents 底层框架](#deep-agents-底层框架)
8. [完整案例代码](#完整案例代码)
9. [扩展阅读](#扩展阅读)

---

## 概述

### 什么是 Agent Builder?

**Agent Builder** 是 LangSmith 提供的一个 **无代码智能体构建平台**（目前处于 Beta 阶段）。它允许用户通过自然语言描述来创建生产级的 AI 智能体，无需编写代码。

> **核心理念**: 将自然语言概念转换为可运行的生产级智能体

与传统的可视化工作流构建器不同，Agent Builder 采用 **对话式构建方式**：

```
用户描述任务 → 系统提问澄清 → 自动生成提示词 → 连接工具 → 设置触发器
```

### 架构概览

Agent Builder 基于开源项目 [deep-agents](https://github.com/langchain-ai/deepagents) 构建，整合了 LangChain 和 LangGraph 的最佳实践。

```
┌─────────────────────────────────────────────────────────────────┐
│                     Agent Builder 架构                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   Prompt     │    │    Tools     │    │   Triggers   │      │
│  │  (智能体大脑) │    │ (工具连接)   │    │ (自动触发)   │      │
│  └──────┬───────┘    └──────┬───────┘    └──────┬───────┘      │
│         │                   │                   │               │
│         └───────────────────┼───────────────────┘               │
│                             │                                   │
│                    ┌────────▼────────┐                          │
│                    │   Sub-agents    │                          │
│                    │  (子智能体)      │                          │
│                    └────────┬────────┘                          │
│                             │                                   │
│                    ┌────────▼────────┐                          │
│                    │     Memory      │                          │
│                    │  (记忆系统)      │                          │
│                    └─────────────────┘                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Deep Agents 引擎                      │   │
│  │  (Planning + Computer Access + Sub-agent Delegation)     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 与传统方式的对比

| 特性 | 传统代码开发 | 可视化工作流 | Agent Builder |
|------|-------------|-------------|---------------|
| 技术门槛 | 高 | 中 | 低 |
| 灵活性 | 高 | 中 | 中高 |
| 构建方式 | 编写代码 | 拖拽节点 | 自然语言对话 |
| 适合人群 | 开发者 | 技术产品经理 | 所有人 |
| 维护成本 | 高 | 中 | 低 |

---

## 核心概念

Agent Builder 的每个智能体由 **四个核心组件** 构成：

### 1. Prompt（提示词）

提示词是智能体的"大脑"，包含智能体应该做什么的逻辑描述。

**特点**：
- 所有复杂逻辑都推入提示词，而非复杂的可视化工作流
- 通过对话式引导自动生成
- 支持后续修改和优化

```python
# 示例：智能体提示词结构
system_prompt = """
你是一个智能会议助手。

职责：
1. 检查用户的日历
2. 提取会议参与者信息
3. 查找相关上下文
4. 在 Slack 中发送会议摘要

注意事项：
- 确保信息准确
- 保持摘要简洁
- 标注重要议题
"""
```

### 2. Tools（工具）

工具使用 **MCP（Model Context Protocol）** 协议连接外部服务。

**两种工具来源**：
- **内置工具**：Gmail、Slack、Google Calendar、Linear 等
- **自定义 MCP 服务器**：用户自己部署的工具服务

### 3. Triggers（触发器）

触发器使智能体能够自动响应后台事件：

| 触发器类型 | 说明 | 使用场景 |
|-----------|------|---------|
| **Slack** | 特定频道的消息触发 | 客服机器人、团队助手 |
| **Gmail** | 邮件到达触发 | 邮件分类、自动回复 |
| **Cron** | 定时触发 | 日报生成、定期检查 |

### 4. Sub-agents（子智能体）

子智能体是处理特定任务的专门化小型智能体：

```
┌─────────────────────────────────────────┐
│            主智能体 (Orchestrator)       │
│                                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ 数据检索 │  │ 内容生成 │  │ 通知发送 │ │
│  │ 子智能体 │  │ 子智能体 │  │ 子智能体 │ │
│  └────┬────┘  └────┬────┘  └────┬────┘ │
│       │            │            │       │
│       └────────────┼────────────┘       │
│                    ▼                    │
│              结果汇总和协调              │
└─────────────────────────────────────────┘
```

**子智能体的优势**：
- 专注于特定任务，提高效率
- 独立的上下文窗口，避免混乱
- 可并行执行，缩短总体时间
- 便于维护和调试

### 5. Memory（记忆系统）

Agent Builder 的智能体具有内置记忆功能：

**记忆特性**：
- **跨会话保持**：相关信息在会话之间持续存储
- **自我更新**：智能体可以修改自己的工具和指令
- **纠错学习**：当用户纠正智能体时，会自动记住以避免重复错误

**不可修改项**：
- 智能体名称
- 智能体描述
- 已附加的触发器

### 6. Human-in-the-Loop（人机协作）

智能体在执行关键操作前会暂停，等待人工审核：

```
智能体提议操作 → 人工审核 → [批准/修改/拒绝] → 继续执行
```

**三种响应选项**：
1. **批准 (Approve)**：同意提议的操作
2. **修改 (Edit)**：调整参数后继续
3. **反馈 (Feedback)**：提供改进建议

---

## 环境配置

### 工作区密钥设置

Agent Builder 需要在 LangSmith 工作区中配置密钥才能正常工作。

#### 配置步骤

1. 登录 LangSmith，点击 **Settings（设置）** 图标
2. 选择 **Secrets（密钥）** 标签页
3. 点击 **Add secret（添加密钥）**
4. 输入密钥名称和对应的值
5. 点击 **Save secret（保存密钥）**

#### 必需的密钥

| 密钥名称 | 说明 | 必需性 |
|---------|------|--------|
| `ANTHROPIC_API_KEY` | Anthropic API 密钥，用于模型推理 | **必需** |

> **重要**: Agent Builder 默认使用 Anthropic 的 Claude 模型，因此 `ANTHROPIC_API_KEY` 是必需的。

#### 可选的工具密钥

| 密钥名称 | 功能 |
|---------|------|
| `EXA_API_KEY` | 启用 Exa 搜索（网络搜索、LinkedIn 档案搜索） |
| `TAVILY_API_KEY` | 启用 Tavily 网络搜索 |
| `TWITTER_API_KEY` | Twitter/X 只读操作 |
| `TWITTER_API_KEY_SECRET` | Twitter/X API 密钥对 |

> **注意**: 添加工作区密钥时，确保密钥名称与模型提供商期望的环境变量名称完全匹配。

---

## 内置工具

Agent Builder 提供 **8 类内置工具**：

### 通讯与消息

#### Gmail

| 功能 | 说明 |
|------|------|
| 读取邮件 | 支持搜索过滤、可选包含正文 |
| 发送邮件 | 撰写并发送新邮件 |
| 创建草稿 | 保存邮件草稿 |
| 管理标签 | 添加/删除邮件标签 |

#### Slack

| 功能 | 说明 |
|------|------|
| 发送私信 | 向用户发送直接消息 |
| 频道发布 | 在频道中发布消息 |
| 线程回复 | 回复特定消息线程 |
| 历史访问 | 读取频道和线程历史 |

### 日历与项目管理

#### Google Calendar

- 列出日历事件
- 获取事件详情
- 创建新的日历条目

#### Linear

- 管理问题（创建、过滤、删除）
- 团队管理功能

### 搜索与发现

| 工具 | 功能 |
|------|------|
| **Exa** | 网络搜索、LinkedIn 档案搜索 |
| **Tavily** | 高质量网络搜索 |

### 社交媒体

#### LinkedIn
- 发布帖子
- 支持附加图片或链接

#### Twitter/X
- 读取单条推文
- 获取列表的最新帖子
- **注意**：仅支持只读操作，不支持发布

### 实用工具

| 功能 | 说明 |
|------|------|
| 提取网页文本 | 从 URL 获取页面内容 |
| 获取图片 URL | 提取页面中的图片链接 |
| 提取元数据 | 获取页面元信息 |
| 用户通知 | 发送通知给用户 |

### 认证方式

| 方式 | 适用工具 |
|------|---------|
| **OAuth** | Google、Slack、Linear、LinkedIn |
| **工作区密钥** | Exa、Tavily、Twitter/X |

---

## MCP 框架

### 什么是 MCP?

**MCP（Model Context Protocol）** 是一个标准化协议，用于创建、部署和管理智能体工具。LangSmith Tool Server 是基于 MCP 的工具服务器框架。

### 安装

```bash
# 安装工具服务器
pip install langsmith-tool-server

# 安装 CLI 工具
pip install langchain-cli-v2
```

### 创建工具包

```bash
# 创建新的工具包项目
langchain tools new my-toolkit
cd my-toolkit
```

这会创建以下目录结构：

```
my-toolkit/
├── pyproject.toml      # 项目配置
├── toolkit.toml        # 工具包配置
└── my_toolkit/
    ├── __init__.py     # 工具定义
    └── auth.py         # 认证处理（可选）
```

### 定义工具

使用 `@tool` 装饰器定义工具：

```python
# my_toolkit/__init__.py
from langsmith_tool_server import tool

@tool
def hello(name: str) -> str:
    """
    向某人问好。

    Args:
        name: 要问候的人的名字
    """
    return f"Hello, {name}!"

@tool
def add(x: int, y: int) -> int:
    """
    计算两个数的和。

    Args:
        x: 第一个数
        y: 第二个数
    """
    return x + y

@tool
def search_database(query: str, limit: int = 10) -> str:
    """
    搜索数据库。

    Args:
        query: 搜索查询
        limit: 返回结果数量限制
    """
    # 实际实现中连接数据库
    return f"找到关于 '{query}' 的 {limit} 条结果"

# 导出工具列表
TOOLS = [hello, add, search_database]
```

### 运行服务器

```bash
# 启动 MCP 服务器（默认端口 8000）
langchain tools serve
```

服务器运行后，可通过 `http://localhost:8000/mcp` 访问 JSON-RPC 端点。

### 客户端调用

```python
import asyncio
import aiohttp

async def mcp_request(url: str, method: str, params: dict = None):
    """发送 MCP 请求"""
    async with aiohttp.ClientSession() as session:
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params or {},
            "id": 1
        }
        async with session.post(f"{url}/mcp", json=payload) as response:
            return await response.json()

async def main():
    url = "http://localhost:8000"

    # 列出所有可用工具
    tools = await mcp_request(url, "tools/list")
    print(f"可用工具: {tools}")

    # 调用 add 工具
    result = await mcp_request(
        url,
        "tools/call",
        {"name": "add", "arguments": {"x": 5, "y": 3}}
    )
    print(f"计算结果: {result}")

    # 调用 hello 工具
    greeting = await mcp_request(
        url,
        "tools/call",
        {"name": "hello", "arguments": {"name": "LangGraph"}}
    )
    print(f"问候结果: {greeting}")

if __name__ == "__main__":
    asyncio.run(main())
```

### OAuth 认证工具

需要 OAuth 认证的工具示例：

```python
from langsmith_tool_server import tool, Context
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build

@tool(
    auth_provider="google",
    scopes=["https://www.googleapis.com/auth/gmail.readonly"],
    integration="gmail"
)
async def read_emails(context: Context, max_results: int = 10) -> str:
    """
    读取 Gmail 中的最近邮件。

    Args:
        context: 认证上下文（自动注入）
        max_results: 返回的最大邮件数量
    """
    # 使用 OAuth token 创建凭证
    credentials = Credentials(token=context.token)
    service = build('gmail', 'v1', credentials=credentials)

    # 获取邮件列表
    results = service.users().messages().list(
        userId='me',
        maxResults=max_results
    ).execute()

    messages = results.get('messages', [])
    return f"获取了 {len(messages)} 封邮件"

@tool(
    auth_provider="slack",
    integration="slack"
)
async def send_slack_message(
    context: Context,
    channel: str,
    message: str
) -> str:
    """
    发送 Slack 消息。

    Args:
        context: 认证上下文
        channel: 频道 ID 或名称
        message: 消息内容
    """
    # 使用 context.token 调用 Slack API
    # ...
    return f"消息已发送到 {channel}"
```

### 自定义认证

```python
# my_toolkit/auth.py
from langsmith_tool_server import Auth

auth = Auth()

@auth.authenticate
async def authenticate(authorization: str = None) -> dict:
    """
    验证请求并返回用户身份。

    Args:
        authorization: Authorization 请求头
    """
    if not authorization or not authorization.startswith("Bearer "):
        raise auth.exceptions.HTTPException(
            status_code=401,
            detail="未授权：需要 Bearer token"
        )

    token = authorization.replace("Bearer ", "")

    # 使用你的身份提供商验证 token
    user = await verify_token_with_idp(token)

    return {
        "identity": user.id,
        "permissions": user.permissions
    }

async def verify_token_with_idp(token: str):
    """验证 token（示例实现）"""
    # 实际实现中调用 IdP API
    class User:
        id = "user_123"
        permissions = ["read", "write"]
    return User()
```

### MCP 网关配置

聚合多个 MCP 服务器的工具：

```toml
# toolkit.toml
[toolkit]
name = "my-toolkit"
tools = "./my_toolkit/__init__.py:TOOLS"

# HTTP 传输的远程服务器
[[mcp_servers]]
name = "weather"
transport = "streamable_http"
url = "http://localhost:8001/mcp/"

# stdio 传输的本地服务器
[[mcp_servers]]
name = "math"
transport = "stdio"
command = "python"
args = ["-m", "mcp_server_math"]

# 另一个远程服务器
[[mcp_servers]]
name = "database"
transport = "streamable_http"
url = "https://db-tools.example.com/mcp/"
```

配置后，工具会以服务器名称为前缀（如 `weather_get_forecast`、`math_calculate`）以避免命名冲突。

---

## Slack 应用集成

### 安装步骤

1. 在 LangSmith 中访问 Agent Builder
2. 创建新智能体或编辑现有智能体
3. 添加 Slack 作为触发器或启用 Slack 工具
4. 按提示完成授权
5. 完成 OAuth 流程，授予 Slack 工作区权限

应用会在授权完成后自动部署。

### 核心功能

集成后，智能体获得以下能力：

| 功能 | 说明 |
|------|------|
| 发送私信 | 向 Slack 用户发送直接消息 |
| 频道发布 | 在频道中发布消息 |
| 线程阅读 | 读取线程消息历史 |
| 线程回复 | 回复特定消息线程 |
| 历史访问 | 访问对话历史记录 |

### 权限要求

Slack 集成需要以下权限：

| 权限类型 | 说明 |
|---------|------|
| **消息** | 发送私信和频道消息 |
| **阅读** | 读取频道历史和线程消息 |
| **频道访问** | 获取基本频道信息 |
| **用户查找** | 查找用户信息以发送消息 |

### 数据与隐私

**关键保障**：
- Slack 数据 **不会** 用于训练 LLM
- 工作区数据保持隔离，仅用于操作目的
- 数据保留遵循 LangSmith 组织策略
- 数据存储位置与 LangSmith 配置一致

### 费用说明

- Slack 应用本身 **免费**
- 费用来自智能体执行和跟踪，通过 LangSmith 订阅计费

---

## Deep Agents 底层框架

Agent Builder 基于开源的 **Deep Agents** 框架构建。

### 核心设计原则

Deep Agents 受 Claude Code 等领先 AI 智能体启发，实现三个基础原则：

1. **规划 (Planning)**: 执行前的结构化任务分解
2. **计算机访问 (Computer Access)**: Shell 和文件系统集成
3. **子智能体委托 (Sub-agent Delegation)**: 隔离的执行上下文

### 内置工具

Deep Agents 为所有智能体提供 9 个标准工具：

| 工具 | 功能 | 来源中间件 |
|------|------|-----------|
| `write_todos` | 写入待办事项 | TodoListMiddleware |
| `read_todos` | 读取待办事项 | TodoListMiddleware |
| `ls` | 列出目录 | FilesystemMiddleware |
| `read_file` | 读取文件 | FilesystemMiddleware |
| `write_file` | 写入文件 | FilesystemMiddleware |
| `edit_file` | 编辑文件 | FilesystemMiddleware |
| `glob` | 文件匹配 | FilesystemMiddleware |
| `grep` | 内容搜索 | FilesystemMiddleware |
| `task` | 创建子智能体 | SubAgentMiddleware |

### 中间件系统

Deep Agents 使用可组合的中间件扩展功能：

| 中间件 | 功能 |
|--------|------|
| **TodoListMiddleware** | 任务规划和进度跟踪 |
| **FilesystemMiddleware** | 文件操作和上下文管理 |
| **SubAgentMiddleware** | 子智能体委托 |
| **SummarizationMiddleware** | 170k token 时自动上下文压缩 |
| **AnthropicPromptCachingMiddleware** | Anthropic 模型成本优化 |
| **HumanInTheLoopMiddleware** | 敏感操作的审批工作流 |

### 后端存储选项

| 后端 | 说明 | 适用场景 |
|------|------|---------|
| **StateBackend** | 临时、会话范围存储（默认） | 开发、测试 |
| **FilesystemBackend** | 直接磁盘访问 | 需要持久化的本地应用 |
| **StoreBackend** | 通过 LangGraph Store 持久存储 | 生产环境、跨会话 |
| **CompositeBackend** | 路由不同路径到不同后端 | 复杂场景 |

---
