# Module-2 å°ç»“å’Œå¤ä¹ ï¼šæ ¸å¿ƒæ¶æ„æ¨¡å¼æŒæ¡æŒ‡å—

> **æ¥è‡ªå›¾çµå¥–è·å¾—è€…çš„å¯„è¯­**
>
> æ­å–œä½ å®Œæˆäº† Module-2 çš„å­¦ä¹ ï¼ä½ å·²ç»æŒæ¡äº† LangGraph çš„å…­å¤§æ ¸å¿ƒæ¶æ„æ¨¡å¼ã€‚è¿™äº›æ¨¡å¼æ˜¯æ„å»ºç”Ÿäº§çº§ AI Agent çš„åŸºçŸ³ã€‚æ­£å¦‚è®¡ç®—æœºç§‘å­¦ä¸­çš„è®¾è®¡æ¨¡å¼ä¸€æ ·ï¼Œç†è§£**ä½•æ—¶ä½¿ç”¨å“ªç§æ¨¡å¼**æ¯”è®°ä½è¯­æ³•æ›´é‡è¦ã€‚æœ¬å¤ä¹ æ–‡æ¡£é€šè¿‡ 15 ä¸ªæ·±åº¦é—®é¢˜ï¼Œå¸®åŠ©ä½ ä»"çŸ¥é“"è¿›åŒ–åˆ°"ç²¾é€š"ã€‚
>
> è®°ä½ï¼šä¼Ÿå¤§çš„ç³»ç»Ÿæ¶æ„å¸ˆä¸æ˜¯è®°ä½äº†æ‰€æœ‰æ¨¡å¼ï¼Œè€Œæ˜¯èƒ½å¤Ÿåœ¨æ­£ç¡®çš„åœºæ™¯é€‰æ‹©æ­£ç¡®çš„æ¨¡å¼ã€‚

---

## ğŸ“‹ æœ¬ç« æ ¸å¿ƒçŸ¥è¯†å›é¡¾

### å­¦ä¹ åœ°å›¾

```
Module-2: æ ¸å¿ƒæ¶æ„æ¨¡å¼
â”œâ”€ 2.1 Simple Graph (åŸºç¡€å›¾)
â”‚  â””â”€ çŠ¶æ€ã€èŠ‚ç‚¹ã€è¾¹çš„åŸºæœ¬æ¦‚å¿µ
â”œâ”€ 2.2 Chain (é“¾å¼æ¶æ„)
â”‚  â””â”€ æ¶ˆæ¯ç³»ç»Ÿã€å·¥å…·ç»‘å®šã€Reducer
â”œâ”€ 2.3 Router (è·¯ç”±æ¶æ„)
â”‚  â””â”€ æ¡ä»¶è¾¹ã€åŠ¨æ€è·¯ç”±ã€å·¥å…·è°ƒç”¨
â”œâ”€ 2.4 Agent (æ™ºèƒ½ä½“æ¶æ„)
â”‚  â””â”€ ReAct å¾ªç¯ã€å¤šæ­¥æ¨ç†ã€å·¥å…·æ‰§è¡Œ
â”œâ”€ 2.5 Agent Memory (è®°å¿†ç®¡ç†)
â”‚  â””â”€ Checkpointerã€Threadã€çŠ¶æ€æŒä¹…åŒ–
â””â”€ 2.6 Deployment (ç”Ÿäº§éƒ¨ç½²)
   â””â”€ LangGraph Cloudã€Studioã€SDK
```

### å…­å¤§æ¨¡å¼é€ŸæŸ¥è¡¨

| æ¨¡å¼ | æ ¸å¿ƒç‰¹å¾ | é€‚ç”¨åœºæ™¯ | å…³é”®æŠ€æœ¯ |
|------|---------|---------|---------|
| **Simple Graph** | 3-5 èŠ‚ç‚¹ï¼Œæ¡ä»¶åˆ†æ”¯ | å­¦ä¹ åŸºç¡€ã€ç®€å•æµç¨‹ | TypedDict, Literal |
| **Chain** | çº¿æ€§æµç¨‹ï¼Œå·¥å…·ç»‘å®š | å•æ¬¡å·¥å…·è°ƒç”¨ | add_messages, bind_tools |
| **Router** | LLM å†³ç­–è·¯ç”± | æ™ºèƒ½åˆ†ç±»ã€åŠ¨æ€é€‰æ‹© | tools_condition, ToolNode |
| **Agent** | ReAct å¾ªç¯æ¨ç† | å¤šæ­¥ä»»åŠ¡ã€å¤æ‚æ¨ç† | å¾ªç¯è¾¹ã€å·¥å…·åé¦ˆ |
| **Agent Memory** | çŠ¶æ€æŒä¹…åŒ– | å¤šè½®å¯¹è¯ã€ä¸Šä¸‹æ–‡è¿ç»­ | Checkpointer, Thread |
| **Deployment** | ç”Ÿäº§ç¯å¢ƒéƒ¨ç½² | çœŸå®ç”¨æˆ·æœåŠ¡ | LangGraph Cloud, SDK |

---

## ğŸ“š æœ¯è¯­è¡¨

| æœ¯è¯­åç§° | LangGraph å®šä¹‰å’Œè§£è¯» | Python å®šä¹‰å’Œè¯´æ˜ | é‡è¦ç¨‹åº¦ |
|---------|---------------------|------------------|---------|
| **StateGraph** | æ ¸å¿ƒå›¾æ„å»ºå™¨ï¼Œç®¡ç†æœ‰çŠ¶æ€å·¥ä½œæµçš„åˆ›å»ºå’Œæ‰§è¡Œ | æ¥å— State ç±»å‹å‚æ•°çš„æ³›å‹ç±»ï¼Œæä¾›èŠ‚ç‚¹å’Œè¾¹çš„æ·»åŠ æ–¹æ³• | â­â­â­â­â­ |
| **MessagesState** | ä¸“ä¸ºå¯¹è¯è®¾è®¡çš„é¢„å®šä¹‰çŠ¶æ€ç±» | åŒ…å« messages å­—æ®µå¹¶è‡ªåŠ¨ä½¿ç”¨ add_messages reducer | â­â­â­â­â­ |
| **add_messages** | æ™ºèƒ½æ¶ˆæ¯åˆå¹¶ reducerï¼Œæ”¯æŒè¿½åŠ å’Œå»é‡ | æ¥æ”¶æ—§æ¶ˆæ¯åˆ—è¡¨å’Œæ–°æ¶ˆæ¯ï¼Œè¿”å›åˆå¹¶åçš„åˆ—è¡¨ | â­â­â­â­â­ |
| **Reducer** | æ§åˆ¶çŠ¶æ€æ›´æ–°æ–¹å¼çš„å‡½æ•°ï¼Œå®ç°éè¦†ç›–å¼åˆå¹¶ | å‡½æ•°ç­¾åä¸º (old_value, new_value) -> merged_value | â­â­â­â­â­ |
| **Conditional Edge** | æ ¹æ®çŠ¶æ€åŠ¨æ€é€‰æ‹©ä¸‹ä¸€èŠ‚ç‚¹çš„æ™ºèƒ½è·¯ç”±è¾¹ | é€šè¿‡ add_conditional_edges æ·»åŠ ï¼Œéœ€æä¾›è¿”å›èŠ‚ç‚¹åçš„å‡½æ•° | â­â­â­â­â­ |
| **ToolNode** | è‡ªåŠ¨æ‰§è¡Œå·¥å…·è°ƒç”¨çš„é¢„æ„å»ºèŠ‚ç‚¹ | è§£æ AIMessage.tool_callsï¼Œè°ƒç”¨å‡½æ•°ï¼Œè¿”å› ToolMessage | â­â­â­â­â­ |
| **Checkpointer** | çŠ¶æ€æŒä¹…åŒ–æœºåˆ¶ï¼Œåœ¨èŠ‚ç‚¹æ‰§è¡Œåè‡ªåŠ¨ä¿å­˜çŠ¶æ€ | æ¥å£ç±»ï¼ŒMemorySaver/PostgresSaver æ˜¯å…¶å®ç° | â­â­â­â­â­ |
| **Thread** | ç‹¬ç«‹çš„å¯¹è¯ä¼šè¯å®¹å™¨ï¼Œé€šè¿‡ thread_id éš”ç¦»çŠ¶æ€ | æ¯ä¸ª thread ç»´æŠ¤ç‹¬ç«‹çš„ checkpoint å†å² | â­â­â­â­â­ |
| **Agent** | æ”¯æŒå¤šæ­¥æ¨ç†å’Œå·¥å…·è°ƒç”¨çš„æ™ºèƒ½ä½“æ¶æ„ | é€šè¿‡å¾ªç¯è¾¹å®ç° ReAct æ¨¡å¼ï¼ˆæ¨ç†-è¡ŒåŠ¨-è§‚å¯Ÿï¼‰ | â­â­â­â­â­ |
| **ReAct** | Reasoning + Actingï¼ŒAgent çš„ç»å…¸å®ç°æ¨¡å¼ | LLM åŸºäºå·¥å…·ç»“æœæŒç»­æ¨ç†ç›´åˆ°å¾—å‡ºæœ€ç»ˆç­”æ¡ˆ | â­â­â­â­â­ |
| **LangGraph Cloud** | æ‰˜ç®¡éƒ¨ç½²æœåŠ¡ï¼Œä» GitHub è‡ªåŠ¨éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ | æä¾›å”¯ä¸€ URLã€ç›‘æ§è¿½è¸ªã€ç¯å¢ƒå˜é‡ç®¡ç† | â­â­â­â­â­ |
| **LangGraph SDK** | Python å®¢æˆ·ç«¯åº“ï¼Œç”¨äºç¨‹åºåŒ–è°ƒç”¨éƒ¨ç½²çš„å›¾ | æä¾›å¼‚æ­¥ API è®¿é—® assistantsã€threadsã€runs | â­â­â­â­â­ |

---

## ğŸ¯ å¤ä¹ é¢˜ç›®åˆ—è¡¨

æœ¬å¤ä¹ åŒ…å« **15 ä¸ªæ¸è¿›å¼é—®é¢˜**ï¼Œè¦†ç›–çŸ¥è¯†ç†è§£ã€ä»£ç å®ç°ã€æ¶æ„è®¾è®¡ä¸‰ä¸ªå±‚æ¬¡ï¼š

**åŸºç¡€ç†è§£é¢˜ï¼ˆ1-5ï¼‰**
1. LangGraph çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ
2. Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
3. ä¸ºä»€ä¹ˆéœ€è¦ add_messages Reducerï¼Ÿ
4. Checkpointer çš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ
5. æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰å¦‚ä½•å†³å®šè·¯ç”±ï¼Ÿ

**ä»£ç å®ç°é¢˜ï¼ˆ6-10ï¼‰**
6. å¦‚ä½•å®ç°ä¸€ä¸ªå¸¦å¤šä¸ªå·¥å…·çš„ Routerï¼Ÿ
7. å¦‚ä½•è®© Agent é¿å…æ— é™å¾ªç¯ï¼Ÿ
8. å¦‚ä½•å®ç°è·¨ä¼šè¯çš„å¯¹è¯è®°å¿†ï¼Ÿ
9. å¦‚ä½•åœ¨æœ¬åœ°æµ‹è¯•åéƒ¨ç½²åˆ°äº‘ç«¯ï¼Ÿ
10. å¦‚ä½•å¤„ç†å·¥å…·è°ƒç”¨å¤±è´¥çš„æƒ…å†µï¼Ÿ

**æ¶æ„è®¾è®¡é¢˜ï¼ˆ11-15ï¼‰**
11. è®¾è®¡ä¸€ä¸ªå®¢æœæœºå™¨äººï¼šåº”è¯¥é€‰æ‹©å“ªç§æ¶æ„æ¨¡å¼ï¼Ÿ
12. å¦‚ä½•ä¼˜åŒ– Agent çš„ Token ä½¿ç”¨ï¼Ÿ
13. å¦‚ä½•è®¾è®¡å¤šç”¨æˆ·å¹¶å‘çš„ Agent ç³»ç»Ÿï¼Ÿ
14. Simple Graph vs Chain vs Agentï¼šå¦‚ä½•é€‰æ‹©ï¼Ÿ
15. å¦‚ä½•è®¾è®¡å¯æ‰©å±•çš„å·¥å…·ç³»ç»Ÿï¼Ÿ

---

## ğŸ“š è¯¦ç»†é—®ç­”è§£æ

### **é—®é¢˜ 1: LangGraph çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

LangGraph çš„çŠ¶æ€ç®¡ç†åŸºäº **TypedDict + Annotated + Reducer** çš„ä¸‰å±‚æ¶æ„ã€‚

#### **1. TypedDictï¼šå®šä¹‰çŠ¶æ€ç»“æ„**

```python
from typing_extensions import TypedDict

class State(TypedDict):
    messages: list
    count: int
    user_id: str
```

**ä½œç”¨ï¼š**
- æä¾›ç±»å‹æç¤ºå’Œ IDE æ”¯æŒ
- å®šä¹‰çŠ¶æ€çš„"éª¨æ¶"
- ä¸å¼ºåˆ¶è¿è¡Œæ—¶éªŒè¯ï¼ˆä¸ Pydantic ä¸åŒï¼‰

#### **2. Annotatedï¼šé™„åŠ å…ƒæ•°æ®**

```python
from typing import Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list, add_messages]
    #          ^^^^^^^^      ^^^^^^^^^^^^^
    #          åŸºç¡€ç±»å‹      Reducer å‡½æ•°
    count: int  # æ²¡æœ‰ Annotated = é»˜è®¤è¦†ç›–è¡Œä¸º
```

**ä½œç”¨ï¼š**
- ä¸ºå­—æ®µæ·»åŠ é¢å¤–ä¿¡æ¯ï¼ˆReducerï¼‰
- ä¸å½±å“ç±»å‹æ£€æŸ¥
- LangGraph è¯»å–å…ƒæ•°æ®æ¥å†³å®šçŠ¶æ€æ›´æ–°æ–¹å¼

#### **3. Reducerï¼šæ§åˆ¶æ›´æ–°é€»è¾‘**

**é»˜è®¤è¡Œä¸ºï¼ˆæ—  Reducerï¼‰ï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"count": 5}

# èŠ‚ç‚¹è¿”å›
node_output = {"count": 10}

# ç»“æœï¼šè¦†ç›–
new_state = {"count": 10}  # 5 è¢«æ›¿æ¢
```

**ä½¿ç”¨ Reducerï¼ˆadd_messagesï¼‰ï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"messages": [msg1, msg2]}

# èŠ‚ç‚¹è¿”å›
node_output = {"messages": [msg3]}

# ç»“æœï¼šè¿½åŠ 
new_state = {"messages": [msg1, msg2, msg3]}
```

#### **4. add_messages çš„æ™ºèƒ½ç‰¹æ€§**

```python
from langgraph.graph.message import add_messages

# ç‰¹æ€§ 1ï¼šè¿½åŠ æ–°æ¶ˆæ¯
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# ç»“æœï¼š[HumanMessage("Hi"), AIMessage("Hello")]

# ç‰¹æ€§ 2ï¼šåŸºäº ID æ›´æ–°ï¼ˆå»é‡ï¼‰
state = {"messages": [AIMessage("Thinking...", id="msg1")]}
update = {"messages": [AIMessage("Answer is 42", id="msg1")]}
# ç»“æœï¼š[AIMessage("Answer is 42", id="msg1")]  â† æ›¿æ¢è€Œéè¿½åŠ 
```

#### **5. è‡ªå®šä¹‰ Reducer**

```python
import operator

class State(TypedDict):
    # æ•°å­—ç´¯åŠ 
    score: Annotated[int, operator.add]

    # åˆ—è¡¨åˆå¹¶
    items: Annotated[list, operator.add]

    # è‡ªå®šä¹‰ï¼šåªä¿ç•™æœ€è¿‘ N æ¡
    recent_logs: Annotated[list, lambda old, new: (old + new)[-10:]]
```

**æ‰§è¡Œæ•ˆæœï¼š**
```python
# score ä½¿ç”¨ operator.add
state = {"score": 5}
update = {"score": 3}
# ç»“æœï¼š{"score": 8}  â† 5 + 3

# items ä½¿ç”¨ operator.addï¼ˆåˆ—è¡¨æ‹¼æ¥ï¼‰
state = {"items": [1, 2]}
update = {"items": [3, 4]}
# ç»“æœï¼š{"items": [1, 2, 3, 4]}

# recent_logs ä½¿ç”¨è‡ªå®šä¹‰ lambda
state = {"recent_logs": [1,2,3,4,5,6,7,8,9,10]}
update = {"recent_logs": [11, 12]}
# ç»“æœï¼š{"recent_logs": [3,4,5,6,7,8,9,10,11,12]}  â† åªä¿ç•™æœ€å 10 ä¸ª
```

#### **6. æ ¸å¿ƒåŸç†æ€»ç»“**

```python
# çŠ¶æ€æ›´æ–°æµç¨‹
åˆå§‹çŠ¶æ€ â†’ èŠ‚ç‚¹æ‰§è¡Œ â†’ è¿”å›æ›´æ–° â†’ Reducer åˆå¹¶ â†’ æ–°çŠ¶æ€

# ä¼ªä»£ç 
def update_state(old_state, node_output):
    new_state = {}
    for key, value in node_output.items():
        if has_reducer(key):
            new_state[key] = reducer(old_state[key], value)
        else:
            new_state[key] = value  # ç›´æ¥è¦†ç›–
    return {**old_state, **new_state}
```

#### **7. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„è®¾è®¡
class ChatState(TypedDict):
    messages: Annotated[list, add_messages]  # å¯¹è¯å†å²ï¼šè¿½åŠ 
    user_id: str                              # ç”¨æˆ·æ ‡è¯†ï¼šè¦†ç›–
    session_count: Annotated[int, operator.add]  # ä¼šè¯è®¡æ•°ï¼šç´¯åŠ 

# âŒ ä¸å¥½çš„è®¾è®¡
class BadState(TypedDict):
    messages: list  # æ²¡æœ‰ Reducerï¼Œæ¯æ¬¡è¦†ç›– â†’ ä¸¢å¤±å†å²
    all_data: dict  # å¤ªå®½æ³›ï¼Œéš¾ä»¥ç»´æŠ¤
```

#### **å…³é”®è¦ç‚¹**
- **TypedDict**ï¼šå®šä¹‰"ä»€ä¹ˆ"ï¼ˆæ•°æ®ç»“æ„ï¼‰
- **Annotated**ï¼šå®šä¹‰"å¦‚ä½•"ï¼ˆæ›´æ–°æ–¹å¼ï¼‰
- **Reducer**ï¼šå®ç°"è¡Œä¸º"ï¼ˆåˆå¹¶é€»è¾‘ï¼‰
- **add_messages**ï¼šä¸“ä¸ºå¯¹è¯è®¾è®¡çš„æ™ºèƒ½ Reducer

</details>

---

### **é—®é¢˜ 2: Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«åœ¨äº **å·¥å…·ç»“æœçš„æµå‘** å’Œ **å†³ç­–æ¬¡æ•°**ã€‚

#### **1. æ¶æ„æµç¨‹å¯¹æ¯”**

**Router æ¶æ„ï¼š**
```
ç”¨æˆ·è¾“å…¥ â†’ LLM å†³ç­– â†’ å·¥å…·æ‰§è¡Œ â†’ ç›´æ¥è¿”å›ç”¨æˆ·
                â†“
         è°ƒç”¨ä¸€æ¬¡å·¥å…·
         åšä¸€æ¬¡å†³ç­–
```

**Agent æ¶æ„ï¼š**
```
ç”¨æˆ·è¾“å…¥ â†’ LLM å†³ç­– â†’ å·¥å…·æ‰§è¡Œ â†’ è¿”å› LLM â†’ ç»§ç»­å†³ç­– â†’ ...
                â†‘______________________|
                        å¾ªç¯åé¦ˆ
         å¯èƒ½è°ƒç”¨å¤šæ¬¡å·¥å…·
         åšå¤šæ¬¡å†³ç­–
```

#### **2. ä»£ç ç»“æ„å¯¹æ¯”**

**Router çš„å›¾ç»“æ„ï¼š**
```python
from langgraph.prebuilt import tools_condition, ToolNode

builder = StateGraph(MessagesState)
builder.add_node("llm", call_llm)
builder.add_node("tools", ToolNode([multiply]))

builder.add_edge(START, "llm")
builder.add_conditional_edges("llm", tools_condition)
builder.add_edge("tools", END)  # â† å…³é”®ï¼šå·¥å…·åç›´æ¥ç»“æŸ

graph = builder.compile()
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START â†’ llm â†’ [æœ‰å·¥å…·è°ƒç”¨] â†’ tools â†’ END
              [æ— å·¥å…·è°ƒç”¨] â†’ END
```

**Agent çš„å›¾ç»“æ„ï¼š**
```python
builder = StateGraph(MessagesState)
builder.add_node("agent", call_llm)
builder.add_node("tools", ToolNode([multiply]))

builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", tools_condition)
builder.add_edge("tools", "agent")  # â† å…³é”®ï¼šå·¥å…·åå›åˆ° agentï¼Œå½¢æˆå¾ªç¯

graph = builder.compile()
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START â†’ agent â†’ [æœ‰å·¥å…·è°ƒç”¨] â†’ tools â†’ agent â†’ [ç»§ç»­åˆ¤æ–­] â†’ ...
                [æ— å·¥å…·è°ƒç”¨] â†’ END
```

#### **3. å®é™…æ¡ˆä¾‹å¯¹æ¯”**

**åœºæ™¯ï¼š** è®¡ç®— `(3 + 4) Ã— 2 Ã· 5`

**Router çš„æ‰§è¡Œï¼š**
```python
# ç¬¬ 1 æ¬¡è°ƒç”¨å›¾
è¾“å…¥: "Calculate (3 + 4) Ã— 2 Ã· 5"
LLM: è°ƒç”¨ add(3, 4)
å·¥å…·: è¿”å› 7
è¾“å‡º: ToolMessage(content="7")
# ç»“æŸ âŒ æ— æ³•ç»§ç»­è®¡ç®—

# éœ€è¦æ‰‹åŠ¨ç¬¬ 2 æ¬¡è°ƒç”¨
è¾“å…¥: "Now multiply 7 by 2"
LLM: è°ƒç”¨ multiply(7, 2)
å·¥å…·: è¿”å› 14
è¾“å‡º: ToolMessage(content="14")
# ç»“æŸ âŒ è¿˜æ˜¯æ— æ³•å®Œæˆ
```

**Agent çš„æ‰§è¡Œï¼š**
```python
è¾“å…¥: "Calculate (3 + 4) Ã— 2 Ã· 5"

# å¾ªç¯ 1
LLM: "éœ€è¦å…ˆè®¡ç®— 3 + 4" â†’ è°ƒç”¨ add(3, 4)
å·¥å…·: è¿”å› 7
â†’ å›åˆ° LLM

# å¾ªç¯ 2
LLM: "å¾—åˆ° 7ï¼Œç°åœ¨ä¹˜ä»¥ 2" â†’ è°ƒç”¨ multiply(7, 2)
å·¥å…·: è¿”å› 14
â†’ å›åˆ° LLM

# å¾ªç¯ 3
LLM: "å¾—åˆ° 14ï¼Œç°åœ¨é™¤ä»¥ 5" â†’ è°ƒç”¨ divide(14, 5)
å·¥å…·: è¿”å› 2.8
â†’ å›åˆ° LLM

# å¾ªç¯ 4
LLM: "æ‰€æœ‰è®¡ç®—å®Œæˆï¼Œç­”æ¡ˆæ˜¯ 2.8"
è¾“å‡º: AIMessage(content="The answer is 2.8")
â†’ ç»“æŸ âœ…
```

#### **4. å·¥å…·ç»“æœçš„æµå‘**

**Routerï¼š**
```python
def tools_node(state):
    # æ‰§è¡Œå·¥å…·
    result = tool.invoke(...)
    return {"messages": [ToolMessage(result)]}
    # â†“
    # æµå‘ï¼šç›´æ¥åˆ° ENDï¼Œç”¨æˆ·å¯è§
```

**Agentï¼š**
```python
def tools_node(state):
    # æ‰§è¡Œå·¥å…·
    result = tool.invoke(...)
    return {"messages": [ToolMessage(result)]}
    # â†“
    # æµå‘ï¼šå›åˆ° agent èŠ‚ç‚¹ï¼ŒLLM åˆ†æç»“æœ
```

#### **5. å†³ç­–æ¬¡æ•°å¯¹æ¯”**

**Routerï¼šå•æ¬¡å†³ç­–**
```python
ç”¨æˆ·é—®é¢˜ â†’ [LLM æ€è€ƒ 1 æ¬¡] â†’ è°ƒç”¨å·¥å…·/ç›´æ¥å›ç­” â†’ ç»“æŸ
```

**Agentï¼šå¤šæ¬¡å†³ç­–**
```python
ç”¨æˆ·é—®é¢˜ â†’ [LLM æ€è€ƒ 1] â†’ å·¥å…· â†’ [LLM æ€è€ƒ 2] â†’ å·¥å…· â†’ ... â†’ [LLM æ€è€ƒ N] â†’ å›ç­”
```

#### **6. é€‚ç”¨åœºæ™¯å¯¹æ¯”**

| åœºæ™¯ | æ¨èæ¶æ„ | åŸå›  |
|------|---------|------|
| ç®€å•é—®ç­”ï¼ˆ"ä»Šå¤©å¤©æ°”"ï¼‰ | Router | å•æ¬¡æŸ¥è¯¢å³å¯ |
| ä¿¡æ¯æ£€ç´¢ï¼ˆ"æœç´¢è®ºæ–‡"ï¼‰ | Router | ä¸€æ¬¡æœç´¢è¿”å› |
| æ•°å­¦è®¡ç®—ï¼ˆå¤šæ­¥éª¤ï¼‰ | Agent | éœ€è¦åŸºäºä¸­é—´ç»“æœæ¨ç† |
| ç ”ç©¶åŠ©æ‰‹ï¼ˆæœç´¢â†’é˜…è¯»â†’æ€»ç»“ï¼‰ | Agent | éœ€è¦å¤šæ­¥éª¤åä½œ |
| å®¢æœï¼ˆæŸ¥è®¢å•â†’å›ç­”ï¼‰ | Router | å•æ¬¡å·¥å…·è°ƒç”¨ |
| æ•°æ®åˆ†æï¼ˆæŸ¥è¯¢â†’è®¡ç®—â†’å¯è§†åŒ–ï¼‰ | Agent | éœ€è¦è¿ç»­æ“ä½œ |

#### **7. ä»£ç å¯¹æ¯”æ€»ç»“**

**å”¯ä¸€çš„åŒºåˆ«ï¼šä¸€æ¡è¾¹**
```python
# Router
builder.add_edge("tools", END)  # å·¥å…· â†’ ç»“æŸ

# Agent
builder.add_edge("tools", "agent")  # å·¥å…· â†’ å›åˆ° agentï¼ˆå¾ªç¯ï¼‰
```

è¿™ä¸€æ¡è¾¹çš„å·®å¼‚ï¼Œå¯¼è‡´äº†ï¼š
- âœ… Routerï¼šç®€å•ã€å¿«é€Ÿã€å¯é¢„æµ‹
- âœ… Agentï¼šçµæ´»ã€å¼ºå¤§ã€æ™ºèƒ½
- âŒ Routerï¼šæ— æ³•å¤šæ­¥æ¨ç†
- âŒ Agentï¼šå¯èƒ½å¾ªç¯ã€æˆæœ¬é«˜

#### **å…³é”®è¦ç‚¹**
- **Router = å•æ¬¡å†³ç­– + å·¥å…·ç›´è¾¾ç”¨æˆ·**
- **Agent = å¤šæ¬¡å†³ç­– + å·¥å…·åé¦ˆ LLM**
- **åŒºåˆ«åœ¨äºï¼šæ˜¯å¦æœ‰ä» tools åˆ° agent çš„è¾¹**
- **é€‰æ‹©æ ‡å‡†ï¼šä»»åŠ¡æ˜¯å¦éœ€è¦å¤šæ­¥æ¨ç†**

</details>

---

### **é—®é¢˜ 3: ä¸ºä»€ä¹ˆéœ€è¦ add_messages Reducerï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

`add_messages` è§£å†³äº†å¯¹è¯ç³»ç»Ÿä¸­ **çŠ¶æ€è¦†ç›–å¯¼è‡´å†å²ä¸¢å¤±** çš„æ ¸å¿ƒé—®é¢˜ã€‚

#### **1. é—®é¢˜æ¼”ç¤ºï¼šæ²¡æœ‰ Reducer ä¼šå‘ç”Ÿä»€ä¹ˆ**

```python
# é”™è¯¯çš„çŠ¶æ€å®šä¹‰ï¼ˆæ²¡æœ‰ Reducerï¼‰
class State(TypedDict):
    messages: list  # é»˜è®¤è¡Œä¸ºï¼šè¦†ç›–

# åˆå§‹çŠ¶æ€
state = {"messages": [HumanMessage("Hi")]}

# èŠ‚ç‚¹ 1 æ‰§è¡Œ
def node1(state):
    return {"messages": [AIMessage("Hello!")]}

# æ›´æ–°åçš„çŠ¶æ€
# âŒ é¢„æœŸï¼š[HumanMessage("Hi"), AIMessage("Hello!")]
# âœ… å®é™…ï¼š[AIMessage("Hello!")]  â† HumanMessage ä¸¢å¤±äº†ï¼
```

**é—®é¢˜åˆ†æï¼š**
- LangGraph é»˜è®¤ä½¿ç”¨ **å­—å…¸æ›´æ–°è¯­ä¹‰**ï¼ˆ`dict.update()`ï¼‰
- ç›¸åŒ key çš„å€¼ä¼šè¢«**å®Œå…¨æ›¿æ¢**ï¼Œè€Œä¸æ˜¯åˆå¹¶
- å¯¹è¯å†å²è¢«è¦†ç›– â†’ LLM å¤±å»ä¸Šä¸‹æ–‡ â†’ æ— æ³•ç†è§£æŒ‡ä»£è¯

#### **2. çœŸå®åœºæ™¯çš„ç¾éš¾**

```python
# ç¬¬ä¸€è½®å¯¹è¯
user: "æˆ‘çš„è®¢å•å·æ˜¯ 12345"
agent: "å¥½çš„ï¼Œæˆ‘çœ‹åˆ°æ‚¨çš„è®¢å• 12345"

# ç¬¬äºŒè½®å¯¹è¯ï¼ˆæ²¡æœ‰ Reducerï¼‰
state = {"messages": [AIMessage("å¥½çš„ï¼Œæˆ‘çœ‹åˆ°æ‚¨çš„è®¢å• 12345")]}
# âŒ ç”¨æˆ·çš„æ¶ˆæ¯ä¸¢å¤±äº†ï¼

user: "é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ"
agent: "è¯·é—®æ‚¨çš„è®¢å•å·æ˜¯å¤šå°‘ï¼Ÿ"  â† å¿˜è®°äº†åˆšæ‰è¯´çš„ 12345
```

#### **3. add_messages çš„ä½œç”¨**

```python
from langgraph.graph.message import add_messages
from typing import Annotated

class State(TypedDict):
    messages: Annotated[list, add_messages]
    #                   ^^^^  ^^^^^^^^^^^^^
    #                   ç±»å‹  Reducer å‡½æ•°
```

**æ‰§è¡Œæ•ˆæœï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"messages": [HumanMessage("Hi")]}

# èŠ‚ç‚¹è¿”å›
update = {"messages": [AIMessage("Hello!")]}

# add_messages è‡ªåŠ¨åˆå¹¶
new_state = {"messages": [
    HumanMessage("Hi"),      â† ä¿ç•™
    AIMessage("Hello!")      â† è¿½åŠ 
]}
```

#### **4. add_messages çš„æ™ºèƒ½ç‰¹æ€§**

**ç‰¹æ€§ 1ï¼šè‡ªåŠ¨è¿½åŠ **
```python
messages = [msg1, msg2]
add_messages(messages, [msg3])
# ç»“æœï¼š[msg1, msg2, msg3]
```

**ç‰¹æ€§ 2ï¼šåŸºäº ID æ›´æ–°ï¼ˆå»é‡ï¼‰**
```python
messages = [AIMessage("Loading...", id="response-1")]
add_messages(messages, [AIMessage("Done!", id="response-1")])
# ç»“æœï¼š[AIMessage("Done!", id="response-1")]  â† æ›¿æ¢è€Œéé‡å¤
```

**ç‰¹æ€§ 3ï¼šæ”¯æŒå¤šç§è¾“å…¥æ ¼å¼**
```python
# å•ä¸ªæ¶ˆæ¯
add_messages(messages, AIMessage("Hi"))

# æ¶ˆæ¯åˆ—è¡¨
add_messages(messages, [msg1, msg2])

# æ··åˆç±»å‹
add_messages(messages, [HumanMessage("Q"), AIMessage("A")])
```

#### **5. æ²¡æœ‰ Reducer çš„åæœå¯¹æ¯”**

**åœºæ™¯ï¼š** ä¸‰è½®å¯¹è¯

**æ²¡æœ‰ add_messagesï¼š**
```python
# è½®æ¬¡ 1
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# çŠ¶æ€ï¼š[AIMessage("Hello")]  âŒ Hi ä¸¢å¤±

# è½®æ¬¡ 2
state = {"messages": [AIMessage("Hello")]}
update = {"messages": [HumanMessage("How are you?")]}
# çŠ¶æ€ï¼š[HumanMessage("How are you?")]  âŒ Hello ä¸¢å¤±

# è½®æ¬¡ 3
state = {"messages": [HumanMessage("How are you?")]}
update = {"messages": [AIMessage("I'm good")]}
# çŠ¶æ€ï¼š[AIMessage("I'm good")]  âŒ é—®é¢˜ä¸¢å¤±

# LLM åªèƒ½çœ‹åˆ°æœ€åä¸€æ¡æ¶ˆæ¯ï¼Œæ— æ³•ç†è§£ä¸Šä¸‹æ–‡ï¼
```

**æœ‰ add_messagesï¼š**
```python
# è½®æ¬¡ 1
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# çŠ¶æ€ï¼š[HumanMessage("Hi"), AIMessage("Hello")]  âœ…

# è½®æ¬¡ 2
state = {"messages": [HumanMessage("Hi"), AIMessage("Hello")]}
update = {"messages": [HumanMessage("How are you?")]}
# çŠ¶æ€ï¼š[HumanMessage("Hi"), AIMessage("Hello"), HumanMessage("How are you?")]  âœ…

# è½®æ¬¡ 3
state = {"messages": [..., HumanMessage("How are you?")]}
update = {"messages": [AIMessage("I'm good")]}
# çŠ¶æ€ï¼š[..., HumanMessage("How are you?"), AIMessage("I'm good")]  âœ…

# LLM å¯ä»¥çœ‹åˆ°å®Œæ•´å¯¹è¯å†å²ï¼
```

#### **6. add_messages çš„å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰**

```python
def add_messages(existing: list, new: list | BaseMessage) -> list:
    """æ™ºèƒ½åˆå¹¶æ¶ˆæ¯åˆ—è¡¨"""
    # 1. æ ‡å‡†åŒ–è¾“å…¥
    if not isinstance(new, list):
        new = [new]

    # 2. æ„å»º ID æ˜ å°„
    id_map = {msg.id: i for i, msg in enumerate(existing) if msg.id}

    # 3. åˆå¹¶é€»è¾‘
    result = existing.copy()
    for msg in new:
        if msg.id and msg.id in id_map:
            # æœ‰ ID ä¸”å·²å­˜åœ¨ â†’ æ›´æ–°
            result[id_map[msg.id]] = msg
        else:
            # æ—  ID æˆ–ä¸å­˜åœ¨ â†’ è¿½åŠ 
            result.append(msg)

    return result
```

#### **7. å…¶ä»–å¸¸ç”¨ Reducer**

```python
import operator

class State(TypedDict):
    # æ•°å­—ç´¯åŠ 
    total_cost: Annotated[float, operator.add]

    # åˆ—è¡¨æ‹¼æ¥
    search_results: Annotated[list, operator.add]

    # é›†åˆåˆå¹¶
    visited_pages: Annotated[set, operator.or_]

    # è‡ªå®šä¹‰ï¼šä¿ç•™æœ€å¤§å€¼
    max_score: Annotated[float, max]
```

#### **8. ä½•æ—¶ä¸éœ€è¦ Reducer**

```python
class State(TypedDict):
    messages: Annotated[list, add_messages]  # éœ€è¦ï¼šå¯¹è¯å†å²
    user_id: str                              # ä¸éœ€è¦ï¼šå›ºå®šæ ‡è¯†
    current_page: int                         # ä¸éœ€è¦ï¼šå½“å‰å€¼è¦†ç›–å³å¯
    is_authenticated: bool                    # ä¸éœ€è¦ï¼šçŠ¶æ€æ ‡è®°
```

**åŸåˆ™ï¼š**
- éœ€è¦**ç´¯ç§¯**çš„æ•°æ® â†’ ä½¿ç”¨ Reducer
- éœ€è¦**æ›¿æ¢**çš„æ•°æ® â†’ ä¸ä½¿ç”¨ Reducer

#### **å…³é”®è¦ç‚¹**
- **é—®é¢˜ï¼š** é»˜è®¤å­—å…¸æ›´æ–°ä¼šè¦†ç›–æ•´ä¸ªåˆ—è¡¨
- **åæœï¼š** å¯¹è¯å†å²ä¸¢å¤±ï¼ŒLLM å¤±å»ä¸Šä¸‹æ–‡
- **è§£å†³ï¼š** add_messages æ™ºèƒ½è¿½åŠ /æ›´æ–°æ¶ˆæ¯
- **æœ¬è´¨ï¼š** å°†"è¦†ç›–è¯­ä¹‰"æ”¹ä¸º"åˆå¹¶è¯­ä¹‰"

</details>

---

### **é—®é¢˜ 4: Checkpointer çš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

Checkpointer æ˜¯ LangGraph çš„ **è‡ªåŠ¨å¿«ç…§ç³»ç»Ÿ**ï¼Œåœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œåä¿å­˜çŠ¶æ€ï¼Œå®ç°å¤šè½®å¯¹è¯å’Œæ—¶é—´æ—…è¡Œã€‚

#### **1. æ ¸å¿ƒæ¦‚å¿µ**

**Checkpointï¼ˆæ£€æŸ¥ç‚¹ï¼‰ï¼š** å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­æŸä¸ªæ—¶åˆ»çš„å®Œæ•´çŠ¶æ€å¿«ç…§

```python
checkpoint = {
    "state": {"messages": [msg1, msg2]},  # çŠ¶æ€æ•°æ®
    "metadata": {
        "node": "agent",                   # å½“å‰èŠ‚ç‚¹
        "step": 2,                         # æ‰§è¡Œæ­¥æ•°
        "timestamp": "2024-03-15T10:30:00"
    },
    "parent_id": "checkpoint-1",          # çˆ¶æ£€æŸ¥ç‚¹ ID
    "id": "checkpoint-2"                  # å½“å‰æ£€æŸ¥ç‚¹ ID
}
```

#### **2. å·¥ä½œæµç¨‹**

**æ²¡æœ‰ Checkpointerï¼š**
```python
graph = builder.compile()  # æ— çŠ¶æ€æŒä¹…åŒ–

# ç¬¬ä¸€æ¬¡è°ƒç”¨
result1 = graph.invoke({"messages": [msg1]})
# çŠ¶æ€ï¼šå­˜åœ¨äºå†…å­˜ï¼Œè°ƒç”¨ç»“æŸåä¸¢å¤±

# ç¬¬äºŒæ¬¡è°ƒç”¨
result2 = graph.invoke({"messages": [msg2]})
# çŠ¶æ€ï¼šå…¨æ–°å¼€å§‹ï¼Œä¸è®°å¾— msg1
```

**æœ‰ Checkpointerï¼š**
```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

# ç¬¬ä¸€æ¬¡è°ƒç”¨
config = {"configurable": {"thread_id": "user-123"}}
result1 = graph.invoke({"messages": [msg1]}, config)
# âœ… çŠ¶æ€è‡ªåŠ¨ä¿å­˜åˆ° checkpointer

# ç¬¬äºŒæ¬¡è°ƒç”¨ï¼ˆåŒä¸€ thread_idï¼‰
result2 = graph.invoke({"messages": [msg2]}, config)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„çŠ¶æ€ï¼Œmsg1 è¿˜åœ¨ï¼
```

#### **3. ä¿å­˜æ—¶æœº**

Checkpointer åœ¨ **æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå** è‡ªåŠ¨ä¿å­˜ï¼š

```python
graph = StateGraph(State)
graph.add_node("node1", node1_func)
graph.add_node("node2", node2_func)
graph.add_edge(START, "node1")
graph.add_edge("node1", "node2")
graph.add_edge("node2", END)

graph_with_memory = graph.compile(checkpointer=memory)
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START
  â†“
node1 æ‰§è¡Œ
  â†“
ğŸ’¾ Checkpoint 1: {"state": {...}, "node": "node1", "step": 1}
  â†“
node2 æ‰§è¡Œ
  â†“
ğŸ’¾ Checkpoint 2: {"state": {...}, "node": "node2", "step": 2}
  â†“
END
```

#### **4. Threadï¼šçŠ¶æ€å®¹å™¨**

**Threadï¼ˆçº¿ç¨‹ï¼‰** æ˜¯éš”ç¦»ä¸åŒä¼šè¯çŠ¶æ€çš„æ ‡è¯†ç¬¦ã€‚

```python
# ç”¨æˆ· A çš„å¯¹è¯
config_a = {"configurable": {"thread_id": "user-a"}}
graph.invoke(input, config_a)
# ä¿å­˜åˆ° thread_id="user-a"

# ç”¨æˆ· B çš„å¯¹è¯ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
config_b = {"configurable": {"thread_id": "user-b"}}
graph.invoke(input, config_b)
# ä¿å­˜åˆ° thread_id="user-b"
```

**Thread ç»“æ„ï¼š**
```
Checkpointerï¼ˆå…¨å±€ï¼‰
â”œâ”€ Thread: user-a
â”‚  â”œâ”€ Checkpoint 1 (step 1)
â”‚  â”œâ”€ Checkpoint 2 (step 2)
â”‚  â””â”€ Checkpoint 3 (step 3)
â”œâ”€ Thread: user-b
â”‚  â”œâ”€ Checkpoint 1
â”‚  â””â”€ Checkpoint 2
â””â”€ Thread: user-c
   â””â”€ Checkpoint 1
```

#### **5. å®é™…æ¡ˆä¾‹ï¼šå¤šè½®å¯¹è¯**

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

config = {"configurable": {"thread_id": "conversation-1"}}

# è½®æ¬¡ 1
graph.invoke({"messages": [HumanMessage("3 + 4 = ?")]}, config)
# ğŸ’¾ ä¿å­˜ï¼š{"messages": [HumanMessage("3 + 4 = ?"), AIMessage("7")]}

# è½®æ¬¡ 2ï¼ˆå‡ åˆ†é’Ÿåï¼‰
graph.invoke({"messages": [HumanMessage("ä¹˜ä»¥ 2")]}, config)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„çŠ¶æ€
# è¾“å…¥å˜æˆï¼š{"messages": [
#     HumanMessage("3 + 4 = ?"),
#     AIMessage("7"),
#     HumanMessage("ä¹˜ä»¥ 2")  â† æ–°æ¶ˆæ¯è¿½åŠ 
# ]}
# ğŸ’¾ ä¿å­˜ï¼šåŒ…å«æ‰€æœ‰å†å²çš„æ–°çŠ¶æ€
```

#### **6. Checkpointer ç±»å‹å¯¹æ¯”**

| ç±»å‹ | å­˜å‚¨ä½ç½® | æŒä¹…åŒ– | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-------|---------|------|------|
| **MemorySaver** | è¿›ç¨‹å†…å­˜ | âŒ | å¼€å‘æµ‹è¯• | å¿«é€Ÿã€ç®€å• | é‡å¯ä¸¢å¤± |
| **SqliteSaver** | SQLite æ–‡ä»¶ | âœ… | å•æœºç”Ÿäº§ | æŒä¹…åŒ–ã€æœ¬åœ° | ä¸æ”¯æŒåˆ†å¸ƒå¼ |
| **PostgresSaver** | PostgreSQL | âœ… | åˆ†å¸ƒå¼ç”Ÿäº§ | å¯æ‰©å±•ã€å¹¶å‘ | éœ€è¦æ•°æ®åº“ |
| **RedisSaver** | Redis | âœ… | é«˜æ€§èƒ½ç”Ÿäº§ | ä½å»¶è¿Ÿã€é«˜åå | éœ€è¦ Redis |

**ä»£ç ç¤ºä¾‹ï¼š**
```python
# å¼€å‘ç¯å¢ƒ
from langgraph.checkpoint.memory import MemorySaver
checkpointer = MemorySaver()

# ç”Ÿäº§ç¯å¢ƒ
from langgraph.checkpoint.postgres import PostgresSaver
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/db"
)

graph = builder.compile(checkpointer=checkpointer)
```

#### **7. æ—¶é—´æ—…è¡Œï¼šå›æº¯åˆ°å†å²çŠ¶æ€**

```python
# è¿è¡Œå¤šæ­¥
config = {"configurable": {"thread_id": "thread-1"}}
graph.invoke(input1, config)  # Checkpoint 1
graph.invoke(input2, config)  # Checkpoint 2
graph.invoke(input3, config)  # Checkpoint 3

# è·å–æ‰€æœ‰æ£€æŸ¥ç‚¹
checkpoints = list(graph.checkpointer.list(config))
for cp in checkpoints:
    print(f"Step {cp.metadata['step']}: {cp.state}")

# å›æº¯åˆ° Checkpoint 2
config_with_checkpoint = {
    "configurable": {
        "thread_id": "thread-1",
        "checkpoint_id": checkpoints[1].id  # ç¬¬ 2 ä¸ªæ£€æŸ¥ç‚¹
    }
}
graph.invoke(input4, config_with_checkpoint)
# ä» Checkpoint 2 çš„çŠ¶æ€ç»§ç»­æ‰§è¡Œ
```

#### **8. Checkpointer çš„å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰**

```python
class MemorySaver:
    def __init__(self):
        self.storage = {}  # {thread_id: [checkpoint1, checkpoint2, ...]}

    def save(self, config, state, metadata):
        """ä¿å­˜æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        checkpoint = {
            "id": generate_id(),
            "state": state,
            "metadata": metadata,
            "timestamp": now()
        }
        self.storage.setdefault(thread_id, []).append(checkpoint)

    def load(self, config):
        """åŠ è½½æœ€æ–°æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        checkpoints = self.storage.get(thread_id, [])
        return checkpoints[-1] if checkpoints else None

    def list(self, config):
        """åˆ—å‡ºæ‰€æœ‰æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        return self.storage.get(thread_id, [])
```

#### **9. ä½•æ—¶éœ€è¦ Checkpointer**

âœ… **éœ€è¦çš„åœºæ™¯ï¼š**
- å¤šè½®å¯¹è¯ç³»ç»Ÿï¼ˆèŠå¤©æœºå™¨äººï¼‰
- é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼ˆéœ€è¦ä¸­æ–­æ¢å¤ï¼‰
- éœ€è¦ä¸Šä¸‹æ–‡è¿ç»­æ€§ï¼ˆ"é‚£ä¸ª"ã€"å®ƒ"ç­‰æŒ‡ä»£ï¼‰
- è°ƒè¯•å’Œå®¡è®¡ï¼ˆæŸ¥çœ‹å†å²æ‰§è¡Œï¼‰
- A/B æµ‹è¯•ï¼ˆå¯¹æ¯”ä¸åŒç‰ˆæœ¬ï¼‰

âŒ **ä¸éœ€è¦çš„åœºæ™¯ï¼š**
- æ— çŠ¶æ€ APIï¼ˆæ¯æ¬¡è¯·æ±‚ç‹¬ç«‹ï¼‰
- æ‰¹å¤„ç†ä»»åŠ¡ï¼ˆä¸éœ€è¦è®°å¿†ï¼‰
- ä¸€æ¬¡æ€§æŸ¥è¯¢ï¼ˆæ— éœ€ä¿å­˜å†å²ï¼‰

#### **10. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„è®¾è®¡
config = {
    "configurable": {
        "thread_id": f"user-{user_id}-session-{session_id}",
        # ç»†ç²’åº¦éš”ç¦»ï¼Œä¾¿äºç®¡ç†
    }
}

# å®šæœŸæ¸…ç†
def cleanup_old_threads():
    cutoff = datetime.now() - timedelta(days=30)
    for thread_id in get_all_threads():
        if thread_last_accessed(thread_id) < cutoff:
            checkpointer.delete_thread({"configurable": {"thread_id": thread_id}})

# âŒ ä¸å¥½çš„è®¾è®¡
config = {"configurable": {"thread_id": "global"}}
# æ‰€æœ‰ç”¨æˆ·å…±äº«çŠ¶æ€ â†’ æ•°æ®æ··ä¹±
```

#### **å…³é”®è¦ç‚¹**
- **Checkpointer = è‡ªåŠ¨å¿«ç…§ç³»ç»Ÿ**
- **ä¿å­˜æ—¶æœºï¼šæ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå**
- **Thread = éš”ç¦»ä¸åŒä¼šè¯çš„çŠ¶æ€å®¹å™¨**
- **ç”¨é€”ï¼šå¤šè½®å¯¹è¯ã€çŠ¶æ€æŒä¹…åŒ–ã€æ—¶é—´æ—…è¡Œ**
- **ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨ PostgresSaver æˆ– RedisSaver**

</details>

---

### **é—®é¢˜ 5: æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰å¦‚ä½•å†³å®šè·¯ç”±ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

æ¡ä»¶è¾¹é€šè¿‡ **æ¡ä»¶å‡½æ•°** åŠ¨æ€å†³å®šä¸‹ä¸€ä¸ªæ‰§è¡Œçš„èŠ‚ç‚¹ï¼Œå®ç°å›¾çš„åˆ†æ”¯é€»è¾‘ã€‚

#### **1. åŸºç¡€æ¦‚å¿µ**

**æ™®é€šè¾¹ï¼ˆNormal Edgeï¼‰ï¼š** å›ºå®šè·¯ç”±
```python
builder.add_edge("node_a", "node_b")
# node_a æ€»æ˜¯æµå‘ node_b
```

**æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰ï¼š** åŠ¨æ€è·¯ç”±
```python
builder.add_conditional_edges("node_a", condition_func)
# node_a æ ¹æ® condition_func çš„è¿”å›å€¼å†³å®šä¸‹ä¸€æ­¥
```

#### **2. æ¡ä»¶å‡½æ•°çš„ç»“æ„**

```python
from typing import Literal

def condition_func(state: State) -> Literal["node_b", "node_c", "__end__"]:
    """
    æ¡ä»¶å‡½æ•°ï¼šåˆ†æçŠ¶æ€ï¼Œè¿”å›ç›®æ ‡èŠ‚ç‚¹åç§°

    å‚æ•°ï¼š
        state: å½“å‰å›¾çŠ¶æ€

    è¿”å›ï¼š
        str: ç›®æ ‡èŠ‚ç‚¹çš„åç§°ï¼ˆå¿…é¡»æ˜¯å·²æ·»åŠ çš„èŠ‚ç‚¹ï¼‰
    """
    # è¯»å–çŠ¶æ€
    value = state["some_field"]

    # å†³ç­–é€»è¾‘
    if value > 10:
        return "node_b"
    elif value > 0:
        return "node_c"
    else:
        return "__end__"  # æˆ–ä½¿ç”¨ END
```

**å…³é”®ç‰¹æ€§ï¼š**
- **è¾“å…¥ï¼š** å½“å‰çŠ¶æ€ï¼ˆState å¯¹è±¡ï¼‰
- **è¾“å‡ºï¼š** èŠ‚ç‚¹åç§°ï¼ˆå­—ç¬¦ä¸²ï¼‰
- **ç±»å‹æç¤ºï¼š** `Literal` æ˜ç¡®æ‰€æœ‰å¯èƒ½çš„è·¯ç”±

#### **3. å®Œæ•´ç¤ºä¾‹ï¼šåŠ¨æ€è·¯ç”±**

```python
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict
from typing import Literal

# å®šä¹‰çŠ¶æ€
class State(TypedDict):
    value: int
    path: list[str]

# å®šä¹‰èŠ‚ç‚¹
def input_node(state: State):
    return {"path": state["path"] + ["input"]}

def process_high(state: State):
    return {"path": state["path"] + ["high"]}

def process_low(state: State):
    return {"path": state["path"] + ["low"]}

def end_node(state: State):
    return {"path": state["path"] + ["end"]}

# æ¡ä»¶å‡½æ•°
def route_based_on_value(state: State) -> Literal["process_high", "process_low", "end"]:
    if state["value"] > 10:
        return "process_high"
    elif state["value"] > 0:
        return "process_low"
    else:
        return "end"

# æ„å»ºå›¾
builder = StateGraph(State)
builder.add_node("input", input_node)
builder.add_node("process_high", process_high)
builder.add_node("process_low", process_low)
builder.add_node("end", end_node)

builder.add_edge(START, "input")
builder.add_conditional_edges(
    "input",                  # æºèŠ‚ç‚¹
    route_based_on_value     # æ¡ä»¶å‡½æ•°
)
builder.add_edge("process_high", "end")
builder.add_edge("process_low", "end")
builder.add_edge("end", END)

graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

# æµ‹è¯•
result1 = graph.invoke({"value": 15, "path": []})
print(result1["path"])  # ['input', 'high', 'end']

result2 = graph.invoke({"value": 5, "path": []})
print(result2["path"])  # ['input', 'low', 'end']

result3 = graph.invoke({"value": -1, "path": []})
print(result3["path"])  # ['input', 'end']
```

#### **4. tools_conditionï¼šé¢„æ„å»ºçš„æ¡ä»¶å‡½æ•°**

LangGraph æä¾›äº†å¸¸ç”¨çš„ `tools_condition`ï¼š

```python
from langgraph.prebuilt import tools_condition

# å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰
def tools_condition(state: MessagesState) -> Literal["tools", "__end__"]:
    """æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·"""
    last_message = state["messages"][-1]

    # æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    if hasattr(last_message, "tool_calls") and last_message.tool_calls:
        return "tools"  # æœ‰å·¥å…·è°ƒç”¨ â†’ è·¯ç”±åˆ° tools èŠ‚ç‚¹
    else:
        return "__end__"  # æ— å·¥å…·è°ƒç”¨ â†’ ç»“æŸ
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**
```python
builder.add_conditional_edges("agent", tools_condition)

# ç­‰ä»·äºæ‰‹åŠ¨å†™ï¼š
def my_tools_condition(state):
    if state["messages"][-1].tool_calls:
        return "tools"
    return END

builder.add_conditional_edges("agent", my_tools_condition)
```

#### **5. é«˜çº§ç”¨æ³•ï¼šå¤šç›®æ ‡è·¯ç”±æ˜ å°„**

**æ–¹å¼ 1ï¼šè‡ªåŠ¨æ˜ å°„ï¼ˆæ¨èï¼‰**
```python
def condition(state) -> Literal["node_a", "node_b", "node_c"]:
    # è¿”å›å€¼è‡ªåŠ¨åŒ¹é…èŠ‚ç‚¹åç§°
    return "node_a"

builder.add_conditional_edges("source", condition)
# LangGraph è‡ªåŠ¨åˆ›å»ºè·¯ç”±ï¼šsource â†’ node_a/node_b/node_c
```

**æ–¹å¼ 2ï¼šæ˜¾å¼æ˜ å°„**
```python
def condition(state) -> str:
    return "path_1"  # è¿”å›è·¯å¾„åç§°ï¼ˆè€ŒéèŠ‚ç‚¹åç§°ï¼‰

builder.add_conditional_edges(
    "source",
    condition,
    {
        "path_1": "node_a",  # è·¯å¾„å â†’ èŠ‚ç‚¹å
        "path_2": "node_b",
        "default": "node_c"
    }
)
```

#### **6. å®æˆ˜æ¡ˆä¾‹ï¼šå®¢æœè·¯ç”±**

```python
from langchain_core.messages import HumanMessage

class CustomerServiceState(TypedDict):
    messages: list
    category: str

def classify_intent(state: CustomerServiceState) -> Literal["billing", "technical", "general"]:
    """æ ¹æ®ç”¨æˆ·æ¶ˆæ¯åˆ†ç±»æ„å›¾"""
    last_message = state["messages"][-1].content.lower()

    # ç®€å•å…³é”®è¯åŒ¹é…ï¼ˆå®é™…åº”ç”¨ä¸­ä½¿ç”¨ LLM åˆ†ç±»ï¼‰
    if "payment" in last_message or "bill" in last_message:
        return "billing"
    elif "error" in last_message or "bug" in last_message:
        return "technical"
    else:
        return "general"

# ä¸åŒéƒ¨é—¨çš„å¤„ç†èŠ‚ç‚¹
def billing_handler(state):
    return {"messages": [AIMessage("Billing team will assist you...")]}

def technical_handler(state):
    return {"messages": [AIMessage("Technical support will help...")]}

def general_handler(state):
    return {"messages": [AIMessage("How can I help you today?")]}

# æ„å»ºå›¾
builder = StateGraph(CustomerServiceState)
builder.add_node("classifier", lambda s: s)  # å ä½èŠ‚ç‚¹
builder.add_node("billing", billing_handler)
builder.add_node("technical", technical_handler)
builder.add_node("general", general_handler)

builder.add_edge(START, "classifier")
builder.add_conditional_edges("classifier", classify_intent)
builder.add_edge("billing", END)
builder.add_edge("technical", END)
builder.add_edge("general", END)

graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

# æµ‹è¯•
result = graph.invoke({
    "messages": [HumanMessage("I have a payment issue")],
    "category": ""
})
# è·¯ç”±ï¼šclassifier â†’ billing â†’ END
```

#### **7. æ¡ä»¶è¾¹çš„æ‰§è¡Œæµç¨‹**

```python
# 1. æºèŠ‚ç‚¹æ‰§è¡Œ
state = source_node(state)

# 2. è°ƒç”¨æ¡ä»¶å‡½æ•°
next_node_name = condition_func(state)

# 3. æ ¹æ®è¿”å›å€¼è·¯ç”±
if next_node_name == "node_a":
    state = node_a(state)
elif next_node_name == "node_b":
    state = node_b(state)
elif next_node_name == END:
    return state
else:
    raise ValueError(f"Unknown node: {next_node_name}")
```

#### **8. å¸¸è§é”™è¯¯ä¸è°ƒè¯•**

**é”™è¯¯ 1ï¼šè¿”å›ä¸å­˜åœ¨çš„èŠ‚ç‚¹å**
```python
def bad_condition(state) -> str:
    return "non_existent_node"  # âŒ è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰è¢«æ·»åŠ 

builder.add_conditional_edges("source", bad_condition)
# è¿è¡Œæ—¶é”™è¯¯ï¼šNode 'non_existent_node' not found
```

**ä¿®å¤ï¼š**
```python
# æ–¹å¼ 1ï¼šç¡®ä¿èŠ‚ç‚¹å­˜åœ¨
builder.add_node("non_existent_node", some_func)

# æ–¹å¼ 2ï¼šä½¿ç”¨ Literal ç±»å‹æ£€æŸ¥
def good_condition(state) -> Literal["node_a", "node_b"]:
    return "node_a"  # IDE ä¼šæç¤ºå¯ç”¨é€‰é¡¹
```

**é”™è¯¯ 2ï¼šå¿˜è®°æ·»åŠ æ‰€æœ‰å¯èƒ½è·¯å¾„çš„è¾¹**
```python
def condition(state) -> Literal["node_a", "node_b", "node_c"]:
    return "node_a"

builder.add_conditional_edges("source", condition)
builder.add_edge("node_a", END)
builder.add_edge("node_b", END)
# âŒ å¿˜è®°æ·»åŠ  node_c â†’ END

# å¦‚æœæ¡ä»¶è¿”å› "node_c"ï¼Œä¼šæŠ¥é”™
```

**è°ƒè¯•æŠ€å·§ï¼š**
```python
def debug_condition(state):
    result = condition(state)
    print(f"Routing from {current_node} to {result}")
    print(f"State: {state}")
    return result

builder.add_conditional_edges("source", debug_condition)
```

#### **9. æ€§èƒ½ä¼˜åŒ–**

```python
# âŒ ä¸å¥½çš„å®è·µï¼šæ¡ä»¶å‡½æ•°ä¸­è°ƒç”¨ LLM
def expensive_condition(state):
    # æ¯æ¬¡è·¯ç”±éƒ½è°ƒç”¨ LLMï¼Œæˆæœ¬é«˜
    intent = llm.invoke("Classify: " + state["message"])
    return intent

# âœ… å¥½çš„å®è·µï¼šåœ¨èŠ‚ç‚¹ä¸­å®Œæˆåˆ†ç±»
def classify_node(state):
    intent = llm.invoke("Classify: " + state["message"])
    return {"intent": intent}

def simple_condition(state):
    # åªè¯»å–å·²æœ‰çŠ¶æ€ï¼Œæ— é¢å¤–å¼€é”€
    return state["intent"]

builder.add_node("classify", classify_node)
builder.add_conditional_edges("classify", simple_condition)
```

#### **10. ä¸æ™®é€šè¾¹çš„å¯¹æ¯”**

| ç‰¹æ€§ | æ™®é€šè¾¹ | æ¡ä»¶è¾¹ |
|------|-------|--------|
| **è·¯ç”±æ–¹å¼** | å›ºå®š | åŠ¨æ€ |
| **æ·»åŠ æ–¹æ³•** | `add_edge(A, B)` | `add_conditional_edges(A, func)` |
| **ä½¿ç”¨åœºæ™¯** | çº¿æ€§æµç¨‹ | åˆ†æ”¯é€»è¾‘ |
| **å¤æ‚åº¦** | ç®€å• | ä¸­ç­‰ |
| **ç¤ºä¾‹** | `START â†’ node1 â†’ END` | `node1 â†’ [æ¡ä»¶åˆ¤æ–­] â†’ node2/node3` |

#### **å…³é”®è¦ç‚¹**
- **æ¡ä»¶è¾¹ = åŠ¨æ€è·¯ç”±æœºåˆ¶**
- **æ¡ä»¶å‡½æ•°ï¼šè¾“å…¥çŠ¶æ€ â†’ è¾“å‡ºèŠ‚ç‚¹å**
- **tools_conditionï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·**
- **ä½¿ç”¨ Literal ç±»å‹æç¤ºæé«˜å®‰å…¨æ€§**
- **æ¡ä»¶é€»è¾‘åº”ç®€å•å¿«é€Ÿï¼Œé¿å…å¤æ‚è®¡ç®—**

</details>

---

---

### **é—®é¢˜ 6: å¦‚ä½•å®ç°ä¸€ä¸ªå¸¦å¤šä¸ªå·¥å…·çš„ Routerï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å®ç°å¤šå·¥å…· Router çš„å…³é”®æ˜¯ **æ­£ç¡®ç»‘å®šæ‰€æœ‰å·¥å…·** å’Œ **ä½¿ç”¨ ToolNode è‡ªåŠ¨è·¯ç”±**ã€‚

#### **1. å®Œæ•´ä»£ç ç¤ºä¾‹**

```python
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.prebuilt import ToolNode, tools_condition

# å®šä¹‰å¤šä¸ªå·¥å…·
@tool
def add(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

@tool
def multiply(a: int, b: int) -> int:
    """Multiply two numbers."""
    return a * b

@tool
def divide(a: float, b: float) -> float:
    """Divide a by b."""
    if b == 0:
        return "Error: Division by zero"
    return a / b

@tool
def search_web(query: str) -> str:
    """Search the web for information."""
    # å®é™…å®ç°ä¸­è°ƒç”¨æœç´¢ API
    return f"Search results for: {query}"

# æ”¶é›†æ‰€æœ‰å·¥å…·
tools = [add, multiply, divide, search_web]

# åˆ›å»º LLM å¹¶ç»‘å®šå·¥å…·
llm = ChatOpenAI(model="gpt-4")
llm_with_tools = llm.bind_tools(tools)

# å®šä¹‰èŠ‚ç‚¹
def call_model(state: MessagesState):
    response = llm_with_tools.invoke(state["messages"])
    return {"messages": [response]}

# æ„å»ºå›¾
builder = StateGraph(MessagesState)
builder.add_node("llm", call_model)
builder.add_node("tools", ToolNode(tools))  # â† ä¼ å…¥æ‰€æœ‰å·¥å…·

builder.add_edge(START, "llm")
builder.add_conditional_edges("llm", tools_condition)
builder.add_edge("tools", END)

graph = builder.compile()
```

#### **2. å…³é”®æŠ€æœ¯ç‚¹**

**æŠ€æœ¯ç‚¹ 1ï¼š@tool è£…é¥°å™¨**

```python
from langchain_core.tools import tool

@tool
def my_function(param: type) -> return_type:
    """Clear description of what this tool does.

    Args:
        param: Description of parameter
    """
    return result
```

**è‡ªåŠ¨è½¬æ¢ä¸ºï¼š**
- å·¥å…·åç§°ï¼šå‡½æ•°åï¼ˆ`my_function`ï¼‰
- å·¥å…·æè¿°ï¼šDocstring ç¬¬ä¸€è¡Œ
- å‚æ•°æ¨¡å¼ï¼šä»ç±»å‹æ³¨è§£ç”Ÿæˆ
- è°ƒç”¨æ¥å£ï¼šä¿æŒåŸå‡½æ•°é€»è¾‘

**æŠ€æœ¯ç‚¹ 2ï¼šToolNode è‡ªåŠ¨è·¯ç”±**

```python
ToolNode(tools)
# å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰ï¼š
class ToolNode:
    def __init__(self, tools):
        self.tools_by_name = {t.name: t for t in tools}

    def __call__(self, state):
        last_message = state["messages"][-1]
        results = []

        for tool_call in last_message.tool_calls:
            tool = self.tools_by_name[tool_call["name"]]  # è‡ªåŠ¨åŒ¹é…
            result = tool.invoke(tool_call["args"])
            results.append(ToolMessage(
                content=str(result),
                tool_call_id=tool_call["id"]
            ))

        return {"messages": results}
```

#### **3. æµ‹è¯•ä¸åŒå·¥å…·**

```python
from langchain_core.messages import HumanMessage

# æµ‹è¯• 1ï¼šæ•°å­¦è®¡ç®—
result1 = graph.invoke({
    "messages": [HumanMessage("What is 15 + 23?")]
})
# LLM é€‰æ‹© add(15, 23) â†’ è¿”å› 38

# æµ‹è¯• 2ï¼šä¹˜æ³•
result2 = graph.invoke({
    "messages": [HumanMessage("Multiply 7 by 8")]
})
# LLM é€‰æ‹© multiply(7, 8) â†’ è¿”å› 56

# æµ‹è¯• 3ï¼šç½‘ç»œæœç´¢
result3 = graph.invoke({
    "messages": [HumanMessage("Search for Python tutorials")]
})
# LLM é€‰æ‹© search_web("Python tutorials")

# æµ‹è¯• 4ï¼šç»„åˆæŸ¥è¯¢
result4 = graph.invoke({
    "messages": [HumanMessage("Calculate 100 / 4")]
})
# LLM é€‰æ‹© divide(100, 4) â†’ è¿”å› 25.0
```

#### **4. LLM å¦‚ä½•é€‰æ‹©å·¥å…·ï¼Ÿ**

LLM æ¥æ”¶åˆ°çš„å·¥å…·ä¿¡æ¯ï¼š

```json
{
  "tools": [
    {
      "name": "add",
      "description": "Add two numbers together.",
      "parameters": {
        "type": "object",
        "properties": {
          "a": {"type": "integer"},
          "b": {"type": "integer"}
        }
      }
    },
    {
      "name": "multiply",
      "description": "Multiply two numbers.",
      "parameters": {
        "type": "object",
        "properties": {
          "a": {"type": "integer"},
          "b": {"type": "integer"}
        }
      }
    },
    ...
  ]
}
```

**LLM å†³ç­–è¿‡ç¨‹ï¼š**
```
ç”¨æˆ·è¾“å…¥: "What is 15 + 23?"
         â†“
LLM åˆ†æ: "è¿™æ˜¯åŠ æ³•é—®é¢˜"
         â†“
æŸ¥æ‰¾å·¥å…·: "add" çš„æè¿°åŒ¹é…
         â†“
æå–å‚æ•°: a=15, b=23
         â†“
è¿”å›: tool_calls=[{"name": "add", "args": {"a": 15, "b": 23}}]
```

#### **5. é”™è¯¯å¤„ç†**

```python
@tool
def divide(a: float, b: float) -> float:
    """Divide a by b. Returns error message if b is zero."""
    try:
        if b == 0:
            return "Error: Cannot divide by zero"
        return a / b
    except Exception as e:
        return f"Error: {str(e)}"

# æµ‹è¯•é”™è¯¯æƒ…å†µ
result = graph.invoke({
    "messages": [HumanMessage("What is 10 divided by 0?")]
})
# å·¥å…·è¿”å›: "Error: Cannot divide by zero"
# LLM æ”¶åˆ°é”™è¯¯ä¿¡æ¯ï¼Œå¯ä»¥ç»™å‡ºå‹å¥½å›å¤
```

#### **6. å·¥å…·åˆ†ç±»ç®¡ç†**

å¯¹äºå¤§é‡å·¥å…·ï¼Œå¯ä»¥åˆ†ç±»ç®¡ç†ï¼š

```python
# æ•°å­¦å·¥å…·
math_tools = [add, multiply, divide]

# æœç´¢å·¥å…·
search_tools = [search_web, search_database]

# æ–‡ä»¶å·¥å…·
file_tools = [read_file, write_file]

# åœºæ™¯ 1ï¼šæ•°å­¦åŠ©æ‰‹ï¼ˆåªç»‘å®šæ•°å­¦å·¥å…·ï¼‰
math_llm = llm.bind_tools(math_tools)

# åœºæ™¯ 2ï¼šé€šç”¨åŠ©æ‰‹ï¼ˆç»‘å®šæ‰€æœ‰å·¥å…·ï¼‰
general_llm = llm.bind_tools(math_tools + search_tools + file_tools)
```

#### **7. åŠ¨æ€å·¥å…·åŠ è½½**

```python
def call_model_dynamic(state: MessagesState):
    # æ ¹æ®ç”¨æˆ·æ¶ˆæ¯åŠ¨æ€é€‰æ‹©å·¥å…·
    last_message = state["messages"][-1].content.lower()

    if "calculate" in last_message or "math" in last_message:
        tools = math_tools
    elif "search" in last_message:
        tools = search_tools
    else:
        tools = math_tools + search_tools  # é»˜è®¤å…¨éƒ¨

    llm_with_selected_tools = llm.bind_tools(tools)
    response = llm_with_selected_tools.invoke(state["messages"])
    return {"messages": [response]}
```

#### **8. å·¥å…·è°ƒç”¨ç»Ÿè®¡**

```python
from collections import Counter

class ToolNodeWithStats(ToolNode):
    def __init__(self, tools):
        super().__init__(tools)
        self.call_stats = Counter()

    def __call__(self, state):
        last_message = state["messages"][-1]

        # ç»Ÿè®¡å·¥å…·ä½¿ç”¨
        for tool_call in last_message.tool_calls:
            self.call_stats[tool_call["name"]] += 1

        # æ‰§è¡Œå·¥å…·
        result = super().__call__(state)

        # æ‰“å°ç»Ÿè®¡
        print(f"Tool usage: {dict(self.call_stats)}")
        return result

# ä½¿ç”¨
tool_node = ToolNodeWithStats(tools)
builder.add_node("tools", tool_node)
```

#### **9. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„å·¥å…·å®šä¹‰
@tool
def calculate_discount(price: float, discount_percent: float) -> float:
    """Calculate the final price after applying a discount.

    Args:
        price: Original price in dollars
        discount_percent: Discount percentage (0-100)

    Returns:
        Final price after discount
    """
    if not (0 <= discount_percent <= 100):
        return "Error: Discount must be between 0 and 100"
    return price * (1 - discount_percent / 100)

# âŒ ä¸å¥½çš„å·¥å…·å®šä¹‰
@tool
def calc(p, d):  # æ— ç±»å‹æ³¨è§£
    """Calculate."""  # æè¿°ä¸æ¸…æ¥š
    return p * d  # é€»è¾‘ä¸æ˜ç¡®
```

#### **10. å®Œæ•´ç¤ºä¾‹ï¼šå¤šåŠŸèƒ½åŠ©æ‰‹**

```python
from langchain_core.tools import tool

# å·¥å…·é›†åˆ
@tool
def get_weather(city: str) -> str:
    """Get current weather for a city."""
    return f"Weather in {city}: Sunny, 72Â°F"

@tool
def book_flight(origin: str, destination: str, date: str) -> str:
    """Book a flight ticket."""
    return f"Flight booked: {origin} â†’ {destination} on {date}"

@tool
def translate(text: str, target_lang: str) -> str:
    """Translate text to target language."""
    return f"[{target_lang}] {text}"

tools = [get_weather, book_flight, translate, add, multiply]

# æ„å»ºå›¾
llm_with_tools = ChatOpenAI(model="gpt-4").bind_tools(tools)

def assistant(state: MessagesState):
    return {"messages": [llm_with_tools.invoke(state["messages"])]}

builder = StateGraph(MessagesState)
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tools_condition)
builder.add_edge("tools", END)

graph = builder.compile()

# ğŸ¨ å¯è§†åŒ–å›¾ç»“æ„
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))

# æµ‹è¯•å¤šæ ·åŒ–æŸ¥è¯¢
queries = [
    "What's the weather in New York?",
    "Book a flight from LA to NYC on March 15",
    "Translate 'Hello' to Spanish",
    "What is 25 times 4?"
]

for query in queries:
    result = graph.invoke({"messages": [HumanMessage(query)]})
    print(f"Query: {query}")
    print(f"Response: {result['messages'][-1].content}\n")
```

#### **å…³é”®è¦ç‚¹**
- **å¤šå·¥å…·ç»‘å®šï¼š** `llm.bind_tools([tool1, tool2, ...])`
- **ToolNode è‡ªåŠ¨è·¯ç”±ï¼š** æ ¹æ® tool_calls ä¸­çš„ name åŒ¹é…å·¥å…·
- **å·¥å…·å®šä¹‰å…³é”®ï¼š** æ¸…æ™°çš„ Docstring + ç±»å‹æ³¨è§£
- **LLM è‡ªåŠ¨é€‰æ‹©ï¼š** åŸºäºæè¿°å’Œå‚æ•°åŒ¹é…
- **å¯æ‰©å±•æ€§ï¼š** è½»æ¾æ·»åŠ æ–°å·¥å…·ï¼Œæ— éœ€ä¿®æ”¹å›¾ç»“æ„

</details>

---

### **é—®é¢˜ 7: å¦‚ä½•è®© Agent é¿å…æ— é™å¾ªç¯ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

é˜²æ­¢ Agent æ— é™å¾ªç¯éœ€è¦ **è®¾ç½®é€’å½’é™åˆ¶** å’Œ **æ™ºèƒ½åœæ­¢æ¡ä»¶**ã€‚

#### **1. é—®é¢˜ï¼šä¸ºä»€ä¹ˆä¼šå‡ºç°æ— é™å¾ªç¯ï¼Ÿ**

Agent çš„å¾ªç¯ç»“æ„ï¼š

```python
builder.add_edge("tools", "agent")  # å·¥å…·æ‰§è¡Œåå›åˆ° agent

# æµç¨‹ï¼š
# agent â†’ tools â†’ agent â†’ tools â†’ agent â†’ ...
```

**å¯èƒ½å¯¼è‡´æ— é™å¾ªç¯çš„åœºæ™¯ï¼š**
- LLM ä¸€ç›´è®¤ä¸ºéœ€è¦è°ƒç”¨å·¥å…·
- å·¥å…·è¿”å›çš„ç»“æœæ— æ³•è®© LLM æ»¡æ„
- LLM é™·å…¥"æ€è€ƒ-è¡ŒåŠ¨"æ­»å¾ªç¯

#### **2. æ–¹æ³• 1ï¼šä½¿ç”¨ recursion_limit**

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(
    checkpointer=memory,
    recursion_limit=10  # â† æœ€å¤šæ‰§è¡Œ 10 æ¬¡èŠ‚ç‚¹
)

# æµ‹è¯•
try:
    result = graph.invoke({"messages": [HumanMessage("test")]})
except RecursionError:
    print("è¾¾åˆ°é€’å½’é™åˆ¶ï¼")
```

**å·¥ä½œåŸç†ï¼š**
```
Step 1: agent
Step 2: tools
Step 3: agent
...
Step 10: agent
Step 11: âŒ RecursionError: è¾¾åˆ°é™åˆ¶
```

#### **3. æ–¹æ³• 2ï¼šåœ¨çŠ¶æ€ä¸­è®¡æ•°**

```python
from typing import Annotated
import operator

class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    iterations: Annotated[int, operator.add]  # ç´¯åŠ è®¡æ•°å™¨

def agent(state: AgentState):
    # æ£€æŸ¥è¿­ä»£æ¬¡æ•°
    current_iterations = state.get("iterations", 0)

    if current_iterations >= 10:
        return {
            "messages": [AIMessage("å·²è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œåœæ­¢æ‰§è¡Œã€‚")],
            "iterations": 0  # é‡ç½®è®¡æ•°å™¨
        }

    # æ­£å¸¸æ‰§è¡Œ
    response = llm_with_tools.invoke(state["messages"])
    return {
        "messages": [response],
        "iterations": 1  # æ¯æ¬¡å¢åŠ  1
    }

# åˆå§‹çŠ¶æ€
initial_state = {
    "messages": [HumanMessage("Start")],
    "iterations": 0
}

result = graph.invoke(initial_state)
```

#### **4. æ–¹æ³• 3ï¼šæ™ºèƒ½åœæ­¢æ¡ä»¶**

```python
def tools_condition_with_limit(state: AgentState) -> Literal["tools", "__end__"]:
    """å¢å¼ºç‰ˆ tools_conditionï¼ŒåŒ…å«å¤šé‡åœæ­¢æ¡ä»¶"""

    # æ¡ä»¶ 1ï¼šæ£€æŸ¥è¿­ä»£æ¬¡æ•°
    if state.get("iterations", 0) >= 15:
        return "__end__"

    # æ¡ä»¶ 2ï¼šæ£€æŸ¥æ¶ˆæ¯æ•°é‡ï¼ˆé˜²æ­¢å¯¹è¯è¿‡é•¿ï¼‰
    if len(state["messages"]) > 50:
        return "__end__"

    # æ¡ä»¶ 3ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    last_message = state["messages"][-1]
    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        return "__end__"

    # æ¡ä»¶ 4ï¼šæ£€æŸ¥æ˜¯å¦é‡å¤è°ƒç”¨ç›¸åŒå·¥å…·
    if len(last_message.tool_calls) > 0:
        tool_name = last_message.tool_calls[0]["name"]
        # æ£€æŸ¥æœ€è¿‘ 3 æ¬¡æ˜¯å¦éƒ½è°ƒç”¨åŒä¸€å·¥å…·
        recent_calls = []
        for msg in state["messages"][-6:]:  # æœ€è¿‘ 3 è½®ï¼ˆæ¯è½® 2 æ¡æ¶ˆæ¯ï¼‰
            if hasattr(msg, "tool_calls") and msg.tool_calls:
                recent_calls.append(msg.tool_calls[0]["name"])

        if recent_calls.count(tool_name) >= 3:
            print(f"è­¦å‘Šï¼šå·¥å…· {tool_name} è¢«é‡å¤è°ƒç”¨ï¼Œåœæ­¢æ‰§è¡Œ")
            return "__end__"

    return "tools"

# ä½¿ç”¨å¢å¼ºç‰ˆæ¡ä»¶
builder.add_conditional_edges("agent", tools_condition_with_limit)
```

#### **5. æ–¹æ³• 4ï¼šè¶…æ—¶æœºåˆ¶**

```python
import time
from datetime import datetime, timedelta

class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    start_time: float

def agent_with_timeout(state: AgentState):
    # è®°å½•å¼€å§‹æ—¶é—´
    if "start_time" not in state:
        state["start_time"] = time.time()

    # æ£€æŸ¥è¶…æ—¶ï¼ˆä¾‹å¦‚ï¼šæœ€å¤šè¿è¡Œ 60 ç§’ï¼‰
    elapsed = time.time() - state["start_time"]
    if elapsed > 60:
        return {
            "messages": [AIMessage("æ‰§è¡Œè¶…æ—¶ï¼Œå·²åœæ­¢ã€‚")],
            "start_time": state["start_time"]
        }

    # æ­£å¸¸æ‰§è¡Œ
    response = llm_with_tools.invoke(state["messages"])
    return {
        "messages": [response],
        "start_time": state["start_time"]
    }
```

#### **6. æ–¹æ³• 5ï¼šå·¥å…·è°ƒç”¨æˆæœ¬é™åˆ¶**

```python
class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    total_tokens: int

def agent_with_budget(state: AgentState):
    # æ£€æŸ¥ token ä½¿ç”¨é‡
    total_tokens = state.get("total_tokens", 0)
    max_tokens = 10000

    if total_tokens >= max_tokens:
        return {
            "messages": [AIMessage(f"å·²è¾¾åˆ° token é™åˆ¶ ({max_tokens})ï¼Œåœæ­¢æ‰§è¡Œã€‚")],
            "total_tokens": total_tokens
        }

    # è°ƒç”¨ LLM
    response = llm_with_tools.invoke(state["messages"])

    # ç»Ÿè®¡ token
    tokens_used = response.response_metadata.get("token_usage", {}).get("total_tokens", 0)

    return {
        "messages": [response],
        "total_tokens": total_tokens + tokens_used
    }
```

#### **7. æ–¹æ³• 6ï¼šLLM æç¤ºè¯ä¼˜åŒ–**

```python
from langchain_core.messages import SystemMessage

system_prompt = SystemMessage(content="""
You are a helpful assistant. Follow these rules:

1. **Efficiency**: Minimize the number of tool calls needed
2. **Completion**: Once you have enough information, provide a final answer
3. **No Loops**: If a tool fails twice, stop trying and explain the issue
4. **Token Awareness**: Keep responses concise

When you have completed the task, respond with a final answer WITHOUT tool calls.
""")

def agent_with_prompt(state: MessagesState):
    messages = [system_prompt] + state["messages"]
    response = llm_with_tools.invoke(messages)
    return {"messages": [response]}
```

#### **8. å®Œæ•´ç¤ºä¾‹ï¼šç»¼åˆé˜²æŠ¤**

```python
from typing import Annotated
import operator
import time

class RobustAgentState(TypedDict):
    messages: Annotated[list, add_messages]
    iterations: Annotated[int, operator.add]
    total_tokens: int
    start_time: float

def robust_agent(state: RobustAgentState):
    """å¸¦å¤šé‡ä¿æŠ¤çš„ Agent"""

    # åˆå§‹åŒ–
    if "start_time" not in state:
        state["start_time"] = time.time()

    iterations = state.get("iterations", 0)
    total_tokens = state.get("total_tokens", 0)
    elapsed = time.time() - state["start_time"]

    # ä¿æŠ¤ 1ï¼šè¿­ä»£æ¬¡æ•°
    if iterations >= 10:
        return {
            "messages": [AIMessage("è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•° (10)ã€‚")],
            "iterations": 0
        }

    # ä¿æŠ¤ 2ï¼šæ‰§è¡Œæ—¶é—´
    if elapsed > 120:  # 2 åˆ†é’Ÿ
        return {
            "messages": [AIMessage("æ‰§è¡Œè¶…æ—¶ (120s)ã€‚")],
            "iterations": 0
        }

    # ä¿æŠ¤ 3ï¼šToken é¢„ç®—
    if total_tokens >= 50000:
        return {
            "messages": [AIMessage("è¾¾åˆ° token é™åˆ¶ (50000)ã€‚")],
            "iterations": 0
        }

    # æ­£å¸¸æ‰§è¡Œ
    try:
        response = llm_with_tools.invoke(state["messages"])
        tokens_used = response.response_metadata.get("token_usage", {}).get("total_tokens", 0)

        return {
            "messages": [response],
            "iterations": 1,
            "total_tokens": tokens_used
        }
    except Exception as e:
        return {
            "messages": [AIMessage(f"æ‰§è¡Œé”™è¯¯ï¼š{str(e)}")],
            "iterations": 0
        }

def robust_tools_condition(state: RobustAgentState):
    """å¢å¼ºç‰ˆåœæ­¢æ¡ä»¶"""
    last_message = state["messages"][-1]

    # æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        return "__end__"

    # æ£€æŸ¥ä¿æŠ¤æ¡ä»¶
    if state.get("iterations", 0) >= 10:
        return "__end__"

    return "tools"

# æ„å»ºå›¾
builder = StateGraph(RobustAgentState)
builder.add_node("agent", robust_agent)
builder.add_node("tools", ToolNode(tools))
builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", robust_tools_condition)
builder.add_edge("tools", "agent")

# ä½¿ç”¨ recursion_limit ä½œä¸ºæœ€åé˜²çº¿
graph = builder.compile(recursion_limit=25)
```

#### **9. ç›‘æ§å’Œè°ƒè¯•**

```python
def agent_with_logging(state: AgentState):
    iterations = state.get("iterations", 0)
    print(f"[Iteration {iterations}] Agent executing...")

    response = llm_with_tools.invoke(state["messages"])

    # è®°å½•å·¥å…·è°ƒç”¨
    if hasattr(response, "tool_calls") and response.tool_calls:
        for tc in response.tool_calls:
            print(f"  â†’ Calling tool: {tc['name']}")
    else:
        print(f"  â†’ Generating final response")

    return {
        "messages": [response],
        "iterations": 1
    }
```

#### **10. æœ€ä½³å®è·µæ€»ç»“**

| æ–¹æ³• | ä¼˜å…ˆçº§ | é€‚ç”¨åœºæ™¯ | å®ç°éš¾åº¦ |
|------|-------|---------|---------|
| **recursion_limit** | å¿…é¡» | æ‰€æœ‰ Agent | ç®€å• |
| **è¿­ä»£è®¡æ•°** | æ¨è | é•¿æ—¶é—´è¿è¡Œçš„ Agent | ä¸­ç­‰ |
| **è¶…æ—¶æœºåˆ¶** | æ¨è | ç”Ÿäº§ç¯å¢ƒ | ä¸­ç­‰ |
| **Token é™åˆ¶** | å¯é€‰ | æˆæœ¬æ•æ„Ÿåœºæ™¯ | ä¸­ç­‰ |
| **æ™ºèƒ½åœæ­¢æ¡ä»¶** | æ¨è | å¤æ‚ Agent | è¾ƒéš¾ |
| **æç¤ºè¯ä¼˜åŒ–** | å¿…é¡» | æ‰€æœ‰ Agent | ç®€å• |

**æ¨èé…ç½®ï¼š**
```python
# 1. æç¤ºè¯æ˜ç¡®æŒ‡ç¤ºä½•æ—¶åœæ­¢
# 2. recursion_limit=20ï¼ˆåˆç†ä¸Šé™ï¼‰
# 3. çŠ¶æ€ä¸­è·Ÿè¸ªè¿­ä»£æ¬¡æ•°
# 4. æ¡ä»¶å‡½æ•°æ£€æŸ¥å¼‚å¸¸æ¨¡å¼
# 5. ç”Ÿäº§ç¯å¢ƒæ·»åŠ è¶…æ—¶å’Œ token é™åˆ¶
```

#### **å…³é”®è¦ç‚¹**
- **å¤šå±‚é˜²æŠ¤ï¼š** ä¸è¦ä¾èµ–å•ä¸€æœºåˆ¶
- **recursion_limitï¼š** æœ€åŸºæœ¬çš„ä¿æŠ¤
- **çŠ¶æ€è®¡æ•°ï¼š** æ›´ç²¾ç»†çš„æ§åˆ¶
- **æ™ºèƒ½æ¡ä»¶ï¼š** æ£€æµ‹å¼‚å¸¸å¾ªç¯æ¨¡å¼
- **ç›‘æ§æ—¥å¿—ï¼š** ä¾¿äºè°ƒè¯•å’Œä¼˜åŒ–

</details>

---

### **é—®é¢˜ 8: å¦‚ä½•å®ç°è·¨ä¼šè¯çš„å¯¹è¯è®°å¿†ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

è·¨ä¼šè¯å¯¹è¯è®°å¿†é€šè¿‡ **Checkpointer + Thread ID** å®ç°çŠ¶æ€æŒä¹…åŒ–å’Œæ¢å¤ã€‚

#### **1. æ ¸å¿ƒæ¦‚å¿µ**

**ä¼šè¯ï¼ˆSessionï¼‰ï¼š** ç”¨æˆ·ä¸ Agent çš„ä¸€æ¬¡å®Œæ•´äº¤äº’è¿‡ç¨‹
**è·¨ä¼šè¯è®°å¿†ï¼š** åœ¨å¤šæ¬¡ç‹¬ç«‹ä¼šè¯ä¹‹é—´ä¿æŒç”¨æˆ·ä¿¡æ¯å’Œå¯¹è¯å†å²

```
ä¼šè¯ 1 (ä»Šå¤©ä¸Šåˆ)
ç”¨æˆ·: "æˆ‘çš„è®¢å•å·æ˜¯ 12345"
Agent: "å¥½çš„ï¼Œè®¢å• 12345 å·²è®°å½•"

ä¼šè¯ 2 (ä»Šå¤©ä¸‹åˆï¼Œæ–°çš„æµè§ˆå™¨æ ‡ç­¾)
ç”¨æˆ·: "é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ"
Agent: "æ‚¨çš„è®¢å• 12345 å·²äºä»Šå¤©ä¸Šåˆå‘è´§"  âœ… è®°ä½äº†è®¢å•å·
```

#### **2. åŸºç¡€å®ç°ï¼šMemorySaver**

```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import StateGraph, MessagesState

# åˆ›å»ºæ£€æŸ¥ç‚¹å™¨
memory = MemorySaver()

# ç¼–è¯‘å›¾
graph = builder.compile(checkpointer=memory)

# ä¼šè¯ 1
config = {"configurable": {"thread_id": "user-123"}}
result1 = graph.invoke(
    {"messages": [HumanMessage("æˆ‘çš„è®¢å•å·æ˜¯ 12345")]},
    config
)

# ä¼šè¯ 2ï¼ˆç¨åï¼ŒåŒä¸€ thread_idï¼‰
result2 = graph.invoke(
    {"messages": [HumanMessage("é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ")]},
    config
)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„å¯¹è¯å†å²
```

#### **3. ç”Ÿäº§å®ç°ï¼šPostgreSQL æŒä¹…åŒ–**

```python
from langgraph.checkpoint.postgres import PostgresSaver
import psycopg2

# è¿æ¥æ•°æ®åº“
conn_string = "postgresql://user:password@localhost:5432/langgraph_db"
checkpointer = PostgresSaver.from_conn_string(conn_string)

# ç¼–è¯‘å›¾ï¼ˆä¸ MemorySaver æ¥å£å®Œå…¨ç›¸åŒï¼‰
graph = builder.compile(checkpointer=checkpointer)

# ä½¿ç”¨æ–¹å¼å®Œå…¨ç›¸åŒ
config = {"configurable": {"thread_id": "user-123"}}
result = graph.invoke({"messages": [...]}, config)
```

**PostgreSQL è¡¨ç»“æ„ï¼š**
```sql
CREATE TABLE checkpoints (
    thread_id TEXT,
    checkpoint_id TEXT PRIMARY KEY,
    parent_id TEXT,
    created_at TIMESTAMP,
    state JSONB,  -- å®Œæ•´çŠ¶æ€æ•°æ®
    metadata JSONB
);

CREATE INDEX idx_thread_id ON checkpoints(thread_id);
```

#### **4. Thread ID è®¾è®¡æ¨¡å¼**

**æ¨¡å¼ 1ï¼šæŒ‰ç”¨æˆ·éš”ç¦»**
```python
def get_config(user_id: str):
    return {"configurable": {"thread_id": f"user-{user_id}"}}

# ç”¨æˆ· A
config_a = get_config("alice")
graph.invoke(input, config_a)

# ç”¨æˆ· Bï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
config_b = get_config("bob")
graph.invoke(input, config_b)
```

**æ¨¡å¼ 2ï¼šæŒ‰ä¼šè¯éš”ç¦»**
```python
import uuid

def create_new_session(user_id: str):
    session_id = str(uuid.uuid4())
    return {"configurable": {"thread_id": f"{user_id}-{session_id}"}}

# ç”¨æˆ·å¼€å§‹æ–°å¯¹è¯
config = create_new_session("alice")
# thread_id: "alice-4f8d3c2a-..."
```

**æ¨¡å¼ 3ï¼šæŒ‰åŠŸèƒ½éš”ç¦»**
```python
def get_config(user_id: str, context: str):
    return {"configurable": {"thread_id": f"{user_id}-{context}"}}

# å®¢æœå¯¹è¯
support_config = get_config("alice", "support")

# è®¢å•æŸ¥è¯¢
order_config = get_config("alice", "order")

# ä¸¤ä¸ªç‹¬ç«‹çš„å¯¹è¯çº¿ç¨‹
```

#### **5. æ‰©å±•çŠ¶æ€ï¼šç”¨æˆ·åå¥½è®°å¿†**

```python
class UserState(TypedDict):
    messages: Annotated[list, add_messages]
    user_id: str
    preferences: dict  # ç”¨æˆ·åå¥½
    conversation_count: Annotated[int, operator.add]

def agent_with_preferences(state: UserState):
    # è¯»å–ç”¨æˆ·åå¥½
    prefs = state.get("preferences", {})
    style = prefs.get("response_style", "formal")

    # æ ¹æ®åå¥½è°ƒæ•´ç³»ç»Ÿæç¤º
    if style == "casual":
        system_msg = "You are a friendly, casual assistant."
    else:
        system_msg = "You are a professional, formal assistant."

    messages = [SystemMessage(system_msg)] + state["messages"]
    response = llm.invoke(messages)

    return {
        "messages": [response],
        "conversation_count": 1
    }

# ä¼šè¯ 1ï¼šè®¾ç½®åå¥½
initial_state = {
    "messages": [HumanMessage("æˆ‘å–œæ¬¢ç®€æ´çš„å›ç­”")],
    "user_id": "alice",
    "preferences": {"response_style": "casual"},
    "conversation_count": 0
}

config = {"configurable": {"thread_id": "alice"}}
graph.invoke(initial_state, config)

# ä¼šè¯ 2ï¼šè‡ªåŠ¨åº”ç”¨åå¥½
later_state = {
    "messages": [HumanMessage("è§£é‡Šé‡å­è®¡ç®—")]
}
result = graph.invoke(later_state, config)
# âœ… è‡ªåŠ¨åŠ è½½ preferencesï¼Œä½¿ç”¨ casual é£æ ¼
```

#### **6. æ—¶é—´é™åˆ¶çš„è®°å¿†**

```python
from datetime import datetime, timedelta

class TimedState(TypedDict):
    messages: Annotated[list, add_messages]
    last_active: str  # ISO æ ¼å¼æ—¶é—´æˆ³

def trim_old_messages(state: TimedState) -> TimedState:
    """åˆ é™¤è¶…è¿‡ 7 å¤©çš„æ¶ˆæ¯"""
    cutoff = datetime.now() - timedelta(days=7)

    # è§£æ last_active
    if "last_active" in state:
        last_active = datetime.fromisoformat(state["last_active"])
        if last_active < cutoff:
            # å¤ªä¹…æ²¡æ´»åŠ¨ï¼Œæ¸…ç©ºå†å²
            return {
                "messages": [],
                "last_active": datetime.now().isoformat()
            }

    # æ›´æ–°æ´»åŠ¨æ—¶é—´
    return {
        **state,
        "last_active": datetime.now().isoformat()
    }

def agent(state: TimedState):
    # å…ˆæ¸…ç†æ—§æ¶ˆæ¯
    state = trim_old_messages(state)

    # æ­£å¸¸å¤„ç†
    response = llm.invoke(state["messages"])
    return {"messages": [response]}
```

#### **7. å¤šè®¾å¤‡åŒæ­¥**

```python
from fastapi import FastAPI, HTTPException
from langgraph_sdk import get_client

app = FastAPI()
client = get_client(url="https://your-langgraph-cloud.app")

@app.post("/chat")
async def chat(user_id: str, message: str, device_id: str):
    """æ”¯æŒå¤šè®¾å¤‡è®¿é—®åŒä¸€å¯¹è¯"""

    # ä½¿ç”¨ user_id ä½œä¸º thread_idï¼ˆä¸åŒ…å« device_idï¼‰
    config = {"configurable": {"thread_id": f"user-{user_id}"}}

    # æ‰§è¡Œå›¾
    response = await client.runs.create(
        thread_id=config["configurable"]["thread_id"],
        assistant_id="agent",
        input={"messages": [HumanMessage(message)]},
        metadata={"device_id": device_id}  # è®°å½•è®¾å¤‡ä¿¡æ¯
    )

    return {"response": response}

# ä½¿ç”¨åœºæ™¯ï¼š
# è®¾å¤‡ 1 (æ‰‹æœº): POST /chat?user_id=alice&message=Hi&device_id=phone
# è®¾å¤‡ 2 (ç”µè„‘): POST /chat?user_id=alice&message=ç»§ç»­&device_id=laptop
# ä¸¤ä¸ªè®¾å¤‡çœ‹åˆ°ç›¸åŒçš„å¯¹è¯å†å²
```

#### **8. æŸ¥è¯¢å†å²å¯¹è¯**

```python
def get_conversation_history(thread_id: str, limit: int = 10):
    """è·å–å¯¹è¯å†å²"""
    config = {"configurable": {"thread_id": thread_id}}

    # è·å–æ‰€æœ‰æ£€æŸ¥ç‚¹
    checkpoints = list(graph.checkpointer.list(config))

    # æŒ‰æ—¶é—´å€’åº
    checkpoints.sort(key=lambda x: x.created_at, reverse=True)

    # æå–æ¶ˆæ¯
    history = []
    for cp in checkpoints[:limit]:
        messages = cp.state.get("messages", [])
        history.append({
            "timestamp": cp.created_at,
            "messages": [
                {"role": m.type, "content": m.content}
                for m in messages
            ]
        })

    return history

# ä½¿ç”¨
history = get_conversation_history("user-alice")
for session in history:
    print(f"\n=== {session['timestamp']} ===")
    for msg in session['messages']:
        print(f"{msg['role']}: {msg['content']}")
```

#### **9. æ¸…ç†å’Œè¿‡æœŸç®¡ç†**

```python
import asyncio
from datetime import datetime, timedelta

async def cleanup_old_threads(checkpointer, days: int = 30):
    """å®šæœŸæ¸…ç†è¶…è¿‡ N å¤©çš„å¯¹è¯"""
    cutoff = datetime.now() - timedelta(days=days)

    # è·å–æ‰€æœ‰ thread
    all_threads = await checkpointer.list_threads()

    deleted_count = 0
    for thread_id in all_threads:
        config = {"configurable": {"thread_id": thread_id}}
        checkpoints = list(checkpointer.list(config))

        if not checkpoints:
            continue

        # æ£€æŸ¥æœ€åæ´»åŠ¨æ—¶é—´
        last_checkpoint = max(checkpoints, key=lambda x: x.created_at)
        if last_checkpoint.created_at < cutoff:
            checkpointer.delete_thread(config)
            deleted_count += 1
            print(f"Deleted thread: {thread_id}")

    print(f"Total deleted: {deleted_count} threads")

# å®šæœŸè¿è¡Œï¼ˆä¾‹å¦‚æ¯å¤©å‡Œæ™¨ï¼‰
async def scheduled_cleanup():
    while True:
        await cleanup_old_threads(checkpointer, days=30)
        await asyncio.sleep(86400)  # 24 å°æ—¶
```

#### **10. å®Œæ•´ç¤ºä¾‹ï¼šç”Ÿäº§çº§è®°å¿†ç³»ç»Ÿ**

```python
from langgraph.checkpoint.postgres import PostgresSaver
from typing import Annotated
import operator
from datetime import datetime

class ProductionState(TypedDict):
    messages: Annotated[list, add_messages]
    user_id: str
    user_name: str
    preferences: dict
    session_count: Annotated[int, operator.add]
    last_active: str
    metadata: dict

# æ•°æ®åº“è¿æ¥
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/langgraph"
)

def production_agent(state: ProductionState):
    # æ›´æ–°æ´»åŠ¨æ—¶é—´
    state["last_active"] = datetime.now().isoformat()

    # ä¸ªæ€§åŒ–é—®å€™
    if state.get("session_count", 0) == 0:
        greeting = f"ä½ å¥½ {state.get('user_name', 'ç”¨æˆ·')}ï¼å¾ˆé«˜å…´ä¸ºä½ æœåŠ¡ã€‚"
    else:
        greeting = f"æ¬¢è¿å›æ¥ï¼Œ{state.get('user_name')}ï¼"

    # æ„å»ºæ¶ˆæ¯
    messages = [SystemMessage(greeting)] + state["messages"]
    response = llm.invoke(messages)

    return {
        "messages": [response],
        "session_count": 1,
        "last_active": state["last_active"]
    }

# æ„å»ºå›¾
builder = StateGraph(ProductionState)
builder.add_node("agent", production_agent)
builder.add_edge(START, "agent")
builder.add_edge("agent", END)

graph = builder.compile(checkpointer=checkpointer)

# API ç«¯ç‚¹
@app.post("/api/chat")
async def chat_endpoint(
    user_id: str,
    message: str,
    user_name: str = "ç”¨æˆ·"
):
    config = {"configurable": {"thread_id": f"user-{user_id}"}}

    # è°ƒç”¨å›¾
    result = await graph.ainvoke(
        {
            "messages": [HumanMessage(message)],
            "user_id": user_id,
            "user_name": user_name,
            "preferences": {},  # å¯ä»¥ä»æ•°æ®åº“åŠ è½½
            "session_count": 0,
            "metadata": {"endpoint": "/api/chat"}
        },
        config
    )

    return {
        "response": result["messages"][-1].content,
        "session_count": result.get("session_count", 0)
    }
```

#### **å…³é”®è¦ç‚¹**
- **Checkpointer + Thread ID = è·¨ä¼šè¯è®°å¿†**
- **MemorySaverï¼šå¼€å‘æµ‹è¯•**
- **PostgresSaverï¼šç”Ÿäº§ç¯å¢ƒ**
- **Thread ID è®¾è®¡ï¼šæŒ‰ç”¨æˆ·/ä¼šè¯/åŠŸèƒ½éš”ç¦»**
- **å®šæœŸæ¸…ç†ï¼šé¿å…æ— é™å¢é•¿**

</details>

---

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè®©æˆ‘ç»§ç»­åˆ›å»ºå‰©ä½™çš„é—®é¢˜ 9-15...
### **é—®é¢˜ 9: å¦‚ä½•åœ¨æœ¬åœ°æµ‹è¯•åéƒ¨ç½²åˆ°äº‘ç«¯ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

æœ¬åœ°æµ‹è¯•åˆ°äº‘ç«¯éƒ¨ç½²çš„å®Œæ•´æµç¨‹åŒ…æ‹¬ **æœ¬åœ°å¼€å‘ â†’ GitHub æ¨é€ â†’ LangSmith é…ç½® â†’ äº‘ç«¯éƒ¨ç½²**ã€‚

#### **æ­¥éª¤ 1ï¼šæœ¬åœ°å¼€å‘å’Œæµ‹è¯•**

```bash
# é¡¹ç›®ç»“æ„
my-agent/
â”œâ”€â”€ agent.py              # å›¾å®šä¹‰
â”œâ”€â”€ langgraph.json        # é…ç½®æ–‡ä»¶
â”œâ”€â”€ .env                  # ç¯å¢ƒå˜é‡ï¼ˆä¸æäº¤ï¼‰
â”œâ”€â”€ .env.example          # ç¯å¢ƒå˜é‡æ¨¡æ¿
â”œâ”€â”€ .gitignore           # Git å¿½ç•¥æ–‡ä»¶
â””â”€â”€ requirements.txt      # Python ä¾èµ–

# å¯åŠ¨æœ¬åœ°å¼€å‘æœåŠ¡å™¨
cd my-agent
langgraph dev

# è¾“å‡ºï¼š
# ğŸš€ API: http://127.0.0.1:2024
# ğŸ¨ Studio UI: https://smith.langchain.com/studio/?baseUrl=http://127.0.0.1:2024
```

#### **æ­¥éª¤ 2ï¼šGit å‡†å¤‡**

```bash
# .gitignore å†…å®¹
.env
*.env
__pycache__/
.venv/

# åˆå§‹åŒ– Git
git init
git add .
git commit -m "Initial commit: LangGraph agent"

# åˆ›å»º GitHub ä»“åº“å¹¶æ¨é€
git remote add origin https://github.com/username/my-agent.git
git push -u origin main
```

#### **æ­¥éª¤ 3ï¼šLangSmith éƒ¨ç½²é…ç½®**

1. è®¿é—® [LangSmith](https://smith.langchain.com/)
2. å¯¼èˆªåˆ° **Deployments** â†’ **New Deployment**
3. é€‰æ‹© **Deploy from GitHub**
4. é…ç½®ï¼š
   - Repository: `username/my-agent`
   - Branch: `main`
   - Config file: `langgraph.json`
5. è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆä» `.env` å¤åˆ¶ï¼‰
6. ç‚¹å‡» **Deploy**

#### **æ­¥éª¤ 4ï¼šä½¿ç”¨ SDK è°ƒç”¨äº‘ç«¯**

```python
from langgraph_sdk import get_client

# æœ¬åœ°æµ‹è¯•
local_client = get_client(url="http://127.0.0.1:2024")

# äº‘ç«¯éƒ¨ç½²
cloud_client = get_client(url="https://your-deployment.langgraph.app")

# API å®Œå…¨ç›¸åŒï¼
async for chunk in cloud_client.runs.stream(
    thread_id="user-123",
    assistant_id="agent",
    input={"messages": [...]},
    stream_mode="values"
):
    print(chunk)
```

#### **å…³é”®è¦ç‚¹**
- **æœ¬åœ°æµ‹è¯•ï¼š** `langgraph dev` å¿«é€Ÿè¿­ä»£
- **Git ç®¡ç†ï¼š** ä¸è¦æäº¤ `.env` æ–‡ä»¶
- **ç¯å¢ƒå˜é‡ï¼š** äº‘ç«¯éœ€æ‰‹åŠ¨é…ç½®
- **SDK ç»Ÿä¸€ï¼š** æœ¬åœ°/äº‘ç«¯ API å®Œå…¨ä¸€è‡´

</details>

---

### **é—®é¢˜ 10: å¦‚ä½•å¤„ç†å·¥å…·è°ƒç”¨å¤±è´¥çš„æƒ…å†µï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å·¥å…·è°ƒç”¨å¤±è´¥å¤„ç†éœ€è¦ **å¼‚å¸¸æ•è· + é”™è¯¯æ¶ˆæ¯è¿”å› + é‡è¯•æœºåˆ¶**ã€‚

#### **æ–¹æ³• 1ï¼šå·¥å…·å†…éƒ¨é”™è¯¯å¤„ç†**

```python
from langchain_core.tools import tool

@tool
def divide(a: float, b: float) -> str:
    """Divide a by b with error handling."""
    try:
        if b == 0:
            return "Error: Division by zero is not allowed"
        result = a / b
        return f"Result: {result}"
    except Exception as e:
        return f"Error: {str(e)}"
```

#### **æ–¹æ³• 2ï¼šToolNode åŒ…è£…å™¨**

```python
class SafeToolNode:
    def __init__(self, tools):
        self.tool_node = ToolNode(tools)

    def __call__(self, state: MessagesState):
        try:
            return self.tool_node(state)
        except Exception as e:
            # è¿”å›é”™è¯¯æ¶ˆæ¯ç»™ LLM
            last_message = state["messages"][-1]
            error_msg = ToolMessage(
                content=f"Tool execution failed: {str(e)}",
                tool_call_id=last_message.tool_calls[0]["id"] if last_message.tool_calls else "error"
            )
            return {"messages": [error_msg]}

# ä½¿ç”¨
builder.add_node("tools", SafeToolNode(tools))
```

#### **æ–¹æ³• 3ï¼šé‡è¯•æœºåˆ¶**

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@tool
@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
def api_call(endpoint: str) -> str:
    """Call external API with retry."""
    response = requests.get(endpoint, timeout=10)
    response.raise_for_status()
    return response.text
```

#### **æ–¹æ³• 4ï¼šAgent çº§åˆ«å¤„ç†**

```python
def agent_with_error_recovery(state: MessagesState):
    last_message = state["messages"][-1]

    # æ£€æŸ¥æ˜¯å¦æ˜¯é”™è¯¯æ¶ˆæ¯
    if isinstance(last_message, ToolMessage) and "Error:" in last_message.content:
        # LLM åˆ†æé”™è¯¯å¹¶å†³å®šä¸‹ä¸€æ­¥
        recovery_prompt = SystemMessage(
            "The tool call failed. Analyze the error and either retry with different parameters or provide an alternative solution."
        )
        messages = [recovery_prompt] + state["messages"]
        response = llm_with_tools.invoke(messages)
    else:
        response = llm_with_tools.invoke(state["messages"])

    return {"messages": [response]}
```

#### **å…³é”®è¦ç‚¹**
- **å·¥å…·å†…éƒ¨ï¼š** try-except æ•è·å¼‚å¸¸
- **è¿”å›é”™è¯¯æ¶ˆæ¯ï¼š** è®© LLM çŸ¥é“å¤±è´¥åŸå› 
- **é‡è¯•æœºåˆ¶ï¼š** å¯¹ä¸´æ—¶å¤±è´¥è‡ªåŠ¨é‡è¯•
- **Agent æ¢å¤ï¼š** åˆ†æé”™è¯¯å¹¶è°ƒæ•´ç­–ç•¥

</details>

---

### **é—®é¢˜ 11: è®¾è®¡ä¸€ä¸ªå®¢æœæœºå™¨äººåº”è¯¥é€‰æ‹©å“ªç§æ¶æ„æ¨¡å¼ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å®¢æœæœºå™¨äººåº”é€‰æ‹© **Agent + Memory** æ¶æ„ï¼Œç»“åˆ Router è¿›è¡Œæ„å›¾åˆ†ç±»ã€‚

#### **æ¨èæ¶æ„ï¼šåˆ†å±‚è®¾è®¡**

```python
# ç¬¬ 1 å±‚ï¼šæ„å›¾åˆ†ç±»ï¼ˆRouterï¼‰
def classify_intent(state) -> Literal["faq", "order_query", "complaint", "general"]:
    last_message = state["messages"][-1].content
    # ä½¿ç”¨ LLM åˆ†ç±»æˆ–å…³é”®è¯åŒ¹é…
    classification = llm.invoke(f"Classify intent: {last_message}")
    return classification

# ç¬¬ 2 å±‚ï¼šä¸“ä¸šå¤„ç†ï¼ˆAgentï¼‰
def order_agent(state):
    """å¤„ç†è®¢å•ç›¸å…³æŸ¥è¯¢ï¼ˆå¯èƒ½éœ€è¦å¤šæ­¥éª¤ï¼‰"""
    tools = [check_order_status, track_shipment, cancel_order]
    llm_with_tools = llm.bind_tools(tools)
    response = llm_with_tools.invoke(state["messages"])
    return {"messages": [response]}

def faq_agent(state):
    """å¤„ç†å¸¸è§é—®é¢˜ï¼ˆç®€å•æŸ¥è¯¢ï¼‰"""
    # ä»çŸ¥è¯†åº“æ£€ç´¢ç­”æ¡ˆ
    answer = search_knowledge_base(state["messages"][-1].content)
    return {"messages": [AIMessage(answer)]}

# æ„å»ºå›¾
builder = StateGraph(MessagesState)
builder.add_node("classifier", lambda s: s)
builder.add_node("order_agent", order_agent)
builder.add_node("faq_agent", faq_agent)
builder.add_node("tools", ToolNode(tools))

# è·¯ç”±é€»è¾‘
builder.add_edge(START, "classifier")
builder.add_conditional_edges("classifier", classify_intent)
builder.add_conditional_edges("order_agent", tools_condition)
builder.add_edge("tools", "order_agent")  # Agent æ¨¡å¼çš„å¾ªç¯
builder.add_edge("faq_agent", END)
builder.add_edge("order_agent", END)

# æ·»åŠ  Memory
from langgraph.checkpoint.postgres import PostgresSaver
checkpointer = PostgresSaver.from_conn_string("postgresql://...")
graph = builder.compile(checkpointer=checkpointer)
```

#### **ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

1. **Routerï¼ˆæ„å›¾åˆ†ç±»ï¼‰ï¼š** å¿«é€Ÿåˆ†æµç®€å•é—®é¢˜
2. **Agentï¼ˆè®¢å•å¤„ç†ï¼‰ï¼š** å¤„ç†éœ€è¦å¤šæ­¥éª¤çš„å¤æ‚æŸ¥è¯¢
3. **Memoryï¼ˆå¯¹è¯è®°å¿†ï¼‰ï¼š** è®°ä½ç”¨æˆ·ä¿¡æ¯å’Œä¸Šä¸‹æ–‡
4. **åˆ†å±‚å¤„ç†ï¼š** å¹³è¡¡æ•ˆç‡å’Œèƒ½åŠ›

#### **ä½¿ç”¨ç¤ºä¾‹**

```python
config = {"configurable": {"thread_id": "customer-12345"}}

# ä¼šè¯ 1ï¼šè®¢å•æŸ¥è¯¢
graph.invoke({"messages": [HumanMessage("æˆ‘çš„è®¢å• #98765 åœ¨å“ªé‡Œï¼Ÿ")]}, config)
# â†’ è·¯ç”±åˆ° order_agent â†’ è°ƒç”¨ track_shipment â†’ è¿”å›ç‰©æµä¿¡æ¯

# ä¼šè¯ 2ï¼šåç»­é—®é¢˜ï¼ˆåˆ©ç”¨ Memoryï¼‰
graph.invoke({"messages": [HumanMessage("é‚£ä¸ªè®¢å•å¯ä»¥å–æ¶ˆå—ï¼Ÿ")]}, config)
# â†’ è®°ä½è®¢å•å· #98765 â†’ è°ƒç”¨ cancel_order
```

#### **å…³é”®è¦ç‚¹**
- **åˆ†å±‚æ¶æ„ï¼š** Router + Agent ç»“åˆ
- **å·¥å…·åˆ†ç±»ï¼š** ä¸åŒåœºæ™¯ä½¿ç”¨ä¸åŒå·¥å…·é›†
- **Memory å¿…éœ€ï¼š** å®¢æœéœ€è¦è®°ä½ä¸Šä¸‹æ–‡
- **é”™è¯¯å¤„ç†ï¼š** å·¥å…·å¤±è´¥æ—¶æä¾›äººå·¥è½¬æ¥é€‰é¡¹

</details>

---

### **é—®é¢˜ 12: å¦‚ä½•ä¼˜åŒ– Agent çš„ Token ä½¿ç”¨ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

ä¼˜åŒ– Token ä½¿ç”¨éœ€è¦ **æ¶ˆæ¯ä¿®å‰ª + æç¤ºè¯ä¼˜åŒ– + å·¥å…·é€‰æ‹©ç­–ç•¥**ã€‚

#### **æ–¹æ³• 1ï¼šé™åˆ¶æ¶ˆæ¯å†å²é•¿åº¦**

```python
from langchain_core.messages import trim_messages

def agent_with_trim(state: MessagesState):
    # åªä¿ç•™æœ€è¿‘ 10 æ¡æ¶ˆæ¯
    trimmed_messages = trim_messages(
        state["messages"],
        max_tokens=2000,
        strategy="last",
        token_counter=llm
    )

    response = llm_with_tools.invoke(trimmed_messages)
    return {"messages": [response]}
```

#### **æ–¹æ³• 2ï¼šæ¶ˆæ¯æ‘˜è¦**

```python
def summarize_old_messages(state: MessagesState):
    messages = state["messages"]

    if len(messages) > 20:
        # æ‘˜è¦å‰ 10 æ¡æ¶ˆæ¯
        old_messages = messages[:10]
        summary = llm.invoke([
            SystemMessage("Summarize this conversation in 2-3 sentences:"),
            *old_messages
        ])

        # ä¿ç•™æ‘˜è¦ + æœ€è¿‘æ¶ˆæ¯
        new_messages = [
            SystemMessage(f"Previous conversation summary: {summary.content}"),
            *messages[10:]
        ]
        return {"messages": new_messages}

    return state
```

#### **æ–¹æ³• 3ï¼šå‡å°‘ç³»ç»Ÿæç¤ºé•¿åº¦**

```python
# âŒ ä¸å¥½ï¼šå†—é•¿çš„ç³»ç»Ÿæç¤º
system_msg = SystemMessage(content="""
You are a highly intelligent, professional, and courteous AI assistant...
[500 words of instructions]
""")

# âœ… å¥½ï¼šç®€æ´çš„ç³»ç»Ÿæç¤º
system_msg = SystemMessage(content="""
You are a helpful assistant. Be concise and accurate.
Use tools when needed. Provide final answers without tool calls.
""")
```

#### **æ–¹æ³• 4ï¼šæ™ºèƒ½å·¥å…·é€‰æ‹©**

```python
def agent_with_selective_tools(state: MessagesState):
    last_message = state["messages"][-1].content.lower()

    # æ ¹æ®æ„å›¾åªç»‘å®šç›¸å…³å·¥å…·
    if "calculate" in last_message:
        tools = [add, multiply, divide]
    elif "search" in last_message:
        tools = [search_web]
    else:
        tools = [add, search_web]  # æœ€å°å·¥å…·é›†

    llm_with_tools = llm.bind_tools(tools)
    response = llm_with_tools.invoke(state["messages"])
    return {"messages": [response]}
```

#### **æ–¹æ³• 5ï¼šä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹**

```python
# åˆ†çº§æ¨¡å‹ç­–ç•¥
def get_llm_for_task(task_complexity: str):
    if task_complexity == "simple":
        return ChatOpenAI(model="gpt-3.5-turbo")  # ä¾¿å®œ
    elif task_complexity == "complex":
        return ChatOpenAI(model="gpt-4")  # å¼ºå¤§
    else:
        return ChatOpenAI(model="gpt-4o-mini")  # å¹³è¡¡
```

#### **æ–¹æ³• 6ï¼šToken ä½¿ç”¨ç›‘æ§**

```python
class TokenTrackingState(TypedDict):
    messages: Annotated[list, add_messages]
    total_tokens: int
    cost_usd: float

def agent_with_tracking(state: TokenTrackingState):
    response = llm_with_tools.invoke(state["messages"])

    # æå– token ä½¿ç”¨
    usage = response.response_metadata.get("token_usage", {})
    tokens = usage.get("total_tokens", 0)

    # è®¡ç®—æˆæœ¬ï¼ˆGPT-4 ç¤ºä¾‹ï¼š$0.03/1K tokensï¼‰
    cost = (tokens / 1000) * 0.03

    return {
        "messages": [response],
        "total_tokens": tokens,
        "cost_usd": cost
    }
```

#### **å…³é”®è¦ç‚¹**
- **æ¶ˆæ¯ä¿®å‰ªï¼š** é™åˆ¶å†å²é•¿åº¦
- **æ‘˜è¦ç­–ç•¥ï¼š** å‹ç¼©æ—§å¯¹è¯
- **æç¤ºè¯ä¼˜åŒ–ï¼š** ç®€æ´æ˜ç¡®
- **é€‰æ‹©æ€§å·¥å…·ï¼š** å‡å°‘å‡½æ•°æè¿°å¼€é”€
- **ç›‘æ§æˆæœ¬ï¼š** å®æ—¶è·Ÿè¸ª token ä½¿ç”¨

</details>

---

### **é—®é¢˜ 13: å¦‚ä½•è®¾è®¡å¤šç”¨æˆ·å¹¶å‘çš„ Agent ç³»ç»Ÿï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å¤šç”¨æˆ·å¹¶å‘ç³»ç»Ÿéœ€è¦ **Thread ID éš”ç¦» + æ•°æ®åº“ Checkpointer + å¼‚æ­¥å¤„ç†**ã€‚

#### **æ ¸å¿ƒè®¾è®¡åŸåˆ™**

```python
# æ¯ä¸ªç”¨æˆ·ç‹¬ç«‹çš„ Thread ID
def get_user_config(user_id: str, session_id: str = None):
    if session_id:
        thread_id = f"user-{user_id}-session-{session_id}"
    else:
        thread_id = f"user-{user_id}"

    return {"configurable": {"thread_id": thread_id}}
```

#### **ç”Ÿäº§çº§æ¶æ„ï¼šFastAPI + PostgreSQL**

```python
from fastapi import FastAPI, HTTPException
from langgraph_sdk import get_client
from langgraph.checkpoint.postgres import PostgresSaver
import asyncio

app = FastAPI()

# æ•°æ®åº“ Checkpointerï¼ˆæ”¯æŒå¹¶å‘ï¼‰
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/langgraph"
)

# ç¼–è¯‘å›¾
graph = builder.compile(checkpointer=checkpointer)

@app.post("/chat")
async def chat_endpoint(user_id: str, message: str):
    """å¤„ç†å•ä¸ªç”¨æˆ·è¯·æ±‚ï¼ˆå¼‚æ­¥ï¼‰"""
    config = get_user_config(user_id)

    # å¼‚æ­¥è°ƒç”¨ï¼ˆéé˜»å¡ï¼‰
    result = await graph.ainvoke(
        {"messages": [HumanMessage(message)]},
        config
    )

    return {"response": result["messages"][-1].content}

@app.post("/chat/batch")
async def batch_chat(requests: list[dict]):
    """æ‰¹é‡å¤„ç†å¤šä¸ªç”¨æˆ·è¯·æ±‚ï¼ˆå¹¶å‘ï¼‰"""
    tasks = []

    for req in requests:
        config = get_user_config(req["user_id"])
        task = graph.ainvoke(
            {"messages": [HumanMessage(req["message"])]},
            config
        )
        tasks.append(task)

    # å¹¶å‘æ‰§è¡Œ
    results = await asyncio.gather(*tasks)

    return {"responses": [r["messages"][-1].content for r in results]}
```

#### **è´Ÿè½½å‡è¡¡å’Œæ‰©å±•**

```python
# ä½¿ç”¨ Redis ä½œä¸ºåˆ†å¸ƒå¼é”
from redis import Redis
import hashlib

redis_client = Redis(host='localhost', port=6379, db=0)

def get_shard_for_user(user_id: str, num_shards: int = 4) -> int:
    """å°†ç”¨æˆ·åˆ†é…åˆ°ä¸åŒçš„å¤„ç†åˆ†ç‰‡"""
    hash_value = int(hashlib.md5(user_id.encode()).hexdigest(), 16)
    return hash_value % num_shards

@app.post("/chat/balanced")
async def balanced_chat(user_id: str, message: str):
    """è´Ÿè½½å‡è¡¡çš„èŠå¤©ç«¯ç‚¹"""
    shard = get_shard_for_user(user_id)

    # ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢å¹¶å‘å†™å…¥
    lock_key = f"user_lock:{user_id}"

    with redis_client.lock(lock_key, timeout=30):
        config = get_user_config(user_id)
        result = await graph.ainvoke(
            {"messages": [HumanMessage(message)]},
            config
        )

    return {
        "response": result["messages"][-1].content,
        "shard": shard
    }
```

#### **ç›‘æ§å’Œé™æµ**

```python
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter

@app.on_event("startup")
async def startup():
    await FastAPILimiter.init(redis_client)

@app.post("/chat", dependencies=[RateLimiter(times=10, seconds=60)])
async def rate_limited_chat(user_id: str, message: str):
    """æ¯ä¸ªç”¨æˆ·æ¯åˆ†é’Ÿæœ€å¤š 10 æ¬¡è¯·æ±‚"""
    config = get_user_config(user_id)
    result = await graph.ainvoke({"messages": [HumanMessage(message)]}, config)
    return {"response": result["messages"][-1].content}
```

#### **å…³é”®è¦ç‚¹**
- **Thread ID éš”ç¦»ï¼š** æ¯ä¸ªç”¨æˆ·ç‹¬ç«‹çŠ¶æ€
- **å¼‚æ­¥å¤„ç†ï¼š** ä½¿ç”¨ `ainvoke` å’Œ `asyncio`
- **æ•°æ®åº“ Checkpointerï¼š** PostgreSQL æ”¯æŒå¹¶å‘
- **è´Ÿè½½å‡è¡¡ï¼š** ç”¨æˆ·åˆ†ç‰‡å’Œåˆ†å¸ƒå¼é”
- **é™æµä¿æŠ¤ï¼š** é˜²æ­¢æ»¥ç”¨

</details>

---

### **é—®é¢˜ 14: Simple Graph vs Chain vs Agentï¼šå¦‚ä½•é€‰æ‹©ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

é€‰æ‹©æ¶æ„æ¨¡å¼åŸºäº **ä»»åŠ¡å¤æ‚åº¦ã€å†³ç­–éœ€æ±‚ã€å·¥å…·æ•°é‡**ã€‚

#### **å†³ç­–æ ‘**

```
ä½ çš„ä»»åŠ¡éœ€æ±‚ï¼š

æ˜¯å¦éœ€è¦ LLMï¼Ÿ
â”œâ”€ å¦ â†’ Simple Graphï¼ˆçº¯é€»è¾‘æµç¨‹ï¼‰
â””â”€ æ˜¯ â†“

æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·ï¼Ÿ
â”œâ”€ å¦ â†’ ç®€å• LLM è°ƒç”¨ï¼ˆä¸éœ€è¦ LangGraphï¼‰
â””â”€ æ˜¯ â†“

å·¥å…·è°ƒç”¨åæ˜¯å¦éœ€è¦ LLM ç»§ç»­æ¨ç†ï¼Ÿ
â”œâ”€ å¦ â†’ Router / Chainï¼ˆå•æ¬¡å·¥å…·è°ƒç”¨ï¼‰
â””â”€ æ˜¯ â†“

æ˜¯å¦éœ€è¦å¤šè½®å·¥å…·è°ƒç”¨ï¼Ÿ
â”œâ”€ å¦ â†’ Routerï¼ˆä¸€æ¬¡å†³ç­–ï¼‰
â””â”€ æ˜¯ â†’ Agentï¼ˆå¾ªç¯æ¨ç†ï¼‰

æ˜¯å¦éœ€è¦è·¨ä¼šè¯è®°å¿†ï¼Ÿ
â”œâ”€ å¦ â†’ æ—  Checkpointer
â””â”€ æ˜¯ â†’ Agent + Memory
```

#### **è¯¦ç»†å¯¹æ¯”è¡¨**

| åœºæ™¯ | Simple Graph | Chain | Router | Agent | Agent + Memory |
|------|-------------|-------|--------|-------|----------------|
| **Hello World ç¤ºä¾‹** | âœ… | âŒ | âŒ | âŒ | âŒ |
| **å•æ¬¡å·¥å…·è°ƒç”¨** | âŒ | âœ… | âœ… | å¯ä»¥ | å¯ä»¥ |
| **å¤šæ¬¡å·¥å…·è°ƒç”¨** | âŒ | âŒ | âŒ | âœ… | âœ… |
| **éœ€è¦ä¸Šä¸‹æ–‡è®°å¿†** | âŒ | âŒ | âŒ | âŒ | âœ… |
| **å¤æ‚åº¦** | ä½ | ä½ | ä¸­ | é«˜ | é«˜ |
| **æˆæœ¬** | ä½ | ä¸­ | ä¸­ | é«˜ | é«˜ |

#### **å®é™…æ¡ˆä¾‹æ¨è**

**åœºæ™¯ 1ï¼šç®€å•é—®ç­”**
```python
# æ¨èï¼šSimple Graph æˆ–ç›´æ¥ LLM
response = llm.invoke("What is Python?")
```

**åœºæ™¯ 2ï¼šå¤©æ°”æŸ¥è¯¢**
```python
# æ¨èï¼šRouter
tools = [get_weather]
llm_with_tools = llm.bind_tools(tools)
# ä¸€æ¬¡è°ƒç”¨å·¥å…·ï¼Œè¿”å›ç»“æœ
```

**åœºæ™¯ 3ï¼šè®¢å•å¤„ç†**
```python
# æ¨èï¼šAgent
# å¯èƒ½éœ€è¦ï¼šæŸ¥è¯¢è®¢å• â†’ æ£€æŸ¥åº“å­˜ â†’ æ›´æ–°çŠ¶æ€
tools = [check_order, check_inventory, update_order]
# éœ€è¦å¤šæ­¥æ¨ç†
```

**åœºæ™¯ 4ï¼šå®¢æœèŠå¤©æœºå™¨äºº**
```python
# æ¨èï¼šAgent + Memory
# éœ€è¦è®°ä½ç”¨æˆ·ä¿¡æ¯å’Œå¯¹è¯å†å²
checkpointer = PostgresSaver(...)
graph = builder.compile(checkpointer=checkpointer)
```

**åœºæ™¯ 5ï¼šæ•°æ®åˆ†æåŠ©æ‰‹**
```python
# æ¨èï¼šAgent + Memory
# æŸ¥è¯¢ â†’ åˆ†æ â†’ å¯è§†åŒ–ï¼ˆå¤šæ­¥éª¤ï¼‰
# è®°ä½æ•°æ®é›†å’Œåˆ†æå†å²
```

#### **å…³é”®è¦ç‚¹**
- **Simple Graphï¼š** å­¦ä¹ å’Œç®€å•æµç¨‹
- **Chain/Routerï¼š** å•æ¬¡å·¥å…·è°ƒç”¨
- **Agentï¼š** å¤šæ­¥æ¨ç†ä»»åŠ¡
- **Agent + Memoryï¼š** å¤šè½®å¯¹è¯ç³»ç»Ÿ

</details>

---

### **é—®é¢˜ 15: å¦‚ä½•è®¾è®¡å¯æ‰©å±•çš„å·¥å…·ç³»ç»Ÿï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å¯æ‰©å±•å·¥å…·ç³»ç»Ÿéœ€è¦ **æ¨¡å—åŒ–è®¾è®¡ + åŠ¨æ€åŠ è½½ + å·¥å…·æ³¨å†Œè¡¨**ã€‚

#### **è®¾è®¡ 1ï¼šå·¥å…·æ³¨å†Œè¡¨æ¨¡å¼**

```python
from typing import Dict, List
from langchain_core.tools import tool

class ToolRegistry:
    """å·¥å…·æ³¨å†Œä¸­å¿ƒ"""

    def __init__(self):
        self.tools: Dict[str, callable] = {}
        self.categories: Dict[str, List[str]] = {}

    def register(self, category: str = "general"):
        """è£…é¥°å™¨ï¼šæ³¨å†Œå·¥å…·"""
        def decorator(func):
            tool_func = tool(func)
            self.tools[func.__name__] = tool_func
            self.categories.setdefault(category, []).append(func.__name__)
            return tool_func
        return decorator

    def get_tools(self, category: str = None) -> List:
        """è·å–å·¥å…·åˆ—è¡¨"""
        if category:
            tool_names = self.categories.get(category, [])
            return [self.tools[name] for name in tool_names]
        return list(self.tools.values())

# å…¨å±€æ³¨å†Œè¡¨
registry = ToolRegistry()

# æ³¨å†Œå·¥å…·
@registry.register(category="math")
def add(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b

@registry.register(category="math")
def multiply(a: int, b: int) -> int:
    """Multiply two numbers."""
    return a * b

@registry.register(category="search")
def search_web(query: str) -> str:
    """Search the web."""
    return f"Results for: {query}"

# ä½¿ç”¨
math_tools = registry.get_tools("math")
all_tools = registry.get_tools()
```

#### **è®¾è®¡ 2ï¼šæ’ä»¶åŒ–å·¥å…·åŠ è½½**

```python
import importlib
import os
from pathlib import Path

class ToolLoader:
    """åŠ¨æ€åŠ è½½å·¥å…·æ’ä»¶"""

    def __init__(self, plugin_dir: str = "plugins"):
        self.plugin_dir = Path(plugin_dir)
        self.tools = []

    def load_plugins(self):
        """ä»æ’ä»¶ç›®å½•åŠ è½½æ‰€æœ‰å·¥å…·"""
        for file in self.plugin_dir.glob("*.py"):
            if file.stem.startswith("_"):
                continue

            # åŠ¨æ€å¯¼å…¥æ¨¡å—
            module_name = f"plugins.{file.stem}"
            module = importlib.import_module(module_name)

            # æŸ¥æ‰¾æ‰€æœ‰ @tool è£…é¥°çš„å‡½æ•°
            for attr_name in dir(module):
                attr = getattr(module, attr_name)
                if callable(attr) and hasattr(attr, "name"):
                    self.tools.append(attr)

        return self.tools

# é¡¹ç›®ç»“æ„
# plugins/
# â”œâ”€â”€ math_tools.py
# â”œâ”€â”€ search_tools.py
# â””â”€â”€ file_tools.py

# ä½¿ç”¨
loader = ToolLoader("plugins")
tools = loader.load_plugins()
```

#### **è®¾è®¡ 3ï¼šæ¡ä»¶å·¥å…·åŠ è½½**

```python
def get_tools_for_context(context: str, user_role: str) -> List:
    """æ ¹æ®ä¸Šä¸‹æ–‡å’Œç”¨æˆ·è§’è‰²è¿”å›å·¥å…·"""

    base_tools = [search_web, calculate]

    if context == "customer_service":
        tools = base_tools + [check_order, track_shipment]

        if user_role == "admin":
            tools.append(cancel_order)  # åªæœ‰ç®¡ç†å‘˜å¯ä»¥å–æ¶ˆè®¢å•

    elif context == "data_analysis":
        tools = base_tools + [query_database, generate_chart]

    else:
        tools = base_tools

    return tools

# ä½¿ç”¨
def agent_with_dynamic_tools(state: MessagesState):
    context = state.get("context", "general")
    user_role = state.get("user_role", "user")

    tools = get_tools_for_context(context, user_role)
    llm_with_tools = llm.bind_tools(tools)

    response = llm_with_tools.invoke(state["messages"])
    return {"messages": [response]}
```

#### **è®¾è®¡ 4ï¼šå·¥å…·ç‰ˆæœ¬ç®¡ç†**

```python
class VersionedTool:
    """æ”¯æŒç‰ˆæœ¬ç®¡ç†çš„å·¥å…·åŒ…è£…å™¨"""

    def __init__(self, name: str, func: callable, version: str):
        self.name = name
        self.func = tool(func)
        self.version = version

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

class ToolManager:
    def __init__(self):
        self.tools: Dict[str, Dict[str, VersionedTool]] = {}

    def register(self, name: str, func: callable, version: str = "1.0"):
        if name not in self.tools:
            self.tools[name] = {}
        self.tools[name][version] = VersionedTool(name, func, version)

    def get_tool(self, name: str, version: str = "latest"):
        if version == "latest":
            version = max(self.tools[name].keys())
        return self.tools[name][version].func

# ä½¿ç”¨
manager = ToolManager()
manager.register("search", search_web_v1, "1.0")
manager.register("search", search_web_v2, "2.0")

# è·å–æœ€æ–°ç‰ˆæœ¬
tool = manager.get_tool("search", "latest")
```

#### **è®¾è®¡ 5ï¼šå·¥å…·ç»„åˆ**

```python
from langchain_core.tools import tool

def create_tool_pipeline(*tools):
    """å°†å¤šä¸ªå·¥å…·ç»„åˆæˆä¸€ä¸ªå·¥å…·"""

    @tool
    def pipeline_tool(input_data: str) -> str:
        """Execute a pipeline of tools."""
        result = input_data
        for t in tools:
            result = t.invoke(result)
        return result

    return pipeline_tool

# ä½¿ç”¨
fetch_tool = create_fetch_tool()
parse_tool = create_parse_tool()
summarize_tool = create_summarize_tool()

# ç»„åˆå·¥å…·
research_tool = create_tool_pipeline(fetch_tool, parse_tool, summarize_tool)
```

#### **å…³é”®è¦ç‚¹**
- **æ³¨å†Œè¡¨æ¨¡å¼ï¼š** ä¸­å¿ƒåŒ–ç®¡ç†æ‰€æœ‰å·¥å…·
- **æ’ä»¶ç³»ç»Ÿï¼š** åŠ¨æ€åŠ è½½å’Œå¸è½½
- **æ¡ä»¶åŠ è½½ï¼š** æ ¹æ®ä¸Šä¸‹æ–‡é€‰æ‹©å·¥å…·
- **ç‰ˆæœ¬ç®¡ç†ï¼š** æ”¯æŒå·¥å…·æ¼”è¿›
- **å·¥å…·ç»„åˆï¼š** å¤æ‚åŠŸèƒ½çš„æ¨¡å—åŒ–

</details>

---

## ğŸ‰ å¤ä¹ å®Œæˆï¼

æ­å–œä½ å®Œæˆäº† Module-2 çš„å…¨éƒ¨ 15 ä¸ªå¤ä¹ é—®é¢˜ï¼è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ä½ å·²ç»æŒæ¡çš„çŸ¥è¯†ï¼š

### ğŸ“Š çŸ¥è¯†æŒæ¡åº¦è‡ªæµ‹

| ç±»åˆ« | é—®é¢˜ç¼–å· | æŒæ¡ç¨‹åº¦ |
|------|---------|---------|
| **åŸºç¡€ç†è§£** | 1-5 | â¬œâ¬œâ¬œâ¬œâ¬œ |
| **ä»£ç å®ç°** | 6-10 | â¬œâ¬œâ¬œâ¬œâ¬œ |
| **æ¶æ„è®¾è®¡** | 11-15 | â¬œâ¬œâ¬œâ¬œâ¬œ |

**è‡ªæµ‹æ–¹æ³•ï¼š**
- â¬œ = ä¸ç†è§£
- â˜‘ = åŸºæœ¬ç†è§£
- âœ… = å®Œå…¨æŒæ¡

---

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„

å®Œæˆ Module-2 åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… LangGraph çš„å…­å¤§æ ¸å¿ƒæ¶æ„æ¨¡å¼
- âœ… çŠ¶æ€ç®¡ç†å’Œ Reducer æœºåˆ¶
- âœ… Router å’Œ Agent çš„åŒºåˆ«ä¸åº”ç”¨
- âœ… å·¥å…·ç³»ç»Ÿçš„è®¾è®¡ä¸å®ç°
- âœ… è®°å¿†ç®¡ç†å’ŒçŠ¶æ€æŒä¹…åŒ–
- âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æµç¨‹

**ç»§ç»­å‰è¿›ï¼š**

**Module-3ï¼šé«˜çº§çŠ¶æ€ç®¡ç†**
- å¤šçŠ¶æ€æ¨¡å¼ï¼ˆMultiple Schemasï¼‰
- æ¶ˆæ¯è¿‡æ»¤å’Œä¿®å‰ª
- å¤–éƒ¨è®°å¿†ç³»ç»Ÿé›†æˆ

**Module-4ï¼šäººæœºåä½œ**
- æ–­ç‚¹ï¼ˆBreakpointsï¼‰æœºåˆ¶
- çŠ¶æ€ç¼–è¾‘å’Œäººå·¥åé¦ˆ
- æ—¶é—´æ—…è¡Œè°ƒè¯•

**Module-5ï¼šå¹¶è¡Œå’Œå­å›¾**
- Map-Reduce æ¨¡å¼
- å¹¶è¡ŒèŠ‚ç‚¹æ‰§è¡Œ
- å­å›¾å¤ç”¨

---

### ğŸ’ª å®è·µå»ºè®®

1. **åŠ¨æ‰‹ç¼–ç ï¼š** æ¯ä¸ªé—®é¢˜éƒ½å°è¯•è‡ªå·±å®ç°ä¸€é
2. **ä¿®æ”¹å®éªŒï¼š** æ”¹å˜å‚æ•°ï¼Œè§‚å¯Ÿè¡Œä¸ºå˜åŒ–
3. **æ„å»ºé¡¹ç›®ï¼š** é€‰æ‹©ä¸€ä¸ªå®é™…åœºæ™¯ï¼ˆå¦‚å®¢æœæœºå™¨äººï¼‰å®Œæ•´å®ç°
4. **é˜…è¯»æºç ï¼š** æ·±å…¥ LangGraph æºä»£ç ç†è§£å†…éƒ¨å®ç°
5. **ç¤¾åŒºäº¤æµï¼š** åœ¨ LangChain Discord æˆ– GitHub è®¨è®ºé—®é¢˜

---

### ğŸ“š å‚è€ƒèµ„æº

- [LangGraph å®˜æ–¹æ–‡æ¡£](https://langchain-ai.github.io/langgraph/)
- [LangChain Python æ–‡æ¡£](https://python.langchain.com/)
- [LangSmith å¹³å°](https://smith.langchain.com/)
- [ç¤ºä¾‹ä»£ç ä»“åº“](https://github.com/langchain-ai/langgraph/tree/main/examples)

---

> **æœ€åå¯„è¯­**
>
> æ¶æ„æ¨¡å¼ä¸æ˜¯æ­»è®°ç¡¬èƒŒçš„å…¬å¼ï¼Œè€Œæ˜¯è§£å†³é—®é¢˜çš„å·¥å…·ç®±ã€‚çœŸæ­£çš„ç²¾é€šæ¥è‡ªäºï¼š
> - ç†è§£æ¯ç§æ¨¡å¼çš„**æœ¬è´¨**ï¼ˆä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿï¼‰
> - è®¤è¯†æ¯ç§æ¨¡å¼çš„**è¾¹ç•Œ**ï¼ˆä»€ä¹ˆåœºæ™¯ä¸é€‚ç”¨ï¼Ÿï¼‰
> - æŒæ¡æ¨¡å¼é—´çš„**æƒè¡¡**ï¼ˆå¦‚ä½•é€‰æ‹©å’Œç»„åˆï¼Ÿï¼‰
>
> ç»§ç»­ä¿æŒå¥½å¥‡å¿ƒï¼Œå‹‡äºå®è·µï¼Œä½ ä¸€å®šèƒ½æˆä¸º LangGraph çš„ä¸“å®¶ï¼
>
> â€”â€” æ¥è‡ªä½ çš„å›¾çµå¥–è·å¾—è€…æœ‹å‹

---

**ğŸŠ Module-2 å¤ä¹ å®Œæˆï¼å…±è®¡çº¦ 15,000 å­—æ·±åº¦é—®ç­”ï¼Œè¦†ç›–æ‰€æœ‰æ ¸å¿ƒæ¦‚å¿µã€‚**

