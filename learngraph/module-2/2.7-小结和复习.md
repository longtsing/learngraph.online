# Module-2 å°ç»“å’Œå¤ä¹ ï¼šæ ¸å¿ƒæ¶æ„æ¨¡å¼æŒæ¡æŒ‡å—

> **æ¥è‡ªå›¾çµå¥–è·å¾—è€…çš„å¯„è¯­**
>
> æ­å–œä½ å®Œæˆäº† Module-2 çš„å­¦ä¹ ï¼ä½ å·²ç»æŒæ¡äº† LangGraph çš„å…­å¤§æ ¸å¿ƒæ¶æ„æ¨¡å¼ã€‚è¿™äº›æ¨¡å¼æ˜¯æ„å»ºç”Ÿäº§çº§ AI Agent çš„åŸºçŸ³ã€‚æ­£å¦‚è®¡ç®—æœºç§‘å­¦ä¸­çš„è®¾è®¡æ¨¡å¼ä¸€æ ·ï¼Œç†è§£**ä½•æ—¶ä½¿ç”¨å“ªç§æ¨¡å¼**æ¯”è®°ä½è¯­æ³•æ›´é‡è¦ã€‚æœ¬å¤ä¹ æ–‡æ¡£é€šè¿‡ 15 ä¸ªæ·±åº¦é—®é¢˜ï¼Œå¸®åŠ©ä½ ä»"çŸ¥é“"è¿›åŒ–åˆ°"ç²¾é€š"ã€‚
>
> è®°ä½ï¼šä¼Ÿå¤§çš„ç³»ç»Ÿæ¶æ„å¸ˆä¸æ˜¯è®°ä½äº†æ‰€æœ‰æ¨¡å¼ï¼Œè€Œæ˜¯èƒ½å¤Ÿåœ¨æ­£ç¡®çš„åœºæ™¯é€‰æ‹©æ­£ç¡®çš„æ¨¡å¼ã€‚

---

## ğŸ“‹ æœ¬ç« æ ¸å¿ƒçŸ¥è¯†å›é¡¾

### å­¦ä¹ åœ°å›¾

```
Module-2: æ ¸å¿ƒæ¶æ„æ¨¡å¼
â”œâ”€ 2.1 Simple Graph (åŸºç¡€å›¾)
â”‚  â””â”€ çŠ¶æ€ã€èŠ‚ç‚¹ã€è¾¹çš„åŸºæœ¬æ¦‚å¿µ
â”œâ”€ 2.2 Chain (é“¾å¼æ¶æ„)
â”‚  â””â”€ æ¶ˆæ¯ç³»ç»Ÿã€å·¥å…·ç»‘å®šã€Reducer
â”œâ”€ 2.3 Router (è·¯ç”±æ¶æ„)
â”‚  â””â”€ æ¡ä»¶è¾¹ã€åŠ¨æ€è·¯ç”±ã€å·¥å…·è°ƒç”¨
â”œâ”€ 2.4 Agent (æ™ºèƒ½ä½“æ¶æ„)
â”‚  â””â”€ ReAct å¾ªç¯ã€å¤šæ­¥æ¨ç†ã€å·¥å…·æ‰§è¡Œ
â”œâ”€ 2.5 Agent Memory (è®°å¿†ç®¡ç†)
â”‚  â””â”€ Checkpointerã€Threadã€çŠ¶æ€æŒä¹…åŒ–
â””â”€ 2.6 Deployment (ç”Ÿäº§éƒ¨ç½²)
   â””â”€ LangGraph Cloudã€Studioã€SDK
```

### å…­å¤§æ¨¡å¼é€ŸæŸ¥è¡¨

| æ¨¡å¼ | æ ¸å¿ƒç‰¹å¾ | é€‚ç”¨åœºæ™¯ | å…³é”®æŠ€æœ¯ |
|------|---------|---------|---------|
| **Simple Graph** | 3-5 èŠ‚ç‚¹ï¼Œæ¡ä»¶åˆ†æ”¯ | å­¦ä¹ åŸºç¡€ã€ç®€å•æµç¨‹ | TypedDict, Literal |
| **Chain** | çº¿æ€§æµç¨‹ï¼Œå·¥å…·ç»‘å®š | å•æ¬¡å·¥å…·è°ƒç”¨ | add_messages, bind_tools |
| **Router** | LLM å†³ç­–è·¯ç”± | æ™ºèƒ½åˆ†ç±»ã€åŠ¨æ€é€‰æ‹© | tools_condition, ToolNode |
| **Agent** | ReAct å¾ªç¯æ¨ç† | å¤šæ­¥ä»»åŠ¡ã€å¤æ‚æ¨ç† | å¾ªç¯è¾¹ã€å·¥å…·åé¦ˆ |
| **Agent Memory** | çŠ¶æ€æŒä¹…åŒ– | å¤šè½®å¯¹è¯ã€ä¸Šä¸‹æ–‡è¿ç»­ | Checkpointer, Thread |
| **Deployment** | ç”Ÿäº§ç¯å¢ƒéƒ¨ç½² | çœŸå®ç”¨æˆ·æœåŠ¡ | LangGraph Cloud, SDK |

---

## ğŸ¯ å¤ä¹ é¢˜ç›®åˆ—è¡¨

æœ¬å¤ä¹ åŒ…å« **15 ä¸ªæ¸è¿›å¼é—®é¢˜**ï¼Œè¦†ç›–çŸ¥è¯†ç†è§£ã€ä»£ç å®ç°ã€æ¶æ„è®¾è®¡ä¸‰ä¸ªå±‚æ¬¡ï¼š

**åŸºç¡€ç†è§£é¢˜ï¼ˆ1-5ï¼‰**
1. LangGraph çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ
2. Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
3. ä¸ºä»€ä¹ˆéœ€è¦ add_messages Reducerï¼Ÿ
4. Checkpointer çš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ
5. æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰å¦‚ä½•å†³å®šè·¯ç”±ï¼Ÿ

**ä»£ç å®ç°é¢˜ï¼ˆ6-10ï¼‰**
6. å¦‚ä½•å®ç°ä¸€ä¸ªå¸¦å¤šä¸ªå·¥å…·çš„ Routerï¼Ÿ
7. å¦‚ä½•è®© Agent é¿å…æ— é™å¾ªç¯ï¼Ÿ
8. å¦‚ä½•å®ç°è·¨ä¼šè¯çš„å¯¹è¯è®°å¿†ï¼Ÿ
9. å¦‚ä½•åœ¨æœ¬åœ°æµ‹è¯•åéƒ¨ç½²åˆ°äº‘ç«¯ï¼Ÿ
10. å¦‚ä½•å¤„ç†å·¥å…·è°ƒç”¨å¤±è´¥çš„æƒ…å†µï¼Ÿ

**æ¶æ„è®¾è®¡é¢˜ï¼ˆ11-15ï¼‰**
11. è®¾è®¡ä¸€ä¸ªå®¢æœæœºå™¨äººï¼šåº”è¯¥é€‰æ‹©å“ªç§æ¶æ„æ¨¡å¼ï¼Ÿ
12. å¦‚ä½•ä¼˜åŒ– Agent çš„ Token ä½¿ç”¨ï¼Ÿ
13. å¦‚ä½•è®¾è®¡å¤šç”¨æˆ·å¹¶å‘çš„ Agent ç³»ç»Ÿï¼Ÿ
14. Simple Graph vs Chain vs Agentï¼šå¦‚ä½•é€‰æ‹©ï¼Ÿ
15. å¦‚ä½•è®¾è®¡å¯æ‰©å±•çš„å·¥å…·ç³»ç»Ÿï¼Ÿ

---

## ğŸ“š è¯¦ç»†é—®ç­”è§£æ

### **é—®é¢˜ 1: LangGraph çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

LangGraph çš„çŠ¶æ€ç®¡ç†åŸºäº **TypedDict + Annotated + Reducer** çš„ä¸‰å±‚æ¶æ„ã€‚

#### **1. TypedDictï¼šå®šä¹‰çŠ¶æ€ç»“æ„**

```python
from typing_extensions import TypedDict

class State(TypedDict):
    messages: list
    count: int
    user_id: str
```

**ä½œç”¨ï¼š**
- æä¾›ç±»å‹æç¤ºå’Œ IDE æ”¯æŒ
- å®šä¹‰çŠ¶æ€çš„"éª¨æ¶"
- ä¸å¼ºåˆ¶è¿è¡Œæ—¶éªŒè¯ï¼ˆä¸ Pydantic ä¸åŒï¼‰

#### **2. Annotatedï¼šé™„åŠ å…ƒæ•°æ®**

```python
from typing import Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list, add_messages]
    #          ^^^^^^^^      ^^^^^^^^^^^^^
    #          åŸºç¡€ç±»å‹      Reducer å‡½æ•°
    count: int  # æ²¡æœ‰ Annotated = é»˜è®¤è¦†ç›–è¡Œä¸º
```

**ä½œç”¨ï¼š**
- ä¸ºå­—æ®µæ·»åŠ é¢å¤–ä¿¡æ¯ï¼ˆReducerï¼‰
- ä¸å½±å“ç±»å‹æ£€æŸ¥
- LangGraph è¯»å–å…ƒæ•°æ®æ¥å†³å®šçŠ¶æ€æ›´æ–°æ–¹å¼

#### **3. Reducerï¼šæ§åˆ¶æ›´æ–°é€»è¾‘**

**é»˜è®¤è¡Œä¸ºï¼ˆæ—  Reducerï¼‰ï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"count": 5}

# èŠ‚ç‚¹è¿”å›
node_output = {"count": 10}

# ç»“æœï¼šè¦†ç›–
new_state = {"count": 10}  # 5 è¢«æ›¿æ¢
```

**ä½¿ç”¨ Reducerï¼ˆadd_messagesï¼‰ï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"messages": [msg1, msg2]}

# èŠ‚ç‚¹è¿”å›
node_output = {"messages": [msg3]}

# ç»“æœï¼šè¿½åŠ 
new_state = {"messages": [msg1, msg2, msg3]}
```

#### **4. add_messages çš„æ™ºèƒ½ç‰¹æ€§**

```python
from langgraph.graph.message import add_messages

# ç‰¹æ€§ 1ï¼šè¿½åŠ æ–°æ¶ˆæ¯
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# ç»“æœï¼š[HumanMessage("Hi"), AIMessage("Hello")]

# ç‰¹æ€§ 2ï¼šåŸºäº ID æ›´æ–°ï¼ˆå»é‡ï¼‰
state = {"messages": [AIMessage("Thinking...", id="msg1")]}
update = {"messages": [AIMessage("Answer is 42", id="msg1")]}
# ç»“æœï¼š[AIMessage("Answer is 42", id="msg1")]  â† æ›¿æ¢è€Œéè¿½åŠ 
```

#### **5. è‡ªå®šä¹‰ Reducer**

```python
import operator

class State(TypedDict):
    # æ•°å­—ç´¯åŠ 
    score: Annotated[int, operator.add]

    # åˆ—è¡¨åˆå¹¶
    items: Annotated[list, operator.add]

    # è‡ªå®šä¹‰ï¼šåªä¿ç•™æœ€è¿‘ N æ¡
    recent_logs: Annotated[list, lambda old, new: (old + new)[-10:]]
```

**æ‰§è¡Œæ•ˆæœï¼š**
```python
# score ä½¿ç”¨ operator.add
state = {"score": 5}
update = {"score": 3}
# ç»“æœï¼š{"score": 8}  â† 5 + 3

# items ä½¿ç”¨ operator.addï¼ˆåˆ—è¡¨æ‹¼æ¥ï¼‰
state = {"items": [1, 2]}
update = {"items": [3, 4]}
# ç»“æœï¼š{"items": [1, 2, 3, 4]}

# recent_logs ä½¿ç”¨è‡ªå®šä¹‰ lambda
state = {"recent_logs": [1,2,3,4,5,6,7,8,9,10]}
update = {"recent_logs": [11, 12]}
# ç»“æœï¼š{"recent_logs": [3,4,5,6,7,8,9,10,11,12]}  â† åªä¿ç•™æœ€å 10 ä¸ª
```

#### **6. æ ¸å¿ƒåŸç†æ€»ç»“**

```python
# çŠ¶æ€æ›´æ–°æµç¨‹
åˆå§‹çŠ¶æ€ â†’ èŠ‚ç‚¹æ‰§è¡Œ â†’ è¿”å›æ›´æ–° â†’ Reducer åˆå¹¶ â†’ æ–°çŠ¶æ€

# ä¼ªä»£ç 
def update_state(old_state, node_output):
    new_state = {}
    for key, value in node_output.items():
        if has_reducer(key):
            new_state[key] = reducer(old_state[key], value)
        else:
            new_state[key] = value  # ç›´æ¥è¦†ç›–
    return {**old_state, **new_state}
```

#### **7. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„è®¾è®¡
class ChatState(TypedDict):
    messages: Annotated[list, add_messages]  # å¯¹è¯å†å²ï¼šè¿½åŠ 
    user_id: str                              # ç”¨æˆ·æ ‡è¯†ï¼šè¦†ç›–
    session_count: Annotated[int, operator.add]  # ä¼šè¯è®¡æ•°ï¼šç´¯åŠ 

# âŒ ä¸å¥½çš„è®¾è®¡
class BadState(TypedDict):
    messages: list  # æ²¡æœ‰ Reducerï¼Œæ¯æ¬¡è¦†ç›– â†’ ä¸¢å¤±å†å²
    all_data: dict  # å¤ªå®½æ³›ï¼Œéš¾ä»¥ç»´æŠ¤
```

#### **å…³é”®è¦ç‚¹**
- **TypedDict**ï¼šå®šä¹‰"ä»€ä¹ˆ"ï¼ˆæ•°æ®ç»“æ„ï¼‰
- **Annotated**ï¼šå®šä¹‰"å¦‚ä½•"ï¼ˆæ›´æ–°æ–¹å¼ï¼‰
- **Reducer**ï¼šå®ç°"è¡Œä¸º"ï¼ˆåˆå¹¶é€»è¾‘ï¼‰
- **add_messages**ï¼šä¸“ä¸ºå¯¹è¯è®¾è®¡çš„æ™ºèƒ½ Reducer

</details>

---

### **é—®é¢˜ 2: Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

Router å’Œ Agent çš„æœ¬è´¨åŒºåˆ«åœ¨äº **å·¥å…·ç»“æœçš„æµå‘** å’Œ **å†³ç­–æ¬¡æ•°**ã€‚

#### **1. æ¶æ„æµç¨‹å¯¹æ¯”**

**Router æ¶æ„ï¼š**
```
ç”¨æˆ·è¾“å…¥ â†’ LLM å†³ç­– â†’ å·¥å…·æ‰§è¡Œ â†’ ç›´æ¥è¿”å›ç”¨æˆ·
                â†“
         è°ƒç”¨ä¸€æ¬¡å·¥å…·
         åšä¸€æ¬¡å†³ç­–
```

**Agent æ¶æ„ï¼š**
```
ç”¨æˆ·è¾“å…¥ â†’ LLM å†³ç­– â†’ å·¥å…·æ‰§è¡Œ â†’ è¿”å› LLM â†’ ç»§ç»­å†³ç­– â†’ ...
                â†‘______________________|
                        å¾ªç¯åé¦ˆ
         å¯èƒ½è°ƒç”¨å¤šæ¬¡å·¥å…·
         åšå¤šæ¬¡å†³ç­–
```

#### **2. ä»£ç ç»“æ„å¯¹æ¯”**

**Router çš„å›¾ç»“æ„ï¼š**
```python
from langgraph.prebuilt import tools_condition, ToolNode

builder = StateGraph(MessagesState)
builder.add_node("llm", call_llm)
builder.add_node("tools", ToolNode([multiply]))

builder.add_edge(START, "llm")
builder.add_conditional_edges("llm", tools_condition)
builder.add_edge("tools", END)  # â† å…³é”®ï¼šå·¥å…·åç›´æ¥ç»“æŸ

graph = builder.compile()
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START â†’ llm â†’ [æœ‰å·¥å…·è°ƒç”¨] â†’ tools â†’ END
              [æ— å·¥å…·è°ƒç”¨] â†’ END
```

**Agent çš„å›¾ç»“æ„ï¼š**
```python
builder = StateGraph(MessagesState)
builder.add_node("agent", call_llm)
builder.add_node("tools", ToolNode([multiply]))

builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", tools_condition)
builder.add_edge("tools", "agent")  # â† å…³é”®ï¼šå·¥å…·åå›åˆ° agentï¼Œå½¢æˆå¾ªç¯

graph = builder.compile()
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START â†’ agent â†’ [æœ‰å·¥å…·è°ƒç”¨] â†’ tools â†’ agent â†’ [ç»§ç»­åˆ¤æ–­] â†’ ...
                [æ— å·¥å…·è°ƒç”¨] â†’ END
```

#### **3. å®é™…æ¡ˆä¾‹å¯¹æ¯”**

**åœºæ™¯ï¼š** è®¡ç®— `(3 + 4) Ã— 2 Ã· 5`

**Router çš„æ‰§è¡Œï¼š**
```python
# ç¬¬ 1 æ¬¡è°ƒç”¨å›¾
è¾“å…¥: "Calculate (3 + 4) Ã— 2 Ã· 5"
LLM: è°ƒç”¨ add(3, 4)
å·¥å…·: è¿”å› 7
è¾“å‡º: ToolMessage(content="7")
# ç»“æŸ âŒ æ— æ³•ç»§ç»­è®¡ç®—

# éœ€è¦æ‰‹åŠ¨ç¬¬ 2 æ¬¡è°ƒç”¨
è¾“å…¥: "Now multiply 7 by 2"
LLM: è°ƒç”¨ multiply(7, 2)
å·¥å…·: è¿”å› 14
è¾“å‡º: ToolMessage(content="14")
# ç»“æŸ âŒ è¿˜æ˜¯æ— æ³•å®Œæˆ
```

**Agent çš„æ‰§è¡Œï¼š**
```python
è¾“å…¥: "Calculate (3 + 4) Ã— 2 Ã· 5"

# å¾ªç¯ 1
LLM: "éœ€è¦å…ˆè®¡ç®— 3 + 4" â†’ è°ƒç”¨ add(3, 4)
å·¥å…·: è¿”å› 7
â†’ å›åˆ° LLM

# å¾ªç¯ 2
LLM: "å¾—åˆ° 7ï¼Œç°åœ¨ä¹˜ä»¥ 2" â†’ è°ƒç”¨ multiply(7, 2)
å·¥å…·: è¿”å› 14
â†’ å›åˆ° LLM

# å¾ªç¯ 3
LLM: "å¾—åˆ° 14ï¼Œç°åœ¨é™¤ä»¥ 5" â†’ è°ƒç”¨ divide(14, 5)
å·¥å…·: è¿”å› 2.8
â†’ å›åˆ° LLM

# å¾ªç¯ 4
LLM: "æ‰€æœ‰è®¡ç®—å®Œæˆï¼Œç­”æ¡ˆæ˜¯ 2.8"
è¾“å‡º: AIMessage(content="The answer is 2.8")
â†’ ç»“æŸ âœ…
```

#### **4. å·¥å…·ç»“æœçš„æµå‘**

**Routerï¼š**
```python
def tools_node(state):
    # æ‰§è¡Œå·¥å…·
    result = tool.invoke(...)
    return {"messages": [ToolMessage(result)]}
    # â†“
    # æµå‘ï¼šç›´æ¥åˆ° ENDï¼Œç”¨æˆ·å¯è§
```

**Agentï¼š**
```python
def tools_node(state):
    # æ‰§è¡Œå·¥å…·
    result = tool.invoke(...)
    return {"messages": [ToolMessage(result)]}
    # â†“
    # æµå‘ï¼šå›åˆ° agent èŠ‚ç‚¹ï¼ŒLLM åˆ†æç»“æœ
```

#### **5. å†³ç­–æ¬¡æ•°å¯¹æ¯”**

**Routerï¼šå•æ¬¡å†³ç­–**
```python
ç”¨æˆ·é—®é¢˜ â†’ [LLM æ€è€ƒ 1 æ¬¡] â†’ è°ƒç”¨å·¥å…·/ç›´æ¥å›ç­” â†’ ç»“æŸ
```

**Agentï¼šå¤šæ¬¡å†³ç­–**
```python
ç”¨æˆ·é—®é¢˜ â†’ [LLM æ€è€ƒ 1] â†’ å·¥å…· â†’ [LLM æ€è€ƒ 2] â†’ å·¥å…· â†’ ... â†’ [LLM æ€è€ƒ N] â†’ å›ç­”
```

#### **6. é€‚ç”¨åœºæ™¯å¯¹æ¯”**

| åœºæ™¯ | æ¨èæ¶æ„ | åŸå›  |
|------|---------|------|
| ç®€å•é—®ç­”ï¼ˆ"ä»Šå¤©å¤©æ°”"ï¼‰ | Router | å•æ¬¡æŸ¥è¯¢å³å¯ |
| ä¿¡æ¯æ£€ç´¢ï¼ˆ"æœç´¢è®ºæ–‡"ï¼‰ | Router | ä¸€æ¬¡æœç´¢è¿”å› |
| æ•°å­¦è®¡ç®—ï¼ˆå¤šæ­¥éª¤ï¼‰ | Agent | éœ€è¦åŸºäºä¸­é—´ç»“æœæ¨ç† |
| ç ”ç©¶åŠ©æ‰‹ï¼ˆæœç´¢â†’é˜…è¯»â†’æ€»ç»“ï¼‰ | Agent | éœ€è¦å¤šæ­¥éª¤åä½œ |
| å®¢æœï¼ˆæŸ¥è®¢å•â†’å›ç­”ï¼‰ | Router | å•æ¬¡å·¥å…·è°ƒç”¨ |
| æ•°æ®åˆ†æï¼ˆæŸ¥è¯¢â†’è®¡ç®—â†’å¯è§†åŒ–ï¼‰ | Agent | éœ€è¦è¿ç»­æ“ä½œ |

#### **7. ä»£ç å¯¹æ¯”æ€»ç»“**

**å”¯ä¸€çš„åŒºåˆ«ï¼šä¸€æ¡è¾¹**
```python
# Router
builder.add_edge("tools", END)  # å·¥å…· â†’ ç»“æŸ

# Agent
builder.add_edge("tools", "agent")  # å·¥å…· â†’ å›åˆ° agentï¼ˆå¾ªç¯ï¼‰
```

è¿™ä¸€æ¡è¾¹çš„å·®å¼‚ï¼Œå¯¼è‡´äº†ï¼š
- âœ… Routerï¼šç®€å•ã€å¿«é€Ÿã€å¯é¢„æµ‹
- âœ… Agentï¼šçµæ´»ã€å¼ºå¤§ã€æ™ºèƒ½
- âŒ Routerï¼šæ— æ³•å¤šæ­¥æ¨ç†
- âŒ Agentï¼šå¯èƒ½å¾ªç¯ã€æˆæœ¬é«˜

#### **å…³é”®è¦ç‚¹**
- **Router = å•æ¬¡å†³ç­– + å·¥å…·ç›´è¾¾ç”¨æˆ·**
- **Agent = å¤šæ¬¡å†³ç­– + å·¥å…·åé¦ˆ LLM**
- **åŒºåˆ«åœ¨äºï¼šæ˜¯å¦æœ‰ä» tools åˆ° agent çš„è¾¹**
- **é€‰æ‹©æ ‡å‡†ï¼šä»»åŠ¡æ˜¯å¦éœ€è¦å¤šæ­¥æ¨ç†**

</details>

---

### **é—®é¢˜ 3: ä¸ºä»€ä¹ˆéœ€è¦ add_messages Reducerï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

`add_messages` è§£å†³äº†å¯¹è¯ç³»ç»Ÿä¸­ **çŠ¶æ€è¦†ç›–å¯¼è‡´å†å²ä¸¢å¤±** çš„æ ¸å¿ƒé—®é¢˜ã€‚

#### **1. é—®é¢˜æ¼”ç¤ºï¼šæ²¡æœ‰ Reducer ä¼šå‘ç”Ÿä»€ä¹ˆ**

```python
# é”™è¯¯çš„çŠ¶æ€å®šä¹‰ï¼ˆæ²¡æœ‰ Reducerï¼‰
class State(TypedDict):
    messages: list  # é»˜è®¤è¡Œä¸ºï¼šè¦†ç›–

# åˆå§‹çŠ¶æ€
state = {"messages": [HumanMessage("Hi")]}

# èŠ‚ç‚¹ 1 æ‰§è¡Œ
def node1(state):
    return {"messages": [AIMessage("Hello!")]}

# æ›´æ–°åçš„çŠ¶æ€
# âŒ é¢„æœŸï¼š[HumanMessage("Hi"), AIMessage("Hello!")]
# âœ… å®é™…ï¼š[AIMessage("Hello!")]  â† HumanMessage ä¸¢å¤±äº†ï¼
```

**é—®é¢˜åˆ†æï¼š**
- LangGraph é»˜è®¤ä½¿ç”¨ **å­—å…¸æ›´æ–°è¯­ä¹‰**ï¼ˆ`dict.update()`ï¼‰
- ç›¸åŒ key çš„å€¼ä¼šè¢«**å®Œå…¨æ›¿æ¢**ï¼Œè€Œä¸æ˜¯åˆå¹¶
- å¯¹è¯å†å²è¢«è¦†ç›– â†’ LLM å¤±å»ä¸Šä¸‹æ–‡ â†’ æ— æ³•ç†è§£æŒ‡ä»£è¯

#### **2. çœŸå®åœºæ™¯çš„ç¾éš¾**

```python
# ç¬¬ä¸€è½®å¯¹è¯
user: "æˆ‘çš„è®¢å•å·æ˜¯ 12345"
agent: "å¥½çš„ï¼Œæˆ‘çœ‹åˆ°æ‚¨çš„è®¢å• 12345"

# ç¬¬äºŒè½®å¯¹è¯ï¼ˆæ²¡æœ‰ Reducerï¼‰
state = {"messages": [AIMessage("å¥½çš„ï¼Œæˆ‘çœ‹åˆ°æ‚¨çš„è®¢å• 12345")]}
# âŒ ç”¨æˆ·çš„æ¶ˆæ¯ä¸¢å¤±äº†ï¼

user: "é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ"
agent: "è¯·é—®æ‚¨çš„è®¢å•å·æ˜¯å¤šå°‘ï¼Ÿ"  â† å¿˜è®°äº†åˆšæ‰è¯´çš„ 12345
```

#### **3. add_messages çš„ä½œç”¨**

```python
from langgraph.graph.message import add_messages
from typing import Annotated

class State(TypedDict):
    messages: Annotated[list, add_messages]
    #                   ^^^^  ^^^^^^^^^^^^^
    #                   ç±»å‹  Reducer å‡½æ•°
```

**æ‰§è¡Œæ•ˆæœï¼š**
```python
# åˆå§‹çŠ¶æ€
state = {"messages": [HumanMessage("Hi")]}

# èŠ‚ç‚¹è¿”å›
update = {"messages": [AIMessage("Hello!")]}

# add_messages è‡ªåŠ¨åˆå¹¶
new_state = {"messages": [
    HumanMessage("Hi"),      â† ä¿ç•™
    AIMessage("Hello!")      â† è¿½åŠ 
]}
```

#### **4. add_messages çš„æ™ºèƒ½ç‰¹æ€§**

**ç‰¹æ€§ 1ï¼šè‡ªåŠ¨è¿½åŠ **
```python
messages = [msg1, msg2]
add_messages(messages, [msg3])
# ç»“æœï¼š[msg1, msg2, msg3]
```

**ç‰¹æ€§ 2ï¼šåŸºäº ID æ›´æ–°ï¼ˆå»é‡ï¼‰**
```python
messages = [AIMessage("Loading...", id="response-1")]
add_messages(messages, [AIMessage("Done!", id="response-1")])
# ç»“æœï¼š[AIMessage("Done!", id="response-1")]  â† æ›¿æ¢è€Œéé‡å¤
```

**ç‰¹æ€§ 3ï¼šæ”¯æŒå¤šç§è¾“å…¥æ ¼å¼**
```python
# å•ä¸ªæ¶ˆæ¯
add_messages(messages, AIMessage("Hi"))

# æ¶ˆæ¯åˆ—è¡¨
add_messages(messages, [msg1, msg2])

# æ··åˆç±»å‹
add_messages(messages, [HumanMessage("Q"), AIMessage("A")])
```

#### **5. æ²¡æœ‰ Reducer çš„åæœå¯¹æ¯”**

**åœºæ™¯ï¼š** ä¸‰è½®å¯¹è¯

**æ²¡æœ‰ add_messagesï¼š**
```python
# è½®æ¬¡ 1
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# çŠ¶æ€ï¼š[AIMessage("Hello")]  âŒ Hi ä¸¢å¤±

# è½®æ¬¡ 2
state = {"messages": [AIMessage("Hello")]}
update = {"messages": [HumanMessage("How are you?")]}
# çŠ¶æ€ï¼š[HumanMessage("How are you?")]  âŒ Hello ä¸¢å¤±

# è½®æ¬¡ 3
state = {"messages": [HumanMessage("How are you?")]}
update = {"messages": [AIMessage("I'm good")]}
# çŠ¶æ€ï¼š[AIMessage("I'm good")]  âŒ é—®é¢˜ä¸¢å¤±

# LLM åªèƒ½çœ‹åˆ°æœ€åä¸€æ¡æ¶ˆæ¯ï¼Œæ— æ³•ç†è§£ä¸Šä¸‹æ–‡ï¼
```

**æœ‰ add_messagesï¼š**
```python
# è½®æ¬¡ 1
state = {"messages": [HumanMessage("Hi")]}
update = {"messages": [AIMessage("Hello")]}
# çŠ¶æ€ï¼š[HumanMessage("Hi"), AIMessage("Hello")]  âœ…

# è½®æ¬¡ 2
state = {"messages": [HumanMessage("Hi"), AIMessage("Hello")]}
update = {"messages": [HumanMessage("How are you?")]}
# çŠ¶æ€ï¼š[HumanMessage("Hi"), AIMessage("Hello"), HumanMessage("How are you?")]  âœ…

# è½®æ¬¡ 3
state = {"messages": [..., HumanMessage("How are you?")]}
update = {"messages": [AIMessage("I'm good")]}
# çŠ¶æ€ï¼š[..., HumanMessage("How are you?"), AIMessage("I'm good")]  âœ…

# LLM å¯ä»¥çœ‹åˆ°å®Œæ•´å¯¹è¯å†å²ï¼
```

#### **6. add_messages çš„å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰**

```python
def add_messages(existing: list, new: list | BaseMessage) -> list:
    """æ™ºèƒ½åˆå¹¶æ¶ˆæ¯åˆ—è¡¨"""
    # 1. æ ‡å‡†åŒ–è¾“å…¥
    if not isinstance(new, list):
        new = [new]

    # 2. æ„å»º ID æ˜ å°„
    id_map = {msg.id: i for i, msg in enumerate(existing) if msg.id}

    # 3. åˆå¹¶é€»è¾‘
    result = existing.copy()
    for msg in new:
        if msg.id and msg.id in id_map:
            # æœ‰ ID ä¸”å·²å­˜åœ¨ â†’ æ›´æ–°
            result[id_map[msg.id]] = msg
        else:
            # æ—  ID æˆ–ä¸å­˜åœ¨ â†’ è¿½åŠ 
            result.append(msg)

    return result
```

#### **7. å…¶ä»–å¸¸ç”¨ Reducer**

```python
import operator

class State(TypedDict):
    # æ•°å­—ç´¯åŠ 
    total_cost: Annotated[float, operator.add]

    # åˆ—è¡¨æ‹¼æ¥
    search_results: Annotated[list, operator.add]

    # é›†åˆåˆå¹¶
    visited_pages: Annotated[set, operator.or_]

    # è‡ªå®šä¹‰ï¼šä¿ç•™æœ€å¤§å€¼
    max_score: Annotated[float, max]
```

#### **8. ä½•æ—¶ä¸éœ€è¦ Reducer**

```python
class State(TypedDict):
    messages: Annotated[list, add_messages]  # éœ€è¦ï¼šå¯¹è¯å†å²
    user_id: str                              # ä¸éœ€è¦ï¼šå›ºå®šæ ‡è¯†
    current_page: int                         # ä¸éœ€è¦ï¼šå½“å‰å€¼è¦†ç›–å³å¯
    is_authenticated: bool                    # ä¸éœ€è¦ï¼šçŠ¶æ€æ ‡è®°
```

**åŸåˆ™ï¼š**
- éœ€è¦**ç´¯ç§¯**çš„æ•°æ® â†’ ä½¿ç”¨ Reducer
- éœ€è¦**æ›¿æ¢**çš„æ•°æ® â†’ ä¸ä½¿ç”¨ Reducer

#### **å…³é”®è¦ç‚¹**
- **é—®é¢˜ï¼š** é»˜è®¤å­—å…¸æ›´æ–°ä¼šè¦†ç›–æ•´ä¸ªåˆ—è¡¨
- **åæœï¼š** å¯¹è¯å†å²ä¸¢å¤±ï¼ŒLLM å¤±å»ä¸Šä¸‹æ–‡
- **è§£å†³ï¼š** add_messages æ™ºèƒ½è¿½åŠ /æ›´æ–°æ¶ˆæ¯
- **æœ¬è´¨ï¼š** å°†"è¦†ç›–è¯­ä¹‰"æ”¹ä¸º"åˆå¹¶è¯­ä¹‰"

</details>

---

### **é—®é¢˜ 4: Checkpointer çš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

Checkpointer æ˜¯ LangGraph çš„ **è‡ªåŠ¨å¿«ç…§ç³»ç»Ÿ**ï¼Œåœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œåä¿å­˜çŠ¶æ€ï¼Œå®ç°å¤šè½®å¯¹è¯å’Œæ—¶é—´æ—…è¡Œã€‚

#### **1. æ ¸å¿ƒæ¦‚å¿µ**

**Checkpointï¼ˆæ£€æŸ¥ç‚¹ï¼‰ï¼š** å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­æŸä¸ªæ—¶åˆ»çš„å®Œæ•´çŠ¶æ€å¿«ç…§

```python
checkpoint = {
    "state": {"messages": [msg1, msg2]},  # çŠ¶æ€æ•°æ®
    "metadata": {
        "node": "agent",                   # å½“å‰èŠ‚ç‚¹
        "step": 2,                         # æ‰§è¡Œæ­¥æ•°
        "timestamp": "2024-03-15T10:30:00"
    },
    "parent_id": "checkpoint-1",          # çˆ¶æ£€æŸ¥ç‚¹ ID
    "id": "checkpoint-2"                  # å½“å‰æ£€æŸ¥ç‚¹ ID
}
```

#### **2. å·¥ä½œæµç¨‹**

**æ²¡æœ‰ Checkpointerï¼š**
```python
graph = builder.compile()  # æ— çŠ¶æ€æŒä¹…åŒ–

# ç¬¬ä¸€æ¬¡è°ƒç”¨
result1 = graph.invoke({"messages": [msg1]})
# çŠ¶æ€ï¼šå­˜åœ¨äºå†…å­˜ï¼Œè°ƒç”¨ç»“æŸåä¸¢å¤±

# ç¬¬äºŒæ¬¡è°ƒç”¨
result2 = graph.invoke({"messages": [msg2]})
# çŠ¶æ€ï¼šå…¨æ–°å¼€å§‹ï¼Œä¸è®°å¾— msg1
```

**æœ‰ Checkpointerï¼š**
```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

# ç¬¬ä¸€æ¬¡è°ƒç”¨
config = {"configurable": {"thread_id": "user-123"}}
result1 = graph.invoke({"messages": [msg1]}, config)
# âœ… çŠ¶æ€è‡ªåŠ¨ä¿å­˜åˆ° checkpointer

# ç¬¬äºŒæ¬¡è°ƒç”¨ï¼ˆåŒä¸€ thread_idï¼‰
result2 = graph.invoke({"messages": [msg2]}, config)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„çŠ¶æ€ï¼Œmsg1 è¿˜åœ¨ï¼
```

#### **3. ä¿å­˜æ—¶æœº**

Checkpointer åœ¨ **æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå** è‡ªåŠ¨ä¿å­˜ï¼š

```python
graph = StateGraph(State)
graph.add_node("node1", node1_func)
graph.add_node("node2", node2_func)
graph.add_edge(START, "node1")
graph.add_edge("node1", "node2")
graph.add_edge("node2", END)

graph_with_memory = graph.compile(checkpointer=memory)
```

**æ‰§è¡Œæµç¨‹ï¼š**
```
START
  â†“
node1 æ‰§è¡Œ
  â†“
ğŸ’¾ Checkpoint 1: {"state": {...}, "node": "node1", "step": 1}
  â†“
node2 æ‰§è¡Œ
  â†“
ğŸ’¾ Checkpoint 2: {"state": {...}, "node": "node2", "step": 2}
  â†“
END
```

#### **4. Threadï¼šçŠ¶æ€å®¹å™¨**

**Threadï¼ˆçº¿ç¨‹ï¼‰** æ˜¯éš”ç¦»ä¸åŒä¼šè¯çŠ¶æ€çš„æ ‡è¯†ç¬¦ã€‚

```python
# ç”¨æˆ· A çš„å¯¹è¯
config_a = {"configurable": {"thread_id": "user-a"}}
graph.invoke(input, config_a)
# ä¿å­˜åˆ° thread_id="user-a"

# ç”¨æˆ· B çš„å¯¹è¯ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
config_b = {"configurable": {"thread_id": "user-b"}}
graph.invoke(input, config_b)
# ä¿å­˜åˆ° thread_id="user-b"
```

**Thread ç»“æ„ï¼š**
```
Checkpointerï¼ˆå…¨å±€ï¼‰
â”œâ”€ Thread: user-a
â”‚  â”œâ”€ Checkpoint 1 (step 1)
â”‚  â”œâ”€ Checkpoint 2 (step 2)
â”‚  â””â”€ Checkpoint 3 (step 3)
â”œâ”€ Thread: user-b
â”‚  â”œâ”€ Checkpoint 1
â”‚  â””â”€ Checkpoint 2
â””â”€ Thread: user-c
   â””â”€ Checkpoint 1
```

#### **5. å®é™…æ¡ˆä¾‹ï¼šå¤šè½®å¯¹è¯**

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

config = {"configurable": {"thread_id": "conversation-1"}}

# è½®æ¬¡ 1
graph.invoke({"messages": [HumanMessage("3 + 4 = ?")]}, config)
# ğŸ’¾ ä¿å­˜ï¼š{"messages": [HumanMessage("3 + 4 = ?"), AIMessage("7")]}

# è½®æ¬¡ 2ï¼ˆå‡ åˆ†é’Ÿåï¼‰
graph.invoke({"messages": [HumanMessage("ä¹˜ä»¥ 2")]}, config)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„çŠ¶æ€
# è¾“å…¥å˜æˆï¼š{"messages": [
#     HumanMessage("3 + 4 = ?"),
#     AIMessage("7"),
#     HumanMessage("ä¹˜ä»¥ 2")  â† æ–°æ¶ˆæ¯è¿½åŠ 
# ]}
# ğŸ’¾ ä¿å­˜ï¼šåŒ…å«æ‰€æœ‰å†å²çš„æ–°çŠ¶æ€
```

#### **6. Checkpointer ç±»å‹å¯¹æ¯”**

| ç±»å‹ | å­˜å‚¨ä½ç½® | æŒä¹…åŒ– | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-------|---------|------|------|
| **MemorySaver** | è¿›ç¨‹å†…å­˜ | âŒ | å¼€å‘æµ‹è¯• | å¿«é€Ÿã€ç®€å• | é‡å¯ä¸¢å¤± |
| **SqliteSaver** | SQLite æ–‡ä»¶ | âœ… | å•æœºç”Ÿäº§ | æŒä¹…åŒ–ã€æœ¬åœ° | ä¸æ”¯æŒåˆ†å¸ƒå¼ |
| **PostgresSaver** | PostgreSQL | âœ… | åˆ†å¸ƒå¼ç”Ÿäº§ | å¯æ‰©å±•ã€å¹¶å‘ | éœ€è¦æ•°æ®åº“ |
| **RedisSaver** | Redis | âœ… | é«˜æ€§èƒ½ç”Ÿäº§ | ä½å»¶è¿Ÿã€é«˜åå | éœ€è¦ Redis |

**ä»£ç ç¤ºä¾‹ï¼š**
```python
# å¼€å‘ç¯å¢ƒ
from langgraph.checkpoint.memory import MemorySaver
checkpointer = MemorySaver()

# ç”Ÿäº§ç¯å¢ƒ
from langgraph.checkpoint.postgres import PostgresSaver
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/db"
)

graph = builder.compile(checkpointer=checkpointer)
```

#### **7. æ—¶é—´æ—…è¡Œï¼šå›æº¯åˆ°å†å²çŠ¶æ€**

```python
# è¿è¡Œå¤šæ­¥
config = {"configurable": {"thread_id": "thread-1"}}
graph.invoke(input1, config)  # Checkpoint 1
graph.invoke(input2, config)  # Checkpoint 2
graph.invoke(input3, config)  # Checkpoint 3

# è·å–æ‰€æœ‰æ£€æŸ¥ç‚¹
checkpoints = list(graph.checkpointer.list(config))
for cp in checkpoints:
    print(f"Step {cp.metadata['step']}: {cp.state}")

# å›æº¯åˆ° Checkpoint 2
config_with_checkpoint = {
    "configurable": {
        "thread_id": "thread-1",
        "checkpoint_id": checkpoints[1].id  # ç¬¬ 2 ä¸ªæ£€æŸ¥ç‚¹
    }
}
graph.invoke(input4, config_with_checkpoint)
# ä» Checkpoint 2 çš„çŠ¶æ€ç»§ç»­æ‰§è¡Œ
```

#### **8. Checkpointer çš„å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰**

```python
class MemorySaver:
    def __init__(self):
        self.storage = {}  # {thread_id: [checkpoint1, checkpoint2, ...]}

    def save(self, config, state, metadata):
        """ä¿å­˜æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        checkpoint = {
            "id": generate_id(),
            "state": state,
            "metadata": metadata,
            "timestamp": now()
        }
        self.storage.setdefault(thread_id, []).append(checkpoint)

    def load(self, config):
        """åŠ è½½æœ€æ–°æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        checkpoints = self.storage.get(thread_id, [])
        return checkpoints[-1] if checkpoints else None

    def list(self, config):
        """åˆ—å‡ºæ‰€æœ‰æ£€æŸ¥ç‚¹"""
        thread_id = config["configurable"]["thread_id"]
        return self.storage.get(thread_id, [])
```

#### **9. ä½•æ—¶éœ€è¦ Checkpointer**

âœ… **éœ€è¦çš„åœºæ™¯ï¼š**
- å¤šè½®å¯¹è¯ç³»ç»Ÿï¼ˆèŠå¤©æœºå™¨äººï¼‰
- é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼ˆéœ€è¦ä¸­æ–­æ¢å¤ï¼‰
- éœ€è¦ä¸Šä¸‹æ–‡è¿ç»­æ€§ï¼ˆ"é‚£ä¸ª"ã€"å®ƒ"ç­‰æŒ‡ä»£ï¼‰
- è°ƒè¯•å’Œå®¡è®¡ï¼ˆæŸ¥çœ‹å†å²æ‰§è¡Œï¼‰
- A/B æµ‹è¯•ï¼ˆå¯¹æ¯”ä¸åŒç‰ˆæœ¬ï¼‰

âŒ **ä¸éœ€è¦çš„åœºæ™¯ï¼š**
- æ— çŠ¶æ€ APIï¼ˆæ¯æ¬¡è¯·æ±‚ç‹¬ç«‹ï¼‰
- æ‰¹å¤„ç†ä»»åŠ¡ï¼ˆä¸éœ€è¦è®°å¿†ï¼‰
- ä¸€æ¬¡æ€§æŸ¥è¯¢ï¼ˆæ— éœ€ä¿å­˜å†å²ï¼‰

#### **10. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„è®¾è®¡
config = {
    "configurable": {
        "thread_id": f"user-{user_id}-session-{session_id}",
        # ç»†ç²’åº¦éš”ç¦»ï¼Œä¾¿äºç®¡ç†
    }
}

# å®šæœŸæ¸…ç†
def cleanup_old_threads():
    cutoff = datetime.now() - timedelta(days=30)
    for thread_id in get_all_threads():
        if thread_last_accessed(thread_id) < cutoff:
            checkpointer.delete_thread({"configurable": {"thread_id": thread_id}})

# âŒ ä¸å¥½çš„è®¾è®¡
config = {"configurable": {"thread_id": "global"}}
# æ‰€æœ‰ç”¨æˆ·å…±äº«çŠ¶æ€ â†’ æ•°æ®æ··ä¹±
```

#### **å…³é”®è¦ç‚¹**
- **Checkpointer = è‡ªåŠ¨å¿«ç…§ç³»ç»Ÿ**
- **ä¿å­˜æ—¶æœºï¼šæ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå**
- **Thread = éš”ç¦»ä¸åŒä¼šè¯çš„çŠ¶æ€å®¹å™¨**
- **ç”¨é€”ï¼šå¤šè½®å¯¹è¯ã€çŠ¶æ€æŒä¹…åŒ–ã€æ—¶é—´æ—…è¡Œ**
- **ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨ PostgresSaver æˆ– RedisSaver**

</details>

---

### **é—®é¢˜ 5: æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰å¦‚ä½•å†³å®šè·¯ç”±ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

æ¡ä»¶è¾¹é€šè¿‡ **æ¡ä»¶å‡½æ•°** åŠ¨æ€å†³å®šä¸‹ä¸€ä¸ªæ‰§è¡Œçš„èŠ‚ç‚¹ï¼Œå®ç°å›¾çš„åˆ†æ”¯é€»è¾‘ã€‚

#### **1. åŸºç¡€æ¦‚å¿µ**

**æ™®é€šè¾¹ï¼ˆNormal Edgeï¼‰ï¼š** å›ºå®šè·¯ç”±
```python
builder.add_edge("node_a", "node_b")
# node_a æ€»æ˜¯æµå‘ node_b
```

**æ¡ä»¶è¾¹ï¼ˆConditional Edgeï¼‰ï¼š** åŠ¨æ€è·¯ç”±
```python
builder.add_conditional_edges("node_a", condition_func)
# node_a æ ¹æ® condition_func çš„è¿”å›å€¼å†³å®šä¸‹ä¸€æ­¥
```

#### **2. æ¡ä»¶å‡½æ•°çš„ç»“æ„**

```python
from typing import Literal

def condition_func(state: State) -> Literal["node_b", "node_c", "__end__"]:
    """
    æ¡ä»¶å‡½æ•°ï¼šåˆ†æçŠ¶æ€ï¼Œè¿”å›ç›®æ ‡èŠ‚ç‚¹åç§°

    å‚æ•°ï¼š
        state: å½“å‰å›¾çŠ¶æ€

    è¿”å›ï¼š
        str: ç›®æ ‡èŠ‚ç‚¹çš„åç§°ï¼ˆå¿…é¡»æ˜¯å·²æ·»åŠ çš„èŠ‚ç‚¹ï¼‰
    """
    # è¯»å–çŠ¶æ€
    value = state["some_field"]

    # å†³ç­–é€»è¾‘
    if value > 10:
        return "node_b"
    elif value > 0:
        return "node_c"
    else:
        return "__end__"  # æˆ–ä½¿ç”¨ END
```

**å…³é”®ç‰¹æ€§ï¼š**
- **è¾“å…¥ï¼š** å½“å‰çŠ¶æ€ï¼ˆState å¯¹è±¡ï¼‰
- **è¾“å‡ºï¼š** èŠ‚ç‚¹åç§°ï¼ˆå­—ç¬¦ä¸²ï¼‰
- **ç±»å‹æç¤ºï¼š** `Literal` æ˜ç¡®æ‰€æœ‰å¯èƒ½çš„è·¯ç”±

#### **3. å®Œæ•´ç¤ºä¾‹ï¼šåŠ¨æ€è·¯ç”±**

```python
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict
from typing import Literal

# å®šä¹‰çŠ¶æ€
class State(TypedDict):
    value: int
    path: list[str]

# å®šä¹‰èŠ‚ç‚¹
def input_node(state: State):
    return {"path": state["path"] + ["input"]}

def process_high(state: State):
    return {"path": state["path"] + ["high"]}

def process_low(state: State):
    return {"path": state["path"] + ["low"]}

def end_node(state: State):
    return {"path": state["path"] + ["end"]}

# æ¡ä»¶å‡½æ•°
def route_based_on_value(state: State) -> Literal["process_high", "process_low", "end"]:
    if state["value"] > 10:
        return "process_high"
    elif state["value"] > 0:
        return "process_low"
    else:
        return "end"

# æ„å»ºå›¾
builder = StateGraph(State)
builder.add_node("input", input_node)
builder.add_node("process_high", process_high)
builder.add_node("process_low", process_low)
builder.add_node("end", end_node)

builder.add_edge(START, "input")
builder.add_conditional_edges(
    "input",                  # æºèŠ‚ç‚¹
    route_based_on_value     # æ¡ä»¶å‡½æ•°
)
builder.add_edge("process_high", "end")
builder.add_edge("process_low", "end")
builder.add_edge("end", END)

graph = builder.compile()

# æµ‹è¯•
result1 = graph.invoke({"value": 15, "path": []})
print(result1["path"])  # ['input', 'high', 'end']

result2 = graph.invoke({"value": 5, "path": []})
print(result2["path"])  # ['input', 'low', 'end']

result3 = graph.invoke({"value": -1, "path": []})
print(result3["path"])  # ['input', 'end']
```

#### **4. tools_conditionï¼šé¢„æ„å»ºçš„æ¡ä»¶å‡½æ•°**

LangGraph æä¾›äº†å¸¸ç”¨çš„ `tools_condition`ï¼š

```python
from langgraph.prebuilt import tools_condition

# å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰
def tools_condition(state: MessagesState) -> Literal["tools", "__end__"]:
    """æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·"""
    last_message = state["messages"][-1]

    # æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    if hasattr(last_message, "tool_calls") and last_message.tool_calls:
        return "tools"  # æœ‰å·¥å…·è°ƒç”¨ â†’ è·¯ç”±åˆ° tools èŠ‚ç‚¹
    else:
        return "__end__"  # æ— å·¥å…·è°ƒç”¨ â†’ ç»“æŸ
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**
```python
builder.add_conditional_edges("agent", tools_condition)

# ç­‰ä»·äºæ‰‹åŠ¨å†™ï¼š
def my_tools_condition(state):
    if state["messages"][-1].tool_calls:
        return "tools"
    return END

builder.add_conditional_edges("agent", my_tools_condition)
```

#### **5. é«˜çº§ç”¨æ³•ï¼šå¤šç›®æ ‡è·¯ç”±æ˜ å°„**

**æ–¹å¼ 1ï¼šè‡ªåŠ¨æ˜ å°„ï¼ˆæ¨èï¼‰**
```python
def condition(state) -> Literal["node_a", "node_b", "node_c"]:
    # è¿”å›å€¼è‡ªåŠ¨åŒ¹é…èŠ‚ç‚¹åç§°
    return "node_a"

builder.add_conditional_edges("source", condition)
# LangGraph è‡ªåŠ¨åˆ›å»ºè·¯ç”±ï¼šsource â†’ node_a/node_b/node_c
```

**æ–¹å¼ 2ï¼šæ˜¾å¼æ˜ å°„**
```python
def condition(state) -> str:
    return "path_1"  # è¿”å›è·¯å¾„åç§°ï¼ˆè€ŒéèŠ‚ç‚¹åç§°ï¼‰

builder.add_conditional_edges(
    "source",
    condition,
    {
        "path_1": "node_a",  # è·¯å¾„å â†’ èŠ‚ç‚¹å
        "path_2": "node_b",
        "default": "node_c"
    }
)
```

#### **6. å®æˆ˜æ¡ˆä¾‹ï¼šå®¢æœè·¯ç”±**

```python
from langchain_core.messages import HumanMessage

class CustomerServiceState(TypedDict):
    messages: list
    category: str

def classify_intent(state: CustomerServiceState) -> Literal["billing", "technical", "general"]:
    """æ ¹æ®ç”¨æˆ·æ¶ˆæ¯åˆ†ç±»æ„å›¾"""
    last_message = state["messages"][-1].content.lower()

    # ç®€å•å…³é”®è¯åŒ¹é…ï¼ˆå®é™…åº”ç”¨ä¸­ä½¿ç”¨ LLM åˆ†ç±»ï¼‰
    if "payment" in last_message or "bill" in last_message:
        return "billing"
    elif "error" in last_message or "bug" in last_message:
        return "technical"
    else:
        return "general"

# ä¸åŒéƒ¨é—¨çš„å¤„ç†èŠ‚ç‚¹
def billing_handler(state):
    return {"messages": [AIMessage("Billing team will assist you...")]}

def technical_handler(state):
    return {"messages": [AIMessage("Technical support will help...")]}

def general_handler(state):
    return {"messages": [AIMessage("How can I help you today?")]}

# æ„å»ºå›¾
builder = StateGraph(CustomerServiceState)
builder.add_node("classifier", lambda s: s)  # å ä½èŠ‚ç‚¹
builder.add_node("billing", billing_handler)
builder.add_node("technical", technical_handler)
builder.add_node("general", general_handler)

builder.add_edge(START, "classifier")
builder.add_conditional_edges("classifier", classify_intent)
builder.add_edge("billing", END)
builder.add_edge("technical", END)
builder.add_edge("general", END)

graph = builder.compile()

# æµ‹è¯•
result = graph.invoke({
    "messages": [HumanMessage("I have a payment issue")],
    "category": ""
})
# è·¯ç”±ï¼šclassifier â†’ billing â†’ END
```

#### **7. æ¡ä»¶è¾¹çš„æ‰§è¡Œæµç¨‹**

```python
# 1. æºèŠ‚ç‚¹æ‰§è¡Œ
state = source_node(state)

# 2. è°ƒç”¨æ¡ä»¶å‡½æ•°
next_node_name = condition_func(state)

# 3. æ ¹æ®è¿”å›å€¼è·¯ç”±
if next_node_name == "node_a":
    state = node_a(state)
elif next_node_name == "node_b":
    state = node_b(state)
elif next_node_name == END:
    return state
else:
    raise ValueError(f"Unknown node: {next_node_name}")
```

#### **8. å¸¸è§é”™è¯¯ä¸è°ƒè¯•**

**é”™è¯¯ 1ï¼šè¿”å›ä¸å­˜åœ¨çš„èŠ‚ç‚¹å**
```python
def bad_condition(state) -> str:
    return "non_existent_node"  # âŒ è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰è¢«æ·»åŠ 

builder.add_conditional_edges("source", bad_condition)
# è¿è¡Œæ—¶é”™è¯¯ï¼šNode 'non_existent_node' not found
```

**ä¿®å¤ï¼š**
```python
# æ–¹å¼ 1ï¼šç¡®ä¿èŠ‚ç‚¹å­˜åœ¨
builder.add_node("non_existent_node", some_func)

# æ–¹å¼ 2ï¼šä½¿ç”¨ Literal ç±»å‹æ£€æŸ¥
def good_condition(state) -> Literal["node_a", "node_b"]:
    return "node_a"  # IDE ä¼šæç¤ºå¯ç”¨é€‰é¡¹
```

**é”™è¯¯ 2ï¼šå¿˜è®°æ·»åŠ æ‰€æœ‰å¯èƒ½è·¯å¾„çš„è¾¹**
```python
def condition(state) -> Literal["node_a", "node_b", "node_c"]:
    return "node_a"

builder.add_conditional_edges("source", condition)
builder.add_edge("node_a", END)
builder.add_edge("node_b", END)
# âŒ å¿˜è®°æ·»åŠ  node_c â†’ END

# å¦‚æœæ¡ä»¶è¿”å› "node_c"ï¼Œä¼šæŠ¥é”™
```

**è°ƒè¯•æŠ€å·§ï¼š**
```python
def debug_condition(state):
    result = condition(state)
    print(f"Routing from {current_node} to {result}")
    print(f"State: {state}")
    return result

builder.add_conditional_edges("source", debug_condition)
```

#### **9. æ€§èƒ½ä¼˜åŒ–**

```python
# âŒ ä¸å¥½çš„å®è·µï¼šæ¡ä»¶å‡½æ•°ä¸­è°ƒç”¨ LLM
def expensive_condition(state):
    # æ¯æ¬¡è·¯ç”±éƒ½è°ƒç”¨ LLMï¼Œæˆæœ¬é«˜
    intent = llm.invoke("Classify: " + state["message"])
    return intent

# âœ… å¥½çš„å®è·µï¼šåœ¨èŠ‚ç‚¹ä¸­å®Œæˆåˆ†ç±»
def classify_node(state):
    intent = llm.invoke("Classify: " + state["message"])
    return {"intent": intent}

def simple_condition(state):
    # åªè¯»å–å·²æœ‰çŠ¶æ€ï¼Œæ— é¢å¤–å¼€é”€
    return state["intent"]

builder.add_node("classify", classify_node)
builder.add_conditional_edges("classify", simple_condition)
```

#### **10. ä¸æ™®é€šè¾¹çš„å¯¹æ¯”**

| ç‰¹æ€§ | æ™®é€šè¾¹ | æ¡ä»¶è¾¹ |
|------|-------|--------|
| **è·¯ç”±æ–¹å¼** | å›ºå®š | åŠ¨æ€ |
| **æ·»åŠ æ–¹æ³•** | `add_edge(A, B)` | `add_conditional_edges(A, func)` |
| **ä½¿ç”¨åœºæ™¯** | çº¿æ€§æµç¨‹ | åˆ†æ”¯é€»è¾‘ |
| **å¤æ‚åº¦** | ç®€å• | ä¸­ç­‰ |
| **ç¤ºä¾‹** | `START â†’ node1 â†’ END` | `node1 â†’ [æ¡ä»¶åˆ¤æ–­] â†’ node2/node3` |

#### **å…³é”®è¦ç‚¹**
- **æ¡ä»¶è¾¹ = åŠ¨æ€è·¯ç”±æœºåˆ¶**
- **æ¡ä»¶å‡½æ•°ï¼šè¾“å…¥çŠ¶æ€ â†’ è¾“å‡ºèŠ‚ç‚¹å**
- **tools_conditionï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·**
- **ä½¿ç”¨ Literal ç±»å‹æç¤ºæé«˜å®‰å…¨æ€§**
- **æ¡ä»¶é€»è¾‘åº”ç®€å•å¿«é€Ÿï¼Œé¿å…å¤æ‚è®¡ç®—**

</details>

---

---

### **é—®é¢˜ 6: å¦‚ä½•å®ç°ä¸€ä¸ªå¸¦å¤šä¸ªå·¥å…·çš„ Routerï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

å®ç°å¤šå·¥å…· Router çš„å…³é”®æ˜¯ **æ­£ç¡®ç»‘å®šæ‰€æœ‰å·¥å…·** å’Œ **ä½¿ç”¨ ToolNode è‡ªåŠ¨è·¯ç”±**ã€‚

#### **1. å®Œæ•´ä»£ç ç¤ºä¾‹**

```python
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.prebuilt import ToolNode, tools_condition

# å®šä¹‰å¤šä¸ªå·¥å…·
@tool
def add(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

@tool
def multiply(a: int, b: int) -> int:
    """Multiply two numbers."""
    return a * b

@tool
def divide(a: float, b: float) -> float:
    """Divide a by b."""
    if b == 0:
        return "Error: Division by zero"
    return a / b

@tool
def search_web(query: str) -> str:
    """Search the web for information."""
    # å®é™…å®ç°ä¸­è°ƒç”¨æœç´¢ API
    return f"Search results for: {query}"

# æ”¶é›†æ‰€æœ‰å·¥å…·
tools = [add, multiply, divide, search_web]

# åˆ›å»º LLM å¹¶ç»‘å®šå·¥å…·
llm = ChatOpenAI(model="gpt-4")
llm_with_tools = llm.bind_tools(tools)

# å®šä¹‰èŠ‚ç‚¹
def call_model(state: MessagesState):
    response = llm_with_tools.invoke(state["messages"])
    return {"messages": [response]}

# æ„å»ºå›¾
builder = StateGraph(MessagesState)
builder.add_node("llm", call_model)
builder.add_node("tools", ToolNode(tools))  # â† ä¼ å…¥æ‰€æœ‰å·¥å…·

builder.add_edge(START, "llm")
builder.add_conditional_edges("llm", tools_condition)
builder.add_edge("tools", END)

graph = builder.compile()
```

#### **2. å…³é”®æŠ€æœ¯ç‚¹**

**æŠ€æœ¯ç‚¹ 1ï¼š@tool è£…é¥°å™¨**

```python
from langchain_core.tools import tool

@tool
def my_function(param: type) -> return_type:
    """Clear description of what this tool does.

    Args:
        param: Description of parameter
    """
    return result
```

**è‡ªåŠ¨è½¬æ¢ä¸ºï¼š**
- å·¥å…·åç§°ï¼šå‡½æ•°åï¼ˆ`my_function`ï¼‰
- å·¥å…·æè¿°ï¼šDocstring ç¬¬ä¸€è¡Œ
- å‚æ•°æ¨¡å¼ï¼šä»ç±»å‹æ³¨è§£ç”Ÿæˆ
- è°ƒç”¨æ¥å£ï¼šä¿æŒåŸå‡½æ•°é€»è¾‘

**æŠ€æœ¯ç‚¹ 2ï¼šToolNode è‡ªåŠ¨è·¯ç”±**

```python
ToolNode(tools)
# å†…éƒ¨å®ç°ï¼ˆç®€åŒ–ï¼‰ï¼š
class ToolNode:
    def __init__(self, tools):
        self.tools_by_name = {t.name: t for t in tools}

    def __call__(self, state):
        last_message = state["messages"][-1]
        results = []

        for tool_call in last_message.tool_calls:
            tool = self.tools_by_name[tool_call["name"]]  # è‡ªåŠ¨åŒ¹é…
            result = tool.invoke(tool_call["args"])
            results.append(ToolMessage(
                content=str(result),
                tool_call_id=tool_call["id"]
            ))

        return {"messages": results}
```

#### **3. æµ‹è¯•ä¸åŒå·¥å…·**

```python
from langchain_core.messages import HumanMessage

# æµ‹è¯• 1ï¼šæ•°å­¦è®¡ç®—
result1 = graph.invoke({
    "messages": [HumanMessage("What is 15 + 23?")]
})
# LLM é€‰æ‹© add(15, 23) â†’ è¿”å› 38

# æµ‹è¯• 2ï¼šä¹˜æ³•
result2 = graph.invoke({
    "messages": [HumanMessage("Multiply 7 by 8")]
})
# LLM é€‰æ‹© multiply(7, 8) â†’ è¿”å› 56

# æµ‹è¯• 3ï¼šç½‘ç»œæœç´¢
result3 = graph.invoke({
    "messages": [HumanMessage("Search for Python tutorials")]
})
# LLM é€‰æ‹© search_web("Python tutorials")

# æµ‹è¯• 4ï¼šç»„åˆæŸ¥è¯¢
result4 = graph.invoke({
    "messages": [HumanMessage("Calculate 100 / 4")]
})
# LLM é€‰æ‹© divide(100, 4) â†’ è¿”å› 25.0
```

#### **4. LLM å¦‚ä½•é€‰æ‹©å·¥å…·ï¼Ÿ**

LLM æ¥æ”¶åˆ°çš„å·¥å…·ä¿¡æ¯ï¼š

```json
{
  "tools": [
    {
      "name": "add",
      "description": "Add two numbers together.",
      "parameters": {
        "type": "object",
        "properties": {
          "a": {"type": "integer"},
          "b": {"type": "integer"}
        }
      }
    },
    {
      "name": "multiply",
      "description": "Multiply two numbers.",
      "parameters": {
        "type": "object",
        "properties": {
          "a": {"type": "integer"},
          "b": {"type": "integer"}
        }
      }
    },
    ...
  ]
}
```

**LLM å†³ç­–è¿‡ç¨‹ï¼š**
```
ç”¨æˆ·è¾“å…¥: "What is 15 + 23?"
         â†“
LLM åˆ†æ: "è¿™æ˜¯åŠ æ³•é—®é¢˜"
         â†“
æŸ¥æ‰¾å·¥å…·: "add" çš„æè¿°åŒ¹é…
         â†“
æå–å‚æ•°: a=15, b=23
         â†“
è¿”å›: tool_calls=[{"name": "add", "args": {"a": 15, "b": 23}}]
```

#### **5. é”™è¯¯å¤„ç†**

```python
@tool
def divide(a: float, b: float) -> float:
    """Divide a by b. Returns error message if b is zero."""
    try:
        if b == 0:
            return "Error: Cannot divide by zero"
        return a / b
    except Exception as e:
        return f"Error: {str(e)}"

# æµ‹è¯•é”™è¯¯æƒ…å†µ
result = graph.invoke({
    "messages": [HumanMessage("What is 10 divided by 0?")]
})
# å·¥å…·è¿”å›: "Error: Cannot divide by zero"
# LLM æ”¶åˆ°é”™è¯¯ä¿¡æ¯ï¼Œå¯ä»¥ç»™å‡ºå‹å¥½å›å¤
```

#### **6. å·¥å…·åˆ†ç±»ç®¡ç†**

å¯¹äºå¤§é‡å·¥å…·ï¼Œå¯ä»¥åˆ†ç±»ç®¡ç†ï¼š

```python
# æ•°å­¦å·¥å…·
math_tools = [add, multiply, divide]

# æœç´¢å·¥å…·
search_tools = [search_web, search_database]

# æ–‡ä»¶å·¥å…·
file_tools = [read_file, write_file]

# åœºæ™¯ 1ï¼šæ•°å­¦åŠ©æ‰‹ï¼ˆåªç»‘å®šæ•°å­¦å·¥å…·ï¼‰
math_llm = llm.bind_tools(math_tools)

# åœºæ™¯ 2ï¼šé€šç”¨åŠ©æ‰‹ï¼ˆç»‘å®šæ‰€æœ‰å·¥å…·ï¼‰
general_llm = llm.bind_tools(math_tools + search_tools + file_tools)
```

#### **7. åŠ¨æ€å·¥å…·åŠ è½½**

```python
def call_model_dynamic(state: MessagesState):
    # æ ¹æ®ç”¨æˆ·æ¶ˆæ¯åŠ¨æ€é€‰æ‹©å·¥å…·
    last_message = state["messages"][-1].content.lower()

    if "calculate" in last_message or "math" in last_message:
        tools = math_tools
    elif "search" in last_message:
        tools = search_tools
    else:
        tools = math_tools + search_tools  # é»˜è®¤å…¨éƒ¨

    llm_with_selected_tools = llm.bind_tools(tools)
    response = llm_with_selected_tools.invoke(state["messages"])
    return {"messages": [response]}
```

#### **8. å·¥å…·è°ƒç”¨ç»Ÿè®¡**

```python
from collections import Counter

class ToolNodeWithStats(ToolNode):
    def __init__(self, tools):
        super().__init__(tools)
        self.call_stats = Counter()

    def __call__(self, state):
        last_message = state["messages"][-1]

        # ç»Ÿè®¡å·¥å…·ä½¿ç”¨
        for tool_call in last_message.tool_calls:
            self.call_stats[tool_call["name"]] += 1

        # æ‰§è¡Œå·¥å…·
        result = super().__call__(state)

        # æ‰“å°ç»Ÿè®¡
        print(f"Tool usage: {dict(self.call_stats)}")
        return result

# ä½¿ç”¨
tool_node = ToolNodeWithStats(tools)
builder.add_node("tools", tool_node)
```

#### **9. æœ€ä½³å®è·µ**

```python
# âœ… å¥½çš„å·¥å…·å®šä¹‰
@tool
def calculate_discount(price: float, discount_percent: float) -> float:
    """Calculate the final price after applying a discount.

    Args:
        price: Original price in dollars
        discount_percent: Discount percentage (0-100)

    Returns:
        Final price after discount
    """
    if not (0 <= discount_percent <= 100):
        return "Error: Discount must be between 0 and 100"
    return price * (1 - discount_percent / 100)

# âŒ ä¸å¥½çš„å·¥å…·å®šä¹‰
@tool
def calc(p, d):  # æ— ç±»å‹æ³¨è§£
    """Calculate."""  # æè¿°ä¸æ¸…æ¥š
    return p * d  # é€»è¾‘ä¸æ˜ç¡®
```

#### **10. å®Œæ•´ç¤ºä¾‹ï¼šå¤šåŠŸèƒ½åŠ©æ‰‹**

```python
from langchain_core.tools import tool

# å·¥å…·é›†åˆ
@tool
def get_weather(city: str) -> str:
    """Get current weather for a city."""
    return f"Weather in {city}: Sunny, 72Â°F"

@tool
def book_flight(origin: str, destination: str, date: str) -> str:
    """Book a flight ticket."""
    return f"Flight booked: {origin} â†’ {destination} on {date}"

@tool
def translate(text: str, target_lang: str) -> str:
    """Translate text to target language."""
    return f"[{target_lang}] {text}"

tools = [get_weather, book_flight, translate, add, multiply]

# æ„å»ºå›¾
llm_with_tools = ChatOpenAI(model="gpt-4").bind_tools(tools)

def assistant(state: MessagesState):
    return {"messages": [llm_with_tools.invoke(state["messages"])]}

builder = StateGraph(MessagesState)
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tools_condition)
builder.add_edge("tools", END)

graph = builder.compile()

# æµ‹è¯•å¤šæ ·åŒ–æŸ¥è¯¢
queries = [
    "What's the weather in New York?",
    "Book a flight from LA to NYC on March 15",
    "Translate 'Hello' to Spanish",
    "What is 25 times 4?"
]

for query in queries:
    result = graph.invoke({"messages": [HumanMessage(query)]})
    print(f"Query: {query}")
    print(f"Response: {result['messages'][-1].content}\n")
```

#### **å…³é”®è¦ç‚¹**
- **å¤šå·¥å…·ç»‘å®šï¼š** `llm.bind_tools([tool1, tool2, ...])`
- **ToolNode è‡ªåŠ¨è·¯ç”±ï¼š** æ ¹æ® tool_calls ä¸­çš„ name åŒ¹é…å·¥å…·
- **å·¥å…·å®šä¹‰å…³é”®ï¼š** æ¸…æ™°çš„ Docstring + ç±»å‹æ³¨è§£
- **LLM è‡ªåŠ¨é€‰æ‹©ï¼š** åŸºäºæè¿°å’Œå‚æ•°åŒ¹é…
- **å¯æ‰©å±•æ€§ï¼š** è½»æ¾æ·»åŠ æ–°å·¥å…·ï¼Œæ— éœ€ä¿®æ”¹å›¾ç»“æ„

</details>

---

### **é—®é¢˜ 7: å¦‚ä½•è®© Agent é¿å…æ— é™å¾ªç¯ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

é˜²æ­¢ Agent æ— é™å¾ªç¯éœ€è¦ **è®¾ç½®é€’å½’é™åˆ¶** å’Œ **æ™ºèƒ½åœæ­¢æ¡ä»¶**ã€‚

#### **1. é—®é¢˜ï¼šä¸ºä»€ä¹ˆä¼šå‡ºç°æ— é™å¾ªç¯ï¼Ÿ**

Agent çš„å¾ªç¯ç»“æ„ï¼š

```python
builder.add_edge("tools", "agent")  # å·¥å…·æ‰§è¡Œåå›åˆ° agent

# æµç¨‹ï¼š
# agent â†’ tools â†’ agent â†’ tools â†’ agent â†’ ...
```

**å¯èƒ½å¯¼è‡´æ— é™å¾ªç¯çš„åœºæ™¯ï¼š**
- LLM ä¸€ç›´è®¤ä¸ºéœ€è¦è°ƒç”¨å·¥å…·
- å·¥å…·è¿”å›çš„ç»“æœæ— æ³•è®© LLM æ»¡æ„
- LLM é™·å…¥"æ€è€ƒ-è¡ŒåŠ¨"æ­»å¾ªç¯

#### **2. æ–¹æ³• 1ï¼šä½¿ç”¨ recursion_limit**

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(
    checkpointer=memory,
    recursion_limit=10  # â† æœ€å¤šæ‰§è¡Œ 10 æ¬¡èŠ‚ç‚¹
)

# æµ‹è¯•
try:
    result = graph.invoke({"messages": [HumanMessage("test")]})
except RecursionError:
    print("è¾¾åˆ°é€’å½’é™åˆ¶ï¼")
```

**å·¥ä½œåŸç†ï¼š**
```
Step 1: agent
Step 2: tools
Step 3: agent
...
Step 10: agent
Step 11: âŒ RecursionError: è¾¾åˆ°é™åˆ¶
```

#### **3. æ–¹æ³• 2ï¼šåœ¨çŠ¶æ€ä¸­è®¡æ•°**

```python
from typing import Annotated
import operator

class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    iterations: Annotated[int, operator.add]  # ç´¯åŠ è®¡æ•°å™¨

def agent(state: AgentState):
    # æ£€æŸ¥è¿­ä»£æ¬¡æ•°
    current_iterations = state.get("iterations", 0)

    if current_iterations >= 10:
        return {
            "messages": [AIMessage("å·²è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œåœæ­¢æ‰§è¡Œã€‚")],
            "iterations": 0  # é‡ç½®è®¡æ•°å™¨
        }

    # æ­£å¸¸æ‰§è¡Œ
    response = llm_with_tools.invoke(state["messages"])
    return {
        "messages": [response],
        "iterations": 1  # æ¯æ¬¡å¢åŠ  1
    }

# åˆå§‹çŠ¶æ€
initial_state = {
    "messages": [HumanMessage("Start")],
    "iterations": 0
}

result = graph.invoke(initial_state)
```

#### **4. æ–¹æ³• 3ï¼šæ™ºèƒ½åœæ­¢æ¡ä»¶**

```python
def tools_condition_with_limit(state: AgentState) -> Literal["tools", "__end__"]:
    """å¢å¼ºç‰ˆ tools_conditionï¼ŒåŒ…å«å¤šé‡åœæ­¢æ¡ä»¶"""

    # æ¡ä»¶ 1ï¼šæ£€æŸ¥è¿­ä»£æ¬¡æ•°
    if state.get("iterations", 0) >= 15:
        return "__end__"

    # æ¡ä»¶ 2ï¼šæ£€æŸ¥æ¶ˆæ¯æ•°é‡ï¼ˆé˜²æ­¢å¯¹è¯è¿‡é•¿ï¼‰
    if len(state["messages"]) > 50:
        return "__end__"

    # æ¡ä»¶ 3ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    last_message = state["messages"][-1]
    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        return "__end__"

    # æ¡ä»¶ 4ï¼šæ£€æŸ¥æ˜¯å¦é‡å¤è°ƒç”¨ç›¸åŒå·¥å…·
    if len(last_message.tool_calls) > 0:
        tool_name = last_message.tool_calls[0]["name"]
        # æ£€æŸ¥æœ€è¿‘ 3 æ¬¡æ˜¯å¦éƒ½è°ƒç”¨åŒä¸€å·¥å…·
        recent_calls = []
        for msg in state["messages"][-6:]:  # æœ€è¿‘ 3 è½®ï¼ˆæ¯è½® 2 æ¡æ¶ˆæ¯ï¼‰
            if hasattr(msg, "tool_calls") and msg.tool_calls:
                recent_calls.append(msg.tool_calls[0]["name"])

        if recent_calls.count(tool_name) >= 3:
            print(f"è­¦å‘Šï¼šå·¥å…· {tool_name} è¢«é‡å¤è°ƒç”¨ï¼Œåœæ­¢æ‰§è¡Œ")
            return "__end__"

    return "tools"

# ä½¿ç”¨å¢å¼ºç‰ˆæ¡ä»¶
builder.add_conditional_edges("agent", tools_condition_with_limit)
```

#### **5. æ–¹æ³• 4ï¼šè¶…æ—¶æœºåˆ¶**

```python
import time
from datetime import datetime, timedelta

class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    start_time: float

def agent_with_timeout(state: AgentState):
    # è®°å½•å¼€å§‹æ—¶é—´
    if "start_time" not in state:
        state["start_time"] = time.time()

    # æ£€æŸ¥è¶…æ—¶ï¼ˆä¾‹å¦‚ï¼šæœ€å¤šè¿è¡Œ 60 ç§’ï¼‰
    elapsed = time.time() - state["start_time"]
    if elapsed > 60:
        return {
            "messages": [AIMessage("æ‰§è¡Œè¶…æ—¶ï¼Œå·²åœæ­¢ã€‚")],
            "start_time": state["start_time"]
        }

    # æ­£å¸¸æ‰§è¡Œ
    response = llm_with_tools.invoke(state["messages"])
    return {
        "messages": [response],
        "start_time": state["start_time"]
    }
```

#### **6. æ–¹æ³• 5ï¼šå·¥å…·è°ƒç”¨æˆæœ¬é™åˆ¶**

```python
class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    total_tokens: int

def agent_with_budget(state: AgentState):
    # æ£€æŸ¥ token ä½¿ç”¨é‡
    total_tokens = state.get("total_tokens", 0)
    max_tokens = 10000

    if total_tokens >= max_tokens:
        return {
            "messages": [AIMessage(f"å·²è¾¾åˆ° token é™åˆ¶ ({max_tokens})ï¼Œåœæ­¢æ‰§è¡Œã€‚")],
            "total_tokens": total_tokens
        }

    # è°ƒç”¨ LLM
    response = llm_with_tools.invoke(state["messages"])

    # ç»Ÿè®¡ token
    tokens_used = response.response_metadata.get("token_usage", {}).get("total_tokens", 0)

    return {
        "messages": [response],
        "total_tokens": total_tokens + tokens_used
    }
```

#### **7. æ–¹æ³• 6ï¼šLLM æç¤ºè¯ä¼˜åŒ–**

```python
from langchain_core.messages import SystemMessage

system_prompt = SystemMessage(content="""
You are a helpful assistant. Follow these rules:

1. **Efficiency**: Minimize the number of tool calls needed
2. **Completion**: Once you have enough information, provide a final answer
3. **No Loops**: If a tool fails twice, stop trying and explain the issue
4. **Token Awareness**: Keep responses concise

When you have completed the task, respond with a final answer WITHOUT tool calls.
""")

def agent_with_prompt(state: MessagesState):
    messages = [system_prompt] + state["messages"]
    response = llm_with_tools.invoke(messages)
    return {"messages": [response]}
```

#### **8. å®Œæ•´ç¤ºä¾‹ï¼šç»¼åˆé˜²æŠ¤**

```python
from typing import Annotated
import operator
import time

class RobustAgentState(TypedDict):
    messages: Annotated[list, add_messages]
    iterations: Annotated[int, operator.add]
    total_tokens: int
    start_time: float

def robust_agent(state: RobustAgentState):
    """å¸¦å¤šé‡ä¿æŠ¤çš„ Agent"""

    # åˆå§‹åŒ–
    if "start_time" not in state:
        state["start_time"] = time.time()

    iterations = state.get("iterations", 0)
    total_tokens = state.get("total_tokens", 0)
    elapsed = time.time() - state["start_time"]

    # ä¿æŠ¤ 1ï¼šè¿­ä»£æ¬¡æ•°
    if iterations >= 10:
        return {
            "messages": [AIMessage("è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•° (10)ã€‚")],
            "iterations": 0
        }

    # ä¿æŠ¤ 2ï¼šæ‰§è¡Œæ—¶é—´
    if elapsed > 120:  # 2 åˆ†é’Ÿ
        return {
            "messages": [AIMessage("æ‰§è¡Œè¶…æ—¶ (120s)ã€‚")],
            "iterations": 0
        }

    # ä¿æŠ¤ 3ï¼šToken é¢„ç®—
    if total_tokens >= 50000:
        return {
            "messages": [AIMessage("è¾¾åˆ° token é™åˆ¶ (50000)ã€‚")],
            "iterations": 0
        }

    # æ­£å¸¸æ‰§è¡Œ
    try:
        response = llm_with_tools.invoke(state["messages"])
        tokens_used = response.response_metadata.get("token_usage", {}).get("total_tokens", 0)

        return {
            "messages": [response],
            "iterations": 1,
            "total_tokens": tokens_used
        }
    except Exception as e:
        return {
            "messages": [AIMessage(f"æ‰§è¡Œé”™è¯¯ï¼š{str(e)}")],
            "iterations": 0
        }

def robust_tools_condition(state: RobustAgentState):
    """å¢å¼ºç‰ˆåœæ­¢æ¡ä»¶"""
    last_message = state["messages"][-1]

    # æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        return "__end__"

    # æ£€æŸ¥ä¿æŠ¤æ¡ä»¶
    if state.get("iterations", 0) >= 10:
        return "__end__"

    return "tools"

# æ„å»ºå›¾
builder = StateGraph(RobustAgentState)
builder.add_node("agent", robust_agent)
builder.add_node("tools", ToolNode(tools))
builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", robust_tools_condition)
builder.add_edge("tools", "agent")

# ä½¿ç”¨ recursion_limit ä½œä¸ºæœ€åé˜²çº¿
graph = builder.compile(recursion_limit=25)
```

#### **9. ç›‘æ§å’Œè°ƒè¯•**

```python
def agent_with_logging(state: AgentState):
    iterations = state.get("iterations", 0)
    print(f"[Iteration {iterations}] Agent executing...")

    response = llm_with_tools.invoke(state["messages"])

    # è®°å½•å·¥å…·è°ƒç”¨
    if hasattr(response, "tool_calls") and response.tool_calls:
        for tc in response.tool_calls:
            print(f"  â†’ Calling tool: {tc['name']}")
    else:
        print(f"  â†’ Generating final response")

    return {
        "messages": [response],
        "iterations": 1
    }
```

#### **10. æœ€ä½³å®è·µæ€»ç»“**

| æ–¹æ³• | ä¼˜å…ˆçº§ | é€‚ç”¨åœºæ™¯ | å®ç°éš¾åº¦ |
|------|-------|---------|---------|
| **recursion_limit** | å¿…é¡» | æ‰€æœ‰ Agent | ç®€å• |
| **è¿­ä»£è®¡æ•°** | æ¨è | é•¿æ—¶é—´è¿è¡Œçš„ Agent | ä¸­ç­‰ |
| **è¶…æ—¶æœºåˆ¶** | æ¨è | ç”Ÿäº§ç¯å¢ƒ | ä¸­ç­‰ |
| **Token é™åˆ¶** | å¯é€‰ | æˆæœ¬æ•æ„Ÿåœºæ™¯ | ä¸­ç­‰ |
| **æ™ºèƒ½åœæ­¢æ¡ä»¶** | æ¨è | å¤æ‚ Agent | è¾ƒéš¾ |
| **æç¤ºè¯ä¼˜åŒ–** | å¿…é¡» | æ‰€æœ‰ Agent | ç®€å• |

**æ¨èé…ç½®ï¼š**
```python
# 1. æç¤ºè¯æ˜ç¡®æŒ‡ç¤ºä½•æ—¶åœæ­¢
# 2. recursion_limit=20ï¼ˆåˆç†ä¸Šé™ï¼‰
# 3. çŠ¶æ€ä¸­è·Ÿè¸ªè¿­ä»£æ¬¡æ•°
# 4. æ¡ä»¶å‡½æ•°æ£€æŸ¥å¼‚å¸¸æ¨¡å¼
# 5. ç”Ÿäº§ç¯å¢ƒæ·»åŠ è¶…æ—¶å’Œ token é™åˆ¶
```

#### **å…³é”®è¦ç‚¹**
- **å¤šå±‚é˜²æŠ¤ï¼š** ä¸è¦ä¾èµ–å•ä¸€æœºåˆ¶
- **recursion_limitï¼š** æœ€åŸºæœ¬çš„ä¿æŠ¤
- **çŠ¶æ€è®¡æ•°ï¼š** æ›´ç²¾ç»†çš„æ§åˆ¶
- **æ™ºèƒ½æ¡ä»¶ï¼š** æ£€æµ‹å¼‚å¸¸å¾ªç¯æ¨¡å¼
- **ç›‘æ§æ—¥å¿—ï¼š** ä¾¿äºè°ƒè¯•å’Œä¼˜åŒ–

</details>

---

### **é—®é¢˜ 8: å¦‚ä½•å®ç°è·¨ä¼šè¯çš„å¯¹è¯è®°å¿†ï¼Ÿ**

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

#### **ç­”æ¡ˆï¼š**

è·¨ä¼šè¯å¯¹è¯è®°å¿†é€šè¿‡ **Checkpointer + Thread ID** å®ç°çŠ¶æ€æŒä¹…åŒ–å’Œæ¢å¤ã€‚

#### **1. æ ¸å¿ƒæ¦‚å¿µ**

**ä¼šè¯ï¼ˆSessionï¼‰ï¼š** ç”¨æˆ·ä¸ Agent çš„ä¸€æ¬¡å®Œæ•´äº¤äº’è¿‡ç¨‹
**è·¨ä¼šè¯è®°å¿†ï¼š** åœ¨å¤šæ¬¡ç‹¬ç«‹ä¼šè¯ä¹‹é—´ä¿æŒç”¨æˆ·ä¿¡æ¯å’Œå¯¹è¯å†å²

```
ä¼šè¯ 1 (ä»Šå¤©ä¸Šåˆ)
ç”¨æˆ·: "æˆ‘çš„è®¢å•å·æ˜¯ 12345"
Agent: "å¥½çš„ï¼Œè®¢å• 12345 å·²è®°å½•"

ä¼šè¯ 2 (ä»Šå¤©ä¸‹åˆï¼Œæ–°çš„æµè§ˆå™¨æ ‡ç­¾)
ç”¨æˆ·: "é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ"
Agent: "æ‚¨çš„è®¢å• 12345 å·²äºä»Šå¤©ä¸Šåˆå‘è´§"  âœ… è®°ä½äº†è®¢å•å·
```

#### **2. åŸºç¡€å®ç°ï¼šMemorySaver**

```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import StateGraph, MessagesState

# åˆ›å»ºæ£€æŸ¥ç‚¹å™¨
memory = MemorySaver()

# ç¼–è¯‘å›¾
graph = builder.compile(checkpointer=memory)

# ä¼šè¯ 1
config = {"configurable": {"thread_id": "user-123"}}
result1 = graph.invoke(
    {"messages": [HumanMessage("æˆ‘çš„è®¢å•å·æ˜¯ 12345")]},
    config
)

# ä¼šè¯ 2ï¼ˆç¨åï¼ŒåŒä¸€ thread_idï¼‰
result2 = graph.invoke(
    {"messages": [HumanMessage("é‚£ä¸ªè®¢å•å‘è´§äº†å—ï¼Ÿ")]},
    config
)
# âœ… è‡ªåŠ¨åŠ è½½ä¹‹å‰çš„å¯¹è¯å†å²
```

#### **3. ç”Ÿäº§å®ç°ï¼šPostgreSQL æŒä¹…åŒ–**

```python
from langgraph.checkpoint.postgres import PostgresSaver
import psycopg2

# è¿æ¥æ•°æ®åº“
conn_string = "postgresql://user:password@localhost:5432/langgraph_db"
checkpointer = PostgresSaver.from_conn_string(conn_string)

# ç¼–è¯‘å›¾ï¼ˆä¸ MemorySaver æ¥å£å®Œå…¨ç›¸åŒï¼‰
graph = builder.compile(checkpointer=checkpointer)

# ä½¿ç”¨æ–¹å¼å®Œå…¨ç›¸åŒ
config = {"configurable": {"thread_id": "user-123"}}
result = graph.invoke({"messages": [...]}, config)
```

**PostgreSQL è¡¨ç»“æ„ï¼š**
```sql
CREATE TABLE checkpoints (
    thread_id TEXT,
    checkpoint_id TEXT PRIMARY KEY,
    parent_id TEXT,
    created_at TIMESTAMP,
    state JSONB,  -- å®Œæ•´çŠ¶æ€æ•°æ®
    metadata JSONB
);

CREATE INDEX idx_thread_id ON checkpoints(thread_id);
```

#### **4. Thread ID è®¾è®¡æ¨¡å¼**

**æ¨¡å¼ 1ï¼šæŒ‰ç”¨æˆ·éš”ç¦»**
```python
def get_config(user_id: str):
    return {"configurable": {"thread_id": f"user-{user_id}"}}

# ç”¨æˆ· A
config_a = get_config("alice")
graph.invoke(input, config_a)

# ç”¨æˆ· Bï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
config_b = get_config("bob")
graph.invoke(input, config_b)
```

**æ¨¡å¼ 2ï¼šæŒ‰ä¼šè¯éš”ç¦»**
```python
import uuid

def create_new_session(user_id: str):
    session_id = str(uuid.uuid4())
    return {"configurable": {"thread_id": f"{user_id}-{session_id}"}}

# ç”¨æˆ·å¼€å§‹æ–°å¯¹è¯
config = create_new_session("alice")
# thread_id: "alice-4f8d3c2a-..."
```

**æ¨¡å¼ 3ï¼šæŒ‰åŠŸèƒ½éš”ç¦»**
```python
def get_config(user_id: str, context: str):
    return {"configurable": {"thread_id": f"{user_id}-{context}"}}

# å®¢æœå¯¹è¯
support_config = get_config("alice", "support")

# è®¢å•æŸ¥è¯¢
order_config = get_config("alice", "order")

# ä¸¤ä¸ªç‹¬ç«‹çš„å¯¹è¯çº¿ç¨‹
```

#### **5. æ‰©å±•çŠ¶æ€ï¼šç”¨æˆ·åå¥½è®°å¿†**

```python
class UserState(TypedDict):
    messages: Annotated[list, add_messages]
    user_id: str
    preferences: dict  # ç”¨æˆ·åå¥½
    conversation_count: Annotated[int, operator.add]

def agent_with_preferences(state: UserState):
    # è¯»å–ç”¨æˆ·åå¥½
    prefs = state.get("preferences", {})
    style = prefs.get("response_style", "formal")

    # æ ¹æ®åå¥½è°ƒæ•´ç³»ç»Ÿæç¤º
    if style == "casual":
        system_msg = "You are a friendly, casual assistant."
    else:
        system_msg = "You are a professional, formal assistant."

    messages = [SystemMessage(system_msg)] + state["messages"]
    response = llm.invoke(messages)

    return {
        "messages": [response],
        "conversation_count": 1
    }

# ä¼šè¯ 1ï¼šè®¾ç½®åå¥½
initial_state = {
    "messages": [HumanMessage("æˆ‘å–œæ¬¢ç®€æ´çš„å›ç­”")],
    "user_id": "alice",
    "preferences": {"response_style": "casual"},
    "conversation_count": 0
}

config = {"configurable": {"thread_id": "alice"}}
graph.invoke(initial_state, config)

# ä¼šè¯ 2ï¼šè‡ªåŠ¨åº”ç”¨åå¥½
later_state = {
    "messages": [HumanMessage("è§£é‡Šé‡å­è®¡ç®—")]
}
result = graph.invoke(later_state, config)
# âœ… è‡ªåŠ¨åŠ è½½ preferencesï¼Œä½¿ç”¨ casual é£æ ¼
```

#### **6. æ—¶é—´é™åˆ¶çš„è®°å¿†**

```python
from datetime import datetime, timedelta

class TimedState(TypedDict):
    messages: Annotated[list, add_messages]
    last_active: str  # ISO æ ¼å¼æ—¶é—´æˆ³

def trim_old_messages(state: TimedState) -> TimedState:
    """åˆ é™¤è¶…è¿‡ 7 å¤©çš„æ¶ˆæ¯"""
    cutoff = datetime.now() - timedelta(days=7)

    # è§£æ last_active
    if "last_active" in state:
        last_active = datetime.fromisoformat(state["last_active"])
        if last_active < cutoff:
            # å¤ªä¹…æ²¡æ´»åŠ¨ï¼Œæ¸…ç©ºå†å²
            return {
                "messages": [],
                "last_active": datetime.now().isoformat()
            }

    # æ›´æ–°æ´»åŠ¨æ—¶é—´
    return {
        **state,
        "last_active": datetime.now().isoformat()
    }

def agent(state: TimedState):
    # å…ˆæ¸…ç†æ—§æ¶ˆæ¯
    state = trim_old_messages(state)

    # æ­£å¸¸å¤„ç†
    response = llm.invoke(state["messages"])
    return {"messages": [response]}
```

#### **7. å¤šè®¾å¤‡åŒæ­¥**

```python
from fastapi import FastAPI, HTTPException
from langgraph_sdk import get_client

app = FastAPI()
client = get_client(url="https://your-langgraph-cloud.app")

@app.post("/chat")
async def chat(user_id: str, message: str, device_id: str):
    """æ”¯æŒå¤šè®¾å¤‡è®¿é—®åŒä¸€å¯¹è¯"""

    # ä½¿ç”¨ user_id ä½œä¸º thread_idï¼ˆä¸åŒ…å« device_idï¼‰
    config = {"configurable": {"thread_id": f"user-{user_id}"}}

    # æ‰§è¡Œå›¾
    response = await client.runs.create(
        thread_id=config["configurable"]["thread_id"],
        assistant_id="agent",
        input={"messages": [HumanMessage(message)]},
        metadata={"device_id": device_id}  # è®°å½•è®¾å¤‡ä¿¡æ¯
    )

    return {"response": response}

# ä½¿ç”¨åœºæ™¯ï¼š
# è®¾å¤‡ 1 (æ‰‹æœº): POST /chat?user_id=alice&message=Hi&device_id=phone
# è®¾å¤‡ 2 (ç”µè„‘): POST /chat?user_id=alice&message=ç»§ç»­&device_id=laptop
# ä¸¤ä¸ªè®¾å¤‡çœ‹åˆ°ç›¸åŒçš„å¯¹è¯å†å²
```

#### **8. æŸ¥è¯¢å†å²å¯¹è¯**

```python
def get_conversation_history(thread_id: str, limit: int = 10):
    """è·å–å¯¹è¯å†å²"""
    config = {"configurable": {"thread_id": thread_id}}

    # è·å–æ‰€æœ‰æ£€æŸ¥ç‚¹
    checkpoints = list(graph.checkpointer.list(config))

    # æŒ‰æ—¶é—´å€’åº
    checkpoints.sort(key=lambda x: x.created_at, reverse=True)

    # æå–æ¶ˆæ¯
    history = []
    for cp in checkpoints[:limit]:
        messages = cp.state.get("messages", [])
        history.append({
            "timestamp": cp.created_at,
            "messages": [
                {"role": m.type, "content": m.content}
                for m in messages
            ]
        })

    return history

# ä½¿ç”¨
history = get_conversation_history("user-alice")
for session in history:
    print(f"\n=== {session['timestamp']} ===")
    for msg in session['messages']:
        print(f"{msg['role']}: {msg['content']}")
```

#### **9. æ¸…ç†å’Œè¿‡æœŸç®¡ç†**

```python
import asyncio
from datetime import datetime, timedelta

async def cleanup_old_threads(checkpointer, days: int = 30):
    """å®šæœŸæ¸…ç†è¶…è¿‡ N å¤©çš„å¯¹è¯"""
    cutoff = datetime.now() - timedelta(days=days)

    # è·å–æ‰€æœ‰ thread
    all_threads = await checkpointer.list_threads()

    deleted_count = 0
    for thread_id in all_threads:
        config = {"configurable": {"thread_id": thread_id}}
        checkpoints = list(checkpointer.list(config))

        if not checkpoints:
            continue

        # æ£€æŸ¥æœ€åæ´»åŠ¨æ—¶é—´
        last_checkpoint = max(checkpoints, key=lambda x: x.created_at)
        if last_checkpoint.created_at < cutoff:
            checkpointer.delete_thread(config)
            deleted_count += 1
            print(f"Deleted thread: {thread_id}")

    print(f"Total deleted: {deleted_count} threads")

# å®šæœŸè¿è¡Œï¼ˆä¾‹å¦‚æ¯å¤©å‡Œæ™¨ï¼‰
async def scheduled_cleanup():
    while True:
        await cleanup_old_threads(checkpointer, days=30)
        await asyncio.sleep(86400)  # 24 å°æ—¶
```

#### **10. å®Œæ•´ç¤ºä¾‹ï¼šç”Ÿäº§çº§è®°å¿†ç³»ç»Ÿ**

```python
from langgraph.checkpoint.postgres import PostgresSaver
from typing import Annotated
import operator
from datetime import datetime

class ProductionState(TypedDict):
    messages: Annotated[list, add_messages]
    user_id: str
    user_name: str
    preferences: dict
    session_count: Annotated[int, operator.add]
    last_active: str
    metadata: dict

# æ•°æ®åº“è¿æ¥
checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:pass@localhost/langgraph"
)

def production_agent(state: ProductionState):
    # æ›´æ–°æ´»åŠ¨æ—¶é—´
    state["last_active"] = datetime.now().isoformat()

    # ä¸ªæ€§åŒ–é—®å€™
    if state.get("session_count", 0) == 0:
        greeting = f"ä½ å¥½ {state.get('user_name', 'ç”¨æˆ·')}ï¼å¾ˆé«˜å…´ä¸ºä½ æœåŠ¡ã€‚"
    else:
        greeting = f"æ¬¢è¿å›æ¥ï¼Œ{state.get('user_name')}ï¼"

    # æ„å»ºæ¶ˆæ¯
    messages = [SystemMessage(greeting)] + state["messages"]
    response = llm.invoke(messages)

    return {
        "messages": [response],
        "session_count": 1,
        "last_active": state["last_active"]
    }

# æ„å»ºå›¾
builder = StateGraph(ProductionState)
builder.add_node("agent", production_agent)
builder.add_edge(START, "agent")
builder.add_edge("agent", END)

graph = builder.compile(checkpointer=checkpointer)

# API ç«¯ç‚¹
@app.post("/api/chat")
async def chat_endpoint(
    user_id: str,
    message: str,
    user_name: str = "ç”¨æˆ·"
):
    config = {"configurable": {"thread_id": f"user-{user_id}"}}

    # è°ƒç”¨å›¾
    result = await graph.ainvoke(
        {
            "messages": [HumanMessage(message)],
            "user_id": user_id,
            "user_name": user_name,
            "preferences": {},  # å¯ä»¥ä»æ•°æ®åº“åŠ è½½
            "session_count": 0,
            "metadata": {"endpoint": "/api/chat"}
        },
        config
    )

    return {
        "response": result["messages"][-1].content,
        "session_count": result.get("session_count", 0)
    }
```

#### **å…³é”®è¦ç‚¹**
- **Checkpointer + Thread ID = è·¨ä¼šè¯è®°å¿†**
- **MemorySaverï¼šå¼€å‘æµ‹è¯•**
- **PostgresSaverï¼šç”Ÿäº§ç¯å¢ƒ**
- **Thread ID è®¾è®¡ï¼šæŒ‰ç”¨æˆ·/ä¼šè¯/åŠŸèƒ½éš”ç¦»**
- **å®šæœŸæ¸…ç†ï¼šé¿å…æ— é™å¢é•¿**

</details>

---

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè®©æˆ‘ç»§ç»­åˆ›å»ºå‰©ä½™çš„é—®é¢˜ 9-15...