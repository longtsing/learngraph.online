# Agentic 设计模式

> 反思、规划、工具使用、多智能体协作——构建智能 RAG 系统的四大基石

---

## 概述

Agentic RAG 的强大能力源于四种核心设计模式的组合应用。这些模式不是孤立存在的，而是相互协作，共同支撑起智能体的自主行为能力。

| 设计模式 | 核心能力 | 成熟度 | 可预测性 |
|----------|----------|--------|----------|
| **反思（Reflection）** | 自我评估与迭代改进 | 高 | 高 |
| **规划（Planning）** | 任务分解与路径规划 | 中 | 中 |
| **工具使用（Tool Use）** | 扩展能力边界 | 高 | 高 |
| **多智能体协作** | 分工合作与并行处理 | 中 | 低 |

---

## 一、反思模式（Reflection）

反思是最基础也是最成熟的 Agentic 设计模式，它使智能体能够**迭代评估和改进自己的输出**。

![反思模式](./images/agentic_self_reflection.png)
*图 1：Agentic 自我反思机制*

### 工作原理

```
初始输出 → 自我评估 → 识别问题 → 修正改进 → 再次评估 → ... → 满意输出
              ↑_______________________________|
                      反思循环
```

### 反思的三个层次

#### 1. 内部反思
智能体审视自己的输出，从**正确性、风格、效率**等维度进行自我批评：

```python
# 内部反思伪代码
def reflect(self, output):
    critique = self.llm.evaluate(output, criteria=[
        "correctness",  # 正确性
        "completeness", # 完整性
        "coherence",    # 连贯性
        "relevance"     # 相关性
    ])
    if critique.has_issues():
        return self.improve(output, critique.feedback)
    return output
```

#### 2. 外部验证
结合外部工具验证结果，如单元测试、Web 搜索等：

```
生成代码 → 运行单元测试 → 测试失败 → 分析错误 → 修正代码 → 重新测试
```

#### 3. 多智能体反思
一个智能体生成，另一个智能体批评，形成协作改进：

```
生成智能体 → 输出 → 批评智能体 → 反馈 → 生成智能体 → 改进输出
```

### 实际应用：法律研究系统

```
用户查询："关于数据隐私的最新判例"

第一轮：检索相关判例 → 生成摘要
反思：检查引用准确性、判例时效性
发现：部分判例已过时

第二轮：补充检索最新判例 → 更新摘要
反思：检查完整性和法律解释准确性
通过：输出最终结果
```

### 相关研究

- **Self-Refine**：迭代自我改进框架
- **Reflexion**：基于反思的强化学习
- **CRITIC**：自我验证与批评机制

---

## 二、规划模式（Planning）

规划使智能体能够**自主分解复杂任务**，动态确定完成目标所需的步骤序列。

![规划模式](./images/agentic_planning.png)
*图 2：Agentic 规划机制*

### 核心能力

规划模式的关键在于**动态适应**——当预定义工作流无法满足需求时，智能体能够自主规划执行路径：

```
复杂任务 → 任务分解 → 子任务序列 → 动态调整 → 执行监控 → 结果整合
```

### 规划 vs 反思

| 维度 | 反思 | 规划 |
|------|------|------|
| **时机** | 输出后评估 | 执行前规划 |
| **焦点** | 质量改进 | 路径选择 |
| **确定性** | 高度可预测 | 相对不确定 |
| **适用场景** | 单一输出优化 | 多步骤任务 |

### 规划策略

#### 1. 前向规划（Forward Planning）
从起点出发，逐步推进到目标：

```
当前状态 → 可用动作 → 选择最优 → 执行 → 新状态 → ...
```

#### 2. 后向规划（Backward Planning）
从目标倒推所需步骤：

```
目标状态 → 需要什么 → 前置条件 → 再前置 → ... → 当前状态
```

#### 3. 层次规划（Hierarchical Planning）
将大任务分解为多层子任务：

```
总任务
├── 子任务1
│   ├── 步骤1.1
│   └── 步骤1.2
├── 子任务2
│   ├── 步骤2.1
│   └── 步骤2.2
└── 子任务3
```

### 实际应用：研究报告生成

```
用户请求："撰写关于量子计算商业应用的研究报告"

规划输出：
1. 定义研究范围和目标受众
2. 检索学术文献（3-5篇核心论文）
3. 检索行业报告（市场规模、主要玩家）
4. 检索最新新闻（近期突破、投资动态）
5. 整合信息，构建报告框架
6. 分章节撰写内容
7. 添加引用和数据可视化
8. 自我审查和优化

执行监控：每步完成后评估是否需要调整后续计划
```

---

## 三、工具使用模式（Tool Use）

工具使用扩展了智能体的能力边界，使其能够**与外部系统交互**，获取实时数据、执行计算、操作资源。

![工具使用模式](./images/agentic_tool_use.png)
*图 3：Agentic 工具使用机制*

### 工具类型

| 类型 | 示例 | 能力扩展 |
|------|------|----------|
| **信息检索** | 向量数据库、Web 搜索 | 获取外部知识 |
| **数据处理** | SQL 查询、数据分析 | 结构化数据操作 |
| **计算工具** | 计算器、代码解释器 | 精确计算 |
| **外部 API** | 天气、股票、地图 | 实时信息 |
| **系统操作** | 文件读写、命令执行 | 环境交互 |

### 工具选择挑战

当可用工具数量众多时，**工具选择**成为关键挑战：

```
问题：50+ 可用工具，如何选择最合适的？

解决方案（受 RAG 启发）：
1. 工具描述向量化
2. 查询-工具相似度匹配
3. Top-K 工具候选
4. LLM 精细选择
```

### 工具使用工作流

```python
# 工具使用伪代码
def use_tools(self, task):
    # 1. 分析任务需要哪些工具
    required_tools = self.analyze_tool_needs(task)

    # 2. 选择最相关的工具
    selected_tools = self.select_tools(required_tools)

    # 3. 构建工具调用计划
    tool_plan = self.plan_tool_usage(selected_tools, task)

    # 4. 执行工具调用
    results = []
    for tool_call in tool_plan:
        result = self.execute_tool(tool_call)
        results.append(result)

    # 5. 整合工具结果
    return self.synthesize_results(results)
```

### 现代实现

- **GPT-4 Function Calling**：原生工具调用支持
- **LangChain Tools**：丰富的工具生态
- **MCP（Model Context Protocol）**：标准化工具协议

---

## 四、多智能体协作模式

多智能体协作将复杂任务**分配给多个专业化智能体**，每个智能体专注于特定领域，通过协作完成整体目标。

![多智能体模式](./images/multi_agent_pattern.png)
*图 4：多智能体协作架构*

### 设计理念

```
复杂任务
    │
    ↓
┌───────────────────────────────────────────┐
│             协调智能体（Orchestrator）       │
└───────────────────────────────────────────┘
    │           │           │           │
    ↓           ↓           ↓           ↓
┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐
│检索专家│  │分析专家│  │写作专家│  │验证专家│
└───────┘  └───────┘  └───────┘  └───────┘
    │           │           │           │
    └───────────┴───────────┴───────────┘
                    │
                    ↓
              结果整合与输出
```

### 协作模式

#### 1. 顺序协作
智能体按序处理，前一个的输出是后一个的输入：

```
Agent A → Agent B → Agent C → 最终输出
```

#### 2. 并行协作
多个智能体同时处理不同子任务：

```
        ┌→ Agent A ─┐
任务 ───┼→ Agent B ─┼→ 结果合并
        └→ Agent C ─┘
```

#### 3. 辩论协作
多个智能体对同一问题给出观点，通过辩论达成共识：

```
Agent A ←→ Agent B
    ↘      ↙
   最终共识
```

### 关键特性

| 特性 | 说明 |
|------|------|
| **独立记忆** | 每个智能体维护自己的上下文 |
| **专业化工具** | 不同智能体配备不同工具集 |
| **通信机制** | 中间结果共享与协调 |
| **失败隔离** | 单点失败不影响整体 |

### 实现框架

- **AutoGen**（微软）：多智能体对话框架
- **CrewAI**：角色扮演多智能体系统
- **LangGraph**：图结构智能体编排

---

## 设计模式组合应用

在实际的 Agentic RAG 系统中，这四种模式通常**组合使用**：

```
用户查询
    │
    ↓
┌─────────────────────────────────────┐
│          规划模式                    │
│   分解任务 → 确定执行路径            │
└─────────────────────────────────────┘
    │
    ↓
┌─────────────────────────────────────┐
│        多智能体协作                  │
│   分配子任务给专业智能体              │
└─────────────────────────────────────┘
    │
    ↓
┌─────────────────────────────────────┐
│         工具使用                     │
│   各智能体调用所需工具               │
└─────────────────────────────────────┘
    │
    ↓
┌─────────────────────────────────────┐
│          反思模式                    │
│   评估结果 → 迭代改进               │
└─────────────────────────────────────┘
    │
    ↓
最终输出
```

---

## 模式选择指南

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 单一输出质量优化 | 反思 | 迭代改进最有效 |
| 复杂多步骤任务 | 规划 | 需要路径规划 |
| 需要外部数据/能力 | 工具使用 | 扩展 LLM 边界 |
| 大规模并行处理 | 多智能体 | 分而治之 |
| 高准确性要求 | 反思 + 多智能体 | 多重验证 |
| 动态复杂任务 | 全部组合 | 综合能力 |

---

## 思考题

1. 在什么情况下，过度使用反思模式可能适得其反？
2. 如何设计智能体间的通信协议以最小化信息损失？
3. 工具选择的"最优"如何定义？准确性、速度、成本如何权衡？
