# 3.5 实战：实现自定义 LangChain Tool

## 完整的 Tool 类实现

```python
from abc import ABC, abstractmethod
from typing import Optional
from pydantic import BaseModel, Field

class ToolInput(BaseModel):
    """Tool 输入基类"""
    pass

class BaseTool(ABC):
    """Tool 抽象基类"""
    
    def __init__(self):
        self.call_count = 0
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        pass
    
    @abstractmethod
    def _run(self, **kwargs) -> str:
        pass
    
    def run(self, **kwargs) -> str:
        """公共运行接口"""
        self.call_count += 1
        return self._run(**kwargs)

class WeatherInput(ToolInput):
    location: str = Field(description="城市名称")

class WeatherTool(BaseTool):
    """天气查询工具"""
    
    @property
    def name(self) -> str:
        return "weather"
    
    @property
    def description(self) -> str:
        return "获取城市天气信息"
    
    def _run(self, location: str) -> str:
        return f"{location} 的天气：晴天 25°C"

# 使用
tool = WeatherTool()
print(tool.run(location="北京"))
print(f"调用次数: {tool.call_count}")
```

---

**下一节：[3.6 小结和复习](3.6-小结和复习.md)**
