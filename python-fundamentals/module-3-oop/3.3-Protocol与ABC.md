# 3.3 Protocol 与 ABC：LangChain 的设计模式

## Protocol：结构化子类型

```python
from typing import Protocol

class Runnable(Protocol):
    """可运行接口（LangChain 风格）"""
    
    def invoke(self, input: dict) -> dict:
        """调用方法"""
        ...

class MyTool:
    """实现 Runnable 接口"""
    
    def invoke(self, input: dict) -> dict:
        return {"result": "完成"}

def run_component(component: Runnable) -> dict:
    """接受任何实现 Runnable 的对象"""
    return component.invoke({"task": "execute"})

# Protocol 不需要显式继承
tool = MyTool()
print(run_component(tool))
```

## ABC：抽象基类

```python
from abc import ABC, abstractmethod

class BaseTool(ABC):
    """工具抽象基类"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """工具名称"""
        pass
    
    @abstractmethod
    def _run(self, query: str) -> str:
        """执行逻辑"""
        pass
    
    def run(self, query: str) -> str:
        """公共运行方法"""
        print(f"[{self.name}] 执行")
        return self._run(query)

class SearchTool(BaseTool):
    @property
    def name(self) -> str:
        return "search"
    
    def _run(self, query: str) -> str:
        return f"搜索结果: {query}"

tool = SearchTool()
print(tool.run("Python"))
```

---

**下一节：[3.4 dataclass](3.4-dataclass.md)**
