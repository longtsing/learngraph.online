# 7.2 HTTP è¯·æ±‚ä¸ API è°ƒç”¨

> **ğŸ¯ å°ç™½ç†è§£**ï¼šä»€ä¹ˆæ˜¯ HTTP è¯·æ±‚å’Œ APIï¼Ÿ
>
> æƒ³è±¡ä½ å»é¤å…åƒé¥­ï¼š
>
> ```
> ä½ ï¼ˆå®¢æˆ·ç«¯ï¼‰          æœåŠ¡å‘˜ï¼ˆAPIï¼‰           å¨æˆ¿ï¼ˆæœåŠ¡å™¨ï¼‰
>      â”‚                    â”‚                     â”‚
>      â”‚â”€â”€â”€â”€ ç‚¹èœå• â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚                     â”‚
>      â”‚    (HTTP è¯·æ±‚)      â”‚â”€â”€â”€â”€ è½¬è¾¾è®¢å• â”€â”€â”€â”€â†’â”‚
>      â”‚                    â”‚                     â”‚
>      â”‚                    â”‚â†â”€â”€â”€â”€ åšå¥½çš„èœ â”€â”€â”€â”€â”€â”‚
>      â”‚â†â”€â”€â”€â”€ ä¸Šèœ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                     â”‚
>           (HTTP å“åº”)
> ```
>
> **å…³é”®æ¦‚å¿µ**ï¼š
>
> | æ¦‚å¿µ | é¤å…æ¯”å–» | ç¼–ç¨‹è§£é‡Š |
> |------|---------|---------|
> | **API** | æœåŠ¡å‘˜ | ç¨‹åºä¹‹é—´é€šä¿¡çš„æ¥å£ |
> | **HTTP è¯·æ±‚** | ä½ çš„ç‚¹èœå• | ä½ å‘ç»™æœåŠ¡å™¨çš„æŒ‡ä»¤ |
> | **HTTP å“åº”** | ä¸Šçš„èœ | æœåŠ¡å™¨è¿”å›çš„æ•°æ® |
> | **GET è¯·æ±‚** | é—®"æœ‰ä»€ä¹ˆèœï¼Ÿ" | è·å–æ•°æ® |
> | **POST è¯·æ±‚** | "æˆ‘è¦ç‚¹è¿™äº›èœ" | å‘é€æ•°æ® |
>
> **OpenAI API å°±æ˜¯è¿™æ ·**ï¼šä½ å‘è¯·æ±‚è¯´"è¯·å›ç­”è¿™ä¸ªé—®é¢˜"ï¼Œå®ƒè¿”å› AI çš„å›ç­”ã€‚

## requests åº“åŸºç¡€

> **ğŸ¯ å°ç™½ç†è§£**ï¼š`requests` æ˜¯ Python æœ€æµè¡Œçš„ HTTP åº“ï¼Œç”¨æ¥"å‘é€è¯·æ±‚ã€æ¥æ”¶å“åº”"ã€‚

### å®‰è£…

```bash
pip install requests
```

### åŸºæœ¬è¯·æ±‚

> **ğŸ¯ å°ç™½ç†è§£**ï¼šHTTP è¯·æ±‚çš„å››ç§å¸¸ç”¨æ–¹æ³•
>
> | æ–¹æ³• | ç”¨é€” | ç±»æ¯” |
> |------|------|------|
> | `GET` | è·å–æ•°æ® | æŸ¥çœ‹èœå• |
> | `POST` | å‘é€æ•°æ® | ä¸‹è®¢å• |
> | `PUT` | æ›´æ–°æ•°æ® | ä¿®æ”¹è®¢å• |
> | `DELETE` | åˆ é™¤æ•°æ® | å–æ¶ˆè®¢å• |

```python
import requests
from typing import Dict, Any

# GET è¯·æ±‚
response = requests.get("https://api.github.com/users/python")
print(response.status_code)  # 200
print(response.json())  # è§£æ JSON å“åº”

# POST è¯·æ±‚
payload = {"name": "Agent", "status": "active"}
response = requests.post(
    "https://api.example.com/agents",
    json=payload,
    headers={"Content-Type": "application/json"}
)

# å¸¦å‚æ•°çš„ GET è¯·æ±‚
params = {"q": "python", "per_page": 10}
response = requests.get("https://api.github.com/search/repositories", params=params)

# å¸¦è®¤è¯çš„è¯·æ±‚
headers = {"Authorization": "Bearer YOUR_TOKEN"}
response = requests.get("https://api.example.com/data", headers=headers)
```

## OpenAI API è°ƒç”¨

> **ğŸ¯ å°ç™½ç†è§£**ï¼šè°ƒç”¨ OpenAI API çš„æµç¨‹
>
> ```
> 1. å‡†å¤‡è¯·æ±‚
>    â”œâ”€â”€ API Keyï¼ˆèº«ä»½è¯æ˜ï¼‰
>    â”œâ”€â”€ æ¨¡å‹åç§°ï¼ˆgpt-4ï¼‰
>    â””â”€â”€ æ¶ˆæ¯å†…å®¹ï¼ˆä½ çš„é—®é¢˜ï¼‰
>
> 2. å‘é€ POST è¯·æ±‚åˆ° OpenAI æœåŠ¡å™¨
>
> 3. æ¥æ”¶å“åº”
>    â””â”€â”€ AI çš„å›ç­”åœ¨ response["choices"][0]["message"]["content"]
> ```
>
> **æ¶ˆæ¯æ ¼å¼**ï¼š
>
> ```python
> messages = [
>     {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªåŠ©æ‰‹"},  # ç³»ç»Ÿè®¾å®š
>     {"role": "user", "content": "ä½ å¥½"},           # ç”¨æˆ·è¯´çš„è¯
>     {"role": "assistant", "content": "ä½ å¥½ï¼"}     # AI çš„å›å¤
> ]
> ```
>
> è¿™å°±æ˜¯ ChatGPT çš„å·¥ä½œåŸç†ï¼

```python
import os
import requests
from typing import List, Dict, Any, Optional

class OpenAIClient:
    """OpenAI API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.base_url = "https://api.openai.com/v1"
        
        if not self.api_key:
            raise ValueError("API Key æœªé…ç½®")
    
    def _headers(self) -> Dict[str, str]:
        """ç”Ÿæˆè¯·æ±‚å¤´"""
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
    
    def chat_completion(
        self,
        messages: List[Dict[str, str]],
        model: str = "gpt-4",
        temperature: float = 0.7,
        max_tokens: int = 2000
    ) -> Dict[str, Any]:
        """è°ƒç”¨ Chat Completion API"""
        url = f"{self.base_url}/chat/completions"
        
        payload = {
            "model": model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens
        }
        
        response = requests.post(
            url,
            headers=self._headers(),
            json=payload,
            timeout=30
        )
        
        response.raise_for_status()  # æŠ›å‡º HTTP é”™è¯¯
        return response.json()
    
    def get_models(self) -> List[str]:
        """è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨"""
        url = f"{self.base_url}/models"
        
        response = requests.get(
            url,
            headers=self._headers(),
            timeout=10
        )
        
        response.raise_for_status()
        data = response.json()
        
        return [model["id"] for model in data["data"]]

# ä½¿ç”¨ç¤ºä¾‹
client = OpenAIClient()

# å‘é€æ¶ˆæ¯
messages = [
    {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„åŠ©æ‰‹ã€‚"},
    {"role": "user", "content": "è§£é‡Šä»€ä¹ˆæ˜¯ API"}
]

result = client.chat_completion(messages)
print(result["choices"][0]["message"]["content"])

# è·å–æ¨¡å‹åˆ—è¡¨
models = client.get_models()
print(f"å¯ç”¨æ¨¡å‹: {len(models)} ä¸ª")
```

## å¼‚æ­¥ HTTP è¯·æ±‚ï¼ˆhttpxï¼‰

> **ğŸ¯ å°ç™½ç†è§£**ï¼šä¸ºä»€ä¹ˆéœ€è¦"å¼‚æ­¥"è¯·æ±‚ï¼Ÿ
>
> **åŒæ­¥è¯·æ±‚**ï¼ˆä¸€ä¸ªä¸€ä¸ªæ¥ï¼‰ï¼š
>
> ```
> è¯·æ±‚1 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”1
>                   è¯·æ±‚2 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”2
>                                     è¯·æ±‚3 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”3
> æ€»æ—¶é—´: 3ç§’ + 3ç§’ + 3ç§’ = 9ç§’
> ```
>
> **å¼‚æ­¥è¯·æ±‚**ï¼ˆåŒæ—¶å‘å‡ºï¼‰ï¼š
>
> ```
> è¯·æ±‚1 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”1
> è¯·æ±‚2 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”2  ï¼ˆåŒæ—¶è¿›è¡Œï¼ï¼‰
> è¯·æ±‚3 â”€â”€ç­‰å¾…â”€â”€â†’ å“åº”3
> æ€»æ—¶é—´: çº¦ 3ç§’
> ```
>
> **ç±»æ¯”**ï¼šåŒæ­¥ = ä¸€ä¸ªæœåŠ¡å‘˜ï¼Œä¸€æ¬¡åªèƒ½æœåŠ¡ä¸€æ¡Œï¼›å¼‚æ­¥ = ä¸€ä¸ªæœåŠ¡å‘˜ï¼Œå¯ä»¥åŒæ—¶è®°å½•å¤šæ¡Œçš„è®¢å•
>
> **ä»€ä¹ˆæ—¶å€™ç”¨å¼‚æ­¥ï¼Ÿ**
>
> - éœ€è¦åŒæ—¶è°ƒç”¨å¤šä¸ª API
> - éœ€è¦åŒæ—¶å¤„ç†å¤šä¸ªç”¨æˆ·çš„è¯·æ±‚
> - éœ€è¦æé«˜ç¨‹åºå“åº”é€Ÿåº¦

### å®‰è£…

```bash
pip install httpx
```

### å¼‚æ­¥ API å®¢æˆ·ç«¯

```python
import asyncio
import httpx
from typing import List, Dict, Any
import os

class AsyncOpenAIClient:
    """å¼‚æ­¥ OpenAI API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.base_url = "https://api.openai.com/v1"
        self.client = httpx.AsyncClient(
            headers={
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            },
            timeout=30.0
        )
    
    async def chat_completion(
        self,
        messages: List[Dict[str, str]],
        model: str = "gpt-4",
        temperature: float = 0.7
    ) -> Dict[str, Any]:
        """å¼‚æ­¥è°ƒç”¨ Chat API"""
        url = f"{self.base_url}/chat/completions"
        
        payload = {
            "model": model,
            "messages": messages,
            "temperature": temperature
        }
        
        response = await self.client.post(url, json=payload)
        response.raise_for_status()
        return response.json()
    
    async def batch_completion(
        self,
        queries: List[str],
        system_prompt: str = "ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„åŠ©æ‰‹ã€‚"
    ) -> List[str]:
        """æ‰¹é‡å¤„ç†æŸ¥è¯¢"""
        tasks = []
        
        for query in queries:
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": query}
            ]
            tasks.append(self.chat_completion(messages))
        
        results = await asyncio.gather(*tasks)
        
        return [
            result["choices"][0]["message"]["content"]
            for result in results
        ]
    
    async def close(self):
        """å…³é—­å®¢æˆ·ç«¯"""
        await self.client.aclose()

# ä½¿ç”¨ç¤ºä¾‹
async def demo_async_client():
    client = AsyncOpenAIClient()
    
    try:
        # å¹¶å‘å¤„ç†å¤šä¸ªæŸ¥è¯¢
        queries = [
            "ä»€ä¹ˆæ˜¯ Python?",
            "ä»€ä¹ˆæ˜¯å¼‚æ­¥ç¼–ç¨‹?",
            "ä»€ä¹ˆæ˜¯ LangChain?"
        ]
        
        import time
        start = time.time()
        
        results = await client.batch_completion(queries)
        
        end = time.time()
        
        print(f"å¤„ç† {len(queries)} ä¸ªæŸ¥è¯¢ï¼Œè€—æ—¶: {end - start:.2f}ç§’\n")
        
        for query, result in zip(queries, results):
            print(f"Q: {query}")
            print(f"A: {result[:100]}...\n")
    
    finally:
        await client.close()

# è¿è¡Œ
# asyncio.run(demo_async_client())
```

## é”™è¯¯å¤„ç†ä¸é‡è¯•

> **ğŸ¯ å°ç™½ç†è§£**ï¼šä¸ºä»€ä¹ˆ API è°ƒç”¨éœ€è¦"é‡è¯•"ï¼Ÿ
>
> ç½‘ç»œè¯·æ±‚å¯èƒ½å¤±è´¥ï¼ŒåŸå› æœ‰å¾ˆå¤šï¼š
>
> | é”™è¯¯ç±»å‹ | å«ä¹‰ | åº”å¯¹ç­–ç•¥ |
> |---------|------|---------|
> | `401` | èº«ä»½éªŒè¯å¤±è´¥ | æ£€æŸ¥ API Key |
> | `429` | è¯·æ±‚å¤ªé¢‘ç¹ | ç­‰ä¸€ä¼šå„¿å†è¯• |
> | `500` | æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ | è¿‡ä¼šå„¿é‡è¯• |
> | `Timeout` | è¯·æ±‚è¶…æ—¶ | é‡è¯•æˆ–å¢åŠ è¶…æ—¶æ—¶é—´ |
>
> **æŒ‡æ•°é€€é¿ç­–ç•¥**ï¼š
>
> ```
> ç¬¬1æ¬¡å¤±è´¥ â†’ ç­‰ 1 ç§’ â†’ é‡è¯•
> ç¬¬2æ¬¡å¤±è´¥ â†’ ç­‰ 2 ç§’ â†’ é‡è¯•
> ç¬¬3æ¬¡å¤±è´¥ â†’ ç­‰ 4 ç§’ â†’ é‡è¯•
> ç¬¬4æ¬¡å¤±è´¥ â†’ æ”¾å¼ƒï¼ŒæŠ¥é”™
> ```
>
> ç­‰å¾…æ—¶é—´ç¿»å€ï¼Œé¿å…ä¸€ç›´"éªšæ‰°"å·²ç»å¾ˆå¿™çš„æœåŠ¡å™¨ã€‚

```python
import requests
import time
from typing import Dict, Any, Optional, Callable
from functools import wraps

class APIError(Exception):
    """API é”™è¯¯åŸºç±»"""
    pass

class RateLimitError(APIError):
    """é€Ÿç‡é™åˆ¶é”™è¯¯"""
    pass

class AuthenticationError(APIError):
    """è®¤è¯é”™è¯¯"""
    pass

def retry_on_error(
    max_retries: int = 3,
    initial_delay: float = 1.0,
    backoff_factor: float = 2.0,
    exceptions: tuple = (requests.RequestException,)
):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            delay = initial_delay
            last_exception = None
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if attempt < max_retries - 1:
                        print(f"é‡è¯• {attempt + 1}/{max_retries}: {e}")
                        time.sleep(delay)
                        delay *= backoff_factor
            
            raise last_exception
        
        return wrapper
    return decorator

class RobustAPIClient:
    """å¥å£®çš„ API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1"
    
    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:
        """å¤„ç†å“åº”å’Œé”™è¯¯"""
        if response.status_code == 200:
            return response.json()
        
        elif response.status_code == 401:
            raise AuthenticationError("API Key æ— æ•ˆ")
        
        elif response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", 60))
            raise RateLimitError(f"é€Ÿç‡é™åˆ¶ï¼Œè¯·ç­‰å¾… {retry_after} ç§’")
        
        elif response.status_code >= 500:
            raise APIError(f"æœåŠ¡å™¨é”™è¯¯: {response.status_code}")
        
        else:
            raise APIError(f"è¯·æ±‚å¤±è´¥: {response.status_code} - {response.text}")
    
    @retry_on_error(max_retries=3, exceptions=(requests.RequestException, RateLimitError))
    def chat_completion(
        self,
        messages: List[Dict[str, str]],
        model: str = "gpt-4"
    ) -> Dict[str, Any]:
        """è°ƒç”¨ Chat APIï¼ˆå¸¦é‡è¯•ï¼‰"""
        url = f"{self.base_url}/chat/completions"
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": model,
            "messages": messages
        }
        
        try:
            response = requests.post(
                url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            return self._handle_response(response)
        
        except requests.Timeout:
            raise APIError("è¯·æ±‚è¶…æ—¶")
        
        except requests.ConnectionError:
            raise APIError("è¿æ¥å¤±è´¥")

# ä½¿ç”¨ç¤ºä¾‹
try:
    client = RobustAPIClient(api_key=os.getenv("OPENAI_API_KEY"))
    
    messages = [
        {"role": "user", "content": "Hello"}
    ]
    
    result = client.chat_completion(messages)
    print(result)

except AuthenticationError as e:
    print(f"è®¤è¯é”™è¯¯: {e}")

except RateLimitError as e:
    print(f"é€Ÿç‡é™åˆ¶: {e}")

except APIError as e:
    print(f"API é”™è¯¯: {e}")
```

## æµå¼å“åº”å¤„ç†

> **ğŸ¯ å°ç™½ç†è§£**ï¼šä»€ä¹ˆæ˜¯"æµå¼å“åº”"ï¼Ÿ
>
> **æ™®é€šå“åº”**ï¼šç­‰ AI å†™å®Œæ•´ç¯‡æ–‡ç« ï¼Œä¸€æ¬¡æ€§è¿”å›
>
> ```
> ç”¨æˆ·æé—® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [ç­‰å¾… 10 ç§’] â”€â”€â†’ ä¸€æ¬¡æ€§æ˜¾ç¤ºå…¨éƒ¨å›ç­”
> ```
>
> **æµå¼å“åº”**ï¼šAI è¾¹å†™è¾¹è¿”å›ï¼Œåƒæ‰“å­—ä¸€æ ·é€å­—æ˜¾ç¤º
>
> ```
> ç”¨æˆ·æé—® â†’ "ä½ " â†’ "å¥½" â†’ "ï¼Œ" â†’ "æˆ‘" â†’ "æ˜¯" â†’ "AI" â†’ ...
> ```
>
> **æµå¼å“åº”çš„å¥½å¤„**ï¼š
>
> 1. **ä½“éªŒæ›´å¥½**ï¼šç”¨æˆ·ä¸ç”¨å¹²ç­‰ï¼Œèƒ½çœ‹åˆ° AI åœ¨"æ€è€ƒ"
> 2. **æ„Ÿè§‰æ›´å¿«**ï¼šç¬¬ä¸€ä¸ªå­—å¾ˆå¿«å°±å‡ºç°äº†
> 3. **ChatGPT å°±æ˜¯è¿™æ ·åšçš„ï¼**
>
> **æŠ€æœ¯åŸç†**ï¼šä½¿ç”¨ SSEï¼ˆServer-Sent Eventsï¼‰ï¼ŒæœåŠ¡å™¨æŒç»­å‘é€å°å—æ•°æ®ã€‚

```python
import requests
import json
from typing import Iterator, Dict, Any

class StreamingAPIClient:
    """æµå¼ API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1"
    
    def chat_completion_stream(
        self,
        messages: List[Dict[str, str]],
        model: str = "gpt-4"
    ) -> Iterator[str]:
        """æµå¼è°ƒç”¨ Chat API"""
        url = f"{self.base_url}/chat/completions"
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": model,
            "messages": messages,
            "stream": True  # å¯ç”¨æµå¼å“åº”
        }
        
        with requests.post(
            url,
            headers=headers,
            json=payload,
            stream=True,
            timeout=30
        ) as response:
            response.raise_for_status()
            
            for line in response.iter_lines():
                if not line:
                    continue
                
                # è§£ç å¹¶è§£æ SSE æ ¼å¼
                line = line.decode('utf-8')
                
                if line.startswith("data: "):
                    data = line[6:]  # å»æ‰ "data: " å‰ç¼€
                    
                    if data == "[DONE]":
                        break
                    
                    try:
                        chunk = json.loads(data)
                        delta = chunk["choices"][0]["delta"]
                        
                        if "content" in delta:
                            yield delta["content"]
                    
                    except json.JSONDecodeError:
                        continue

# ä½¿ç”¨ç¤ºä¾‹
client = StreamingAPIClient(api_key=os.getenv("OPENAI_API_KEY"))

messages = [
    {"role": "user", "content": "å†™ä¸€é¦–å…³äº Python çš„è¯—"}
]

print("Agent: ", end="", flush=True)

for chunk in client.chat_completion_stream(messages):
    print(chunk, end="", flush=True)

print()
```

## API é€Ÿç‡é™åˆ¶ç®¡ç†

```python
import time
from collections import deque
from typing import Callable, Any
from functools import wraps

class RateLimiter:
    """é€Ÿç‡é™åˆ¶å™¨"""
    
    def __init__(self, max_calls: int, period: float):
        """
        Args:
            max_calls: æ—¶é—´çª—å£å†…æœ€å¤§è°ƒç”¨æ¬¡æ•°
            period: æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        """
        self.max_calls = max_calls
        self.period = period
        self.calls = deque()
    
    def __call__(self, func: Callable) -> Callable:
        """è£…é¥°å™¨"""
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            now = time.time()
            
            # æ¸…ç†è¿‡æœŸçš„è°ƒç”¨è®°å½•
            while self.calls and self.calls[0] < now - self.period:
                self.calls.popleft()
            
            # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
            if len(self.calls) >= self.max_calls:
                sleep_time = self.period - (now - self.calls[0])
                if sleep_time > 0:
                    print(f"é€Ÿç‡é™åˆ¶ï¼Œç­‰å¾… {sleep_time:.2f} ç§’...")
                    time.sleep(sleep_time)
                    # é‡æ–°æ¸…ç†
                    now = time.time()
                    while self.calls and self.calls[0] < now - self.period:
                        self.calls.popleft()
            
            # è®°å½•è°ƒç”¨
            self.calls.append(now)
            
            return func(*args, **kwargs)
        
        return wrapper

# ä½¿ç”¨ç¤ºä¾‹
class APIClientWithRateLimit:
    """å¸¦é€Ÿç‡é™åˆ¶çš„ API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        # é™åˆ¶: æ¯åˆ†é’Ÿæœ€å¤š 20 æ¬¡è°ƒç”¨
        self.rate_limiter = RateLimiter(max_calls=20, period=60)
    
    @property
    def chat_completion(self):
        """è¿”å›å¸¦é€Ÿç‡é™åˆ¶çš„æ–¹æ³•"""
        return self.rate_limiter(self._chat_completion)
    
    def _chat_completion(self, messages: List[Dict[str, str]]) -> Dict[str, Any]:
        """å®é™…çš„ API è°ƒç”¨"""
        print(f"è°ƒç”¨ API: {time.time():.2f}")
        # å®é™… API è°ƒç”¨é€»è¾‘
        return {"status": "success"}

# æµ‹è¯•
client = APIClientWithRateLimit(api_key="test")

# å¿«é€Ÿè¿ç»­è°ƒç”¨
for i in range(25):
    result = client.chat_completion([{"role": "user", "content": f"æ¶ˆæ¯ {i}"}])
```

## å…³é”®è¦ç‚¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨ `try-except` å¤„ç†æ‰€æœ‰ HTTP é”™è¯¯
2. **é‡è¯•æœºåˆ¶**ï¼šå®ç°æŒ‡æ•°é€€é¿ç­–ç•¥
3. **è¶…æ—¶è®¾ç½®**ï¼šå§‹ç»ˆè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
4. **é€Ÿç‡é™åˆ¶**ï¼šéµå®ˆ API æä¾›å•†çš„é€Ÿç‡é™åˆ¶
5. **æµå¼å“åº”**ï¼šå¯¹äºé•¿æ–‡æœ¬ç”Ÿæˆï¼Œä½¿ç”¨æµå¼ API

---

**ä¸‹ä¸€èŠ‚ï¼š[7.3 å®æˆ˜ï¼šå¤š API é›†æˆç³»ç»Ÿ](7.3-å®æˆ˜ï¼šå¤šAPIé›†æˆç³»ç»Ÿ.md)**
