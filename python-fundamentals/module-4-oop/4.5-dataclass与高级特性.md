# 3.4 dataclass 与高级特性

## dataclass 基础

```python
from dataclasses import dataclass, field
from typing import List, Optional

@dataclass
class AgentConfig:
    """Agent 配置（使用 dataclass）"""
    name: str
    model: str
    temperature: float = 0.7
    max_tokens: int = 2000
    tools: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        """初始化后验证"""
        if not 0 <= self.temperature <= 2:
            raise ValueError("temperature 必须在 0-2 之间")

# 使用
config = AgentConfig(
    name="ResearchBot",
    model="gpt-4",
    tools=["search", "calculator"]
)

print(config)  # 自动生成 __repr__
print(config.temperature)  # 访问属性

# 自动生成 __eq__
config2 = AgentConfig(name="ResearchBot", model="gpt-4")
print(config == config2)  # True
```

## field() 高级用法

```python
from dataclasses import dataclass, field
from typing import List, Dict, Any
from datetime import datetime

@dataclass
class Message:
    """消息数据类"""
    role: str
    content: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # 不包含在比较中
    id: str = field(default="", compare=False)
    
    # 不包含在 repr 中
    raw_data: Dict = field(default_factory=dict, repr=False)
    
    # 不初始化（由 __post_init__ 设置）
    token_count: int = field(init=False)
    
    def __post_init__(self):
        """计算 token 数量"""
        self.token_count = len(self.content.split())

# 使用
msg = Message(role="user", content="Hello world")
print(msg)  # 不显示 raw_data
print(f"Token 数量: {msg.token_count}")
```

## 不可变 dataclass

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class ImmutableConfig:
    """不可变配置"""
    api_key: str
    model: str
    temperature: float = 0.7

# 创建
config = ImmutableConfig(api_key="sk-xxx", model="gpt-4")

# 尝试修改会报错
try:
    config.temperature = 0.5
except Exception as e:
    print(f"错误: {e}")  # FrozenInstanceError

# 可以作为字典的键
configs = {
    config: "production"
}
```

## dataclass 与继承

```python
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class BaseAgent(ABC):
    """Agent 基类"""
    name: str
    verbose: bool = False
    
    @abstractmethod
    def run(self, input: str) -> str:
        """运行 Agent"""
        pass

@dataclass
class ChatAgent(BaseAgent):
    """聊天 Agent"""
    model: str = "gpt-5"
    temperature: float = 0.7
    
    def run(self, input: str) -> str:
        """执行聊天"""
        if self.verbose:
            print(f"[{self.name}] 处理: {input}")
        
        return f"响应: {input}"

# 使用
agent = ChatAgent(name="Assistant", model="gpt-3.5-turbo")
result = agent.run("你好")
print(result)
```

## asdict 和 astuple

```python
from dataclasses import dataclass, asdict, astuple
import json

@dataclass
class Tool:
    """工具配置"""
    name: str
    enabled: bool
    timeout: float = 30.0

@dataclass
class AgentSetup:
    """完整 Agent 设置"""
    name: str
    tools: List[Tool]
    max_iterations: int = 10

# 创建对象
setup = AgentSetup(
    name="ResearchBot",
    tools=[
        Tool(name="search", enabled=True),
        Tool(name="calculator", enabled=False, timeout=10.0)
    ]
)

# 转换为字典
setup_dict = asdict(setup)
print(json.dumps(setup_dict, indent=2))

# 转换为元组
setup_tuple = astuple(setup)
print(setup_tuple)
```

## __slots__ 优化内存

```python
from dataclasses import dataclass

@dataclass(slots=True)
class OptimizedMessage:
    """内存优化的消息类"""
    role: str
    content: str
    timestamp: float
    
    # 使用 slots 可以减少内存占用

# 对比内存使用
import sys

# 不使用 slots
@dataclass
class RegularMessage:
    role: str
    content: str
    timestamp: float

regular = RegularMessage("user", "hello", 1234567890.0)
optimized = OptimizedMessage("user", "hello", 1234567890.0)

print(f"Regular: {sys.getsizeof(regular)} bytes")
print(f"Optimized: {sys.getsizeof(optimized)} bytes")
```

## 高级类特性

### 1. __init_subclass__

```python
from typing import Dict, Type

class RegistryMixin:
    """自动注册子类"""
    _registry: Dict[str, Type] = {}
    
    def __init_subclass__(cls, **kwargs):
        """子类创建时自动注册"""
        super().__init_subclass__(**kwargs)
        cls._registry[cls.__name__] = cls
    
    @classmethod
    def get_class(cls, name: str) -> Type:
        """根据名称获取类"""
        return cls._registry.get(name)

@dataclass
class BaseTool(RegistryMixin):
    """工具基类"""
    name: str

@dataclass
class SearchTool(BaseTool):
    """搜索工具"""
    max_results: int = 5

@dataclass
class CalculatorTool(BaseTool):
    """计算工具"""
    precision: int = 2

# 自动注册
print(BaseTool._registry.keys())  # dict_keys(['BaseTool', 'SearchTool', 'CalculatorTool'])

# 根据名称创建实例
ToolClass = BaseTool.get_class("SearchTool")
tool = ToolClass(name="google_search")
print(tool)
```

### 2. 描述符 (Descriptor)

```python
class Validated:
    """验证描述符"""
    
    def __init__(self, validator):
        self.validator = validator
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return obj.__dict__.get(self.name)
    
    def __set__(self, obj, value):
        if not self.validator(value):
            raise ValueError(f"验证失败: {self.name} = {value}")
        obj.__dict__[self.name] = value

class Temperature:
    """温度参数（带验证）"""
    value = Validated(lambda x: 0 <= x <= 2)
    
    def __init__(self, value: float):
        self.value = value

# 使用
temp = Temperature(0.7)
print(temp.value)  # 0.7

try:
    temp.value = 3.0  # 会抛出 ValueError
except ValueError as e:
    print(e)
```

### 3. 元类 (Metaclass)

```python
class SingletonMeta(type):
    """单例元类"""
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class ConfigManager(metaclass=SingletonMeta):
    """配置管理器（单例）"""
    
    def __init__(self):
        self.config = {}
    
    def set(self, key: str, value: Any):
        self.config[key] = value
    
    def get(self, key: str) -> Any:
        return self.config.get(key)

# 无论创建多少次，都是同一个实例
manager1 = ConfigManager()
manager2 = ConfigManager()

manager1.set("model", "gpt-4")
print(manager2.get("model"))  # gpt-4

print(manager1 is manager2)  # True
```

## 属性装饰器

```python
from typing import Optional

class Agent:
    """Agent 类（带属性）"""
    
    def __init__(self, name: str):
        self._name = name
        self._model: Optional[str] = None
        self._ready = False
    
    @property
    def name(self) -> str:
        """获取名称"""
        return self._name
    
    @property
    def model(self) -> Optional[str]:
        """获取模型"""
        return self._model
    
    @model.setter
    def model(self, value: str):
        """设置模型"""
        if value not in ["gpt-4", "gpt-3.5-turbo", "claude-3"]:
            raise ValueError(f"不支持的模型: {value}")
        self._model = value
        self._ready = True
    
    @model.deleter
    def model(self):
        """删除模型"""
        self._model = None
        self._ready = False
    
    @property
    def ready(self) -> bool:
        """是否就绪"""
        return self._ready

# 使用
agent = Agent("Assistant")
print(agent.name)  # Assistant

agent.model = "gpt-4"
print(agent.model)  # gpt-4
print(agent.ready)  # True

del agent.model
print(agent.ready)  # False
```

## 上下文管理器协议

```python
from typing import Optional
import time

class TimedOperation:
    """计时上下文管理器"""
    
    def __init__(self, operation_name: str, verbose: bool = True):
        self.operation_name = operation_name
        self.verbose = verbose
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None
    
    def __enter__(self):
        """进入上下文"""
        if self.verbose:
            print(f"开始 {self.operation_name}...")
        self.start_time = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文"""
        self.end_time = time.time()
        elapsed = self.end_time - self.start_time
        
        if exc_type is None:
            if self.verbose:
                print(f"{self.operation_name} 完成，耗时: {elapsed:.2f}秒")
        else:
            if self.verbose:
                print(f"{self.operation_name} 失败: {exc_val}")
        
        return False  # 不抑制异常
    
    @property
    def elapsed(self) -> Optional[float]:
        """获取耗时"""
        if self.start_time and self.end_time:
            return self.end_time - self.start_time
        return None

# 使用
with TimedOperation("API 调用"):
    time.sleep(1)
    # 执行操作...

print()

# 错误情况
try:
    with TimedOperation("失败的操作") as timer:
        time.sleep(0.5)
        raise ValueError("模拟错误")
except ValueError:
    pass
```

## 关键要点

1. **dataclass**：简化数据类的创建
2. **field()**：控制字段行为
3. **frozen=True**：创建不可变对象
4. **slots=True**：优化内存使用
5. **描述符**：实现属性验证
6. **元类**：定制类的创建行为
7. **属性装饰器**：控制属性访问

---

**下一节：[3.5 实战：自定义 Tool](3.5-实战：自定义Tool.md)**
