# 3.1 类与对象：Agent 的抽象

## 引言

> **小白理解 - 类和对象的关系**
>
> 想象你在**制造汽车**：
>
> | 概念 | 汽车类比 | Python |
> |------|----------|--------|
> | **类（Class）** | 汽车设计图纸 | `class Car:` |
> | **对象（Object）** | 根据图纸造出的真车 | `my_car = Car()` |
> | **属性（Attribute）** | 车的特征（颜色、品牌） | `self.color = "红色"` |
> | **方法（Method）** | 车能做的事（启动、刹车） | `def start(self):` |
>
> **关键理解**：
> - 一张图纸（类）可以造出无数辆车（对象）
> - 每辆车有自己的颜色（属性），但都能启动（方法）

## 类的基础

> **小白理解 - 看懂第一个类**
>
> ```python
> class Agent:                    # ← 定义一张"Agent设计图"
>     def __init__(self, name):   # ← 造Agent时必须做的事（初始化）
>         self.name = name        # ← 每个Agent都有自己的名字
>
>     def say_hello(self):        # ← Agent能做的事（方法）
>         print(f"你好，我是{self.name}")
>
> # 根据图纸造两个Agent
> agent1 = Agent("小助手")        # ← 造第一个
> agent2 = Agent("大管家")        # ← 造第二个
>
> agent1.say_hello()  # 输出：你好，我是小助手
> agent2.say_hello()  # 输出：你好，我是大管家
> ```
>
> **`self` 是什么？** 就是"我自己"
> - `agent1.say_hello()` 时，`self` 就是 `agent1`
> - `agent2.say_hello()` 时，`self` 就是 `agent2`
>
> **`__init__` 是什么？** 就是"出生时要做的事"
> - 每次 `Agent("名字")` 创建对象时，自动执行 `__init__`

```python
class Agent:
    """简单的 Agent 类"""

    def __init__(self, name: str, model: str = "gpt-3.5-turbo"):
        """初始化方法"""
        self.name = name
        self.model = model
        self.messages = []

    def add_message(self, role: str, content: str) -> None:
        """添加消息"""
        self.messages.append({"role": role, "content": content})

    def get_history(self) -> list:
        """获取历史"""
        return self.messages

# 创建实例
agent = Agent("ResearchBot", "gpt-4")
agent.add_message("user", "Hello")
print(agent.get_history())
```

> **代码逐行解读**：
>
> | 行 | 代码 | 含义 |
> |----|------|------|
> | 1 | `class Agent:` | 开始定义"Agent设计图" |
> | 4 | `def __init__(self, name, model)` | 创建Agent时必须提供名字，model有默认值 |
> | 6-8 | `self.xxx = xxx` | 给这个Agent设置属性 |
> | 10-12 | `def add_message(...)` | 定义一个方法：添加消息 |
> | 18 | `agent = Agent("ResearchBot", "gpt-4")` | 创建一个具体的Agent |

## 实战：完整的 Agent 类

> **小白理解 - 这段代码在做什么？**
>
> 我们要造一个"聊天机器人"：
> - 有名字、使用的模型、系统提示词
> - 能聊天（chat）
> - 能记住聊天历史
> - 能查看消息数量
> - 能清空历史

```python
from typing import Optional, List, Dict
from dataclasses import dataclass, field

@dataclass
class Message:
    role: str
    content: str

class ConversationalAgent:
    """对话型 Agent"""

    def __init__(
        self,
        name: str,
        model: str = "gpt-3.5-turbo",
        system_prompt: Optional[str] = None
    ):
        self.name = name
        self.model = model
        self.system_prompt = system_prompt or "You are a helpful assistant."
        self._messages: List[Message] = []
        self._stats = {"total_messages": 0}

    def chat(self, user_input: str) -> str:
        """对话"""
        # 添加用户消息
        self._messages.append(Message("user", user_input))
        self._stats["total_messages"] += 1

        # 模拟 LLM 响应
        response = f"[{self.name}] 收到: {user_input}"
        self._messages.append(Message("assistant", response))
        self._stats["total_messages"] += 1

        return response

    @property
    def message_count(self) -> int:
        """消息数量（只读属性）"""
        return len(self._messages)

    def clear_history(self) -> None:
        """清空历史"""
        self._messages = []

# 使用
agent = ConversationalAgent("ChatBot")
print(agent.chat("你好"))
print(f"消息数: {agent.message_count}")
```

> **关键概念解释**：
>
> | 代码 | 含义 | 类比 |
> |------|------|------|
> | `self._messages` | 下划线开头 = "私有"属性 | 日记本（别人别随便翻） |
> | `@property` | 把方法变成"只读属性" | 温度计只能看不能改 |
> | `Optional[str]` | 这个参数可以是字符串或 None | 可填可不填的表格项 |
>
> **为什么用下划线 `_messages`？**
> - `self.name` → 公开属性，外面可以随便改
> - `self._messages` → "私有"属性，暗示"别直接改我"
> - 这是 Python 的**约定**，不是强制的
>
> **`@property` 是什么？**
> ```python
> # 没有 @property：
> agent.message_count()   # 必须加括号，是方法
>
> # 有 @property：
> agent.message_count     # 不用括号，像属性一样
> ```

---

## 本节小结

| 概念 | 一句话解释 | 记忆口诀 |
|------|------------|----------|
| **class** | 定义一类东西的蓝图 | 类 = 设计图 |
| **对象** | 根据类创建的具体实例 | 对象 = 真东西 |
| **`__init__`** | 创建对象时自动执行 | init = 出生 |
| **self** | 指向当前对象自己 | self = 我 |
| **`_xxx`** | 暗示私有，别直接改 | 下划线 = 私人 |
| **@property** | 方法伪装成属性 | property = 只读 |

---

**下一节：[3.2 继承与多态](3.2-继承与多态.md)**
