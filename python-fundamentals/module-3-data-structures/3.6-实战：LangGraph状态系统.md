# 2.5 å®æˆ˜ï¼šLangGraph çŠ¶æ€ç³»ç»Ÿ

> **ğŸ¯ å°ç™½ç†è§£æŒ‡å—ï¼šè¿™ä¸€èŠ‚è®²ä»€ä¹ˆï¼Ÿ**
>
> å‰é¢æˆ‘ä»¬å­¦äº†å„ç§"ç§¯æœ¨"ï¼š
> - åˆ—è¡¨ï¼ˆå­˜æ¶ˆæ¯å†å²ï¼‰
> - å­—å…¸ï¼ˆå­˜é…ç½®ä¿¡æ¯ï¼‰
> - é›†åˆï¼ˆå»é‡ï¼‰
> - TypedDictï¼ˆç±»å‹å®‰å…¨çš„å­—å…¸ï¼‰
> - Pydanticï¼ˆæ•°æ®éªŒè¯ï¼‰
>
> è¿™ä¸€èŠ‚æˆ‘ä»¬è¦æŠŠè¿™äº›**ç§¯æœ¨ç»„è£…èµ·æ¥**ï¼Œæ„å»ºä¸€ä¸ªçœŸæ­£çš„ LangGraph Agent çŠ¶æ€ç³»ç»Ÿï¼
>
> **LangGraph å·¥ä½œåŸç†ç®€è¿°**ï¼š
> 1. å®šä¹‰ä¸€ä¸ª**çŠ¶æ€ï¼ˆStateï¼‰**â€”â€”å‘Šè¯‰ç³»ç»Ÿè¦è®°ä½å“ªäº›ä¿¡æ¯
> 2. åˆ›å»ºå¤šä¸ª**èŠ‚ç‚¹ï¼ˆNodeï¼‰**â€”â€”æ¯ä¸ªèŠ‚ç‚¹å¤„ç†çŠ¶æ€ã€è¿”å›æ›´æ–°
> 3. ç”¨**è¾¹ï¼ˆEdgeï¼‰**è¿æ¥èŠ‚ç‚¹â€”â€”å†³å®šæ‰§è¡Œé¡ºåº
> 4. è¿è¡Œå›¾â€”â€”çŠ¶æ€åœ¨èŠ‚ç‚¹é—´ä¼ é€’ï¼Œæœ€ç»ˆå¾—åˆ°ç»“æœ

## å®Œæ•´çš„ LangGraph Agent çŠ¶æ€å®ç°

```python
"""
ç”Ÿäº§çº§ LangGraph çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
æ•´åˆ TypedDict + Pydantic + æ•°æ®ç»“æ„
"""

from typing import TypedDict, Annotated, Sequence
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
import operator

# 1. å®šä¹‰çŠ¶æ€ç»“æ„
# ğŸ¯ å°ç™½è§£è¯»ï¼š
# AgentState å°±æ˜¯ Agent çš„"è®°å¿†è¡¨"ï¼Œè§„å®šäº†å®ƒè¦è®°ä½å“ªäº›ä¿¡æ¯
# TypedDict ç¡®ä¿æ¯ä¸ªå­—æ®µçš„ç±»å‹éƒ½æ˜¯å›ºå®šçš„ï¼Œé˜²æ­¢å‡ºé”™

class AgentState(TypedDict):
    """Agent çŠ¶æ€"""
    # æ¶ˆæ¯åˆ—è¡¨ - ä½¿ç”¨ Annotated å®šä¹‰åˆå¹¶ç­–ç•¥
    # ğŸ¯ operator.add çš„æ„æ€æ˜¯ï¼šæ–°æ¶ˆæ¯ä¼š"è¿½åŠ "åˆ°æ—§æ¶ˆæ¯åé¢ï¼Œè€Œä¸æ˜¯æ›¿æ¢
    messages: Annotated[Sequence[BaseMessage], operator.add]

    # å½“å‰æ­¥éª¤ï¼ˆæ¯”å¦‚ "init" â†’ "processing" â†’ "responding"ï¼‰
    current_step: str

    # è¿­ä»£è®¡æ•°ï¼ˆè®°å½•å¾ªç¯äº†å¤šå°‘æ¬¡ï¼Œé˜²æ­¢æ— é™å¾ªç¯ï¼‰
    iteration: int

    # å·¥å…·ä½¿ç”¨å†å²ï¼ˆè®°å½•ç”¨è¿‡å“ªäº›å·¥å…·ï¼‰
    tools_used: list[str]

    # ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆå¯ä»¥å­˜ä»»ä½•é¢å¤–ä¿¡æ¯ï¼‰
    context: dict

# 2. èŠ‚ç‚¹å‡½æ•°
# ğŸ¯ å°ç™½è§£è¯»ï¼š
# èŠ‚ç‚¹å°±åƒæµæ°´çº¿ä¸Šçš„"å·¥ä½œç«™"ï¼Œæ¯ä¸ªèŠ‚ç‚¹è´Ÿè´£ä¸€é¡¹å·¥ä½œ
# èŠ‚ç‚¹å‡½æ•°æ¥æ”¶å½“å‰çŠ¶æ€ï¼Œå¤„ç†åè¿”å›è¦æ›´æ–°çš„éƒ¨åˆ†

def agent_node(state: AgentState) -> AgentState:
    """Agent èŠ‚ç‚¹ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥"""
    # ä»çŠ¶æ€ä¸­è¯»å–ä¿¡æ¯
    messages = state["messages"]
    iteration = state["iteration"]

    # æ¨¡æ‹Ÿ LLM è°ƒç”¨ï¼ˆå®é™…é¡¹ç›®ä¸­è¿™é‡Œä¼šè°ƒç”¨ ChatGPT ç­‰ï¼‰
    last_message = messages[-1]
    response = AIMessage(content=f"å¤„ç†: {last_message.content}")

    # è¿”å›è¦æ›´æ–°çš„çŠ¶æ€
    # ğŸ¯ æ³¨æ„ï¼šåªè¿”å›è¦æ›´æ–°çš„å­—æ®µï¼Œå…¶ä»–å­—æ®µä¼šä¿æŒä¸å˜
    return {
        "messages": [response],      # æ–°æ¶ˆæ¯ä¼šè¿½åŠ ï¼ˆå› ä¸ºç”¨äº† operator.addï¼‰
        "iteration": iteration + 1,   # è¿­ä»£æ¬¡æ•° +1
        "current_step": "processing"  # æ›´æ–°å½“å‰æ­¥éª¤
    }

def tool_node(state: AgentState) -> AgentState:
    """å·¥å…·èŠ‚ç‚¹ï¼šè°ƒç”¨å¤–éƒ¨å·¥å…·"""
    # ğŸ¯ å·¥å…·èŠ‚ç‚¹æ‰§è¡Œå…·ä½“ä»»åŠ¡ï¼ˆæœç´¢ã€è®¡ç®—ç­‰ï¼‰
    return {
        "current_step": "responding",
        "tools_used": state["tools_used"] + ["search"]  # è®°å½•ä½¿ç”¨äº†æœç´¢å·¥å…·
    }

# 3. è·¯ç”±é€»è¾‘
# ğŸ¯ å°ç™½è§£è¯»ï¼š
# è·¯ç”±å°±åƒ"äº¤é€šæŒ‡æŒ¥å‘˜"ï¼Œæ ¹æ®å½“å‰çŠ¶æ€å†³å®šä¸‹ä¸€æ­¥å»å“ªä¸ªèŠ‚ç‚¹
# è¿”å›çš„å­—ç¬¦ä¸²å¯¹åº”åé¢ add_conditional_edges ä¸­å®šä¹‰çš„è·¯å¾„

def should_continue(state: AgentState) -> str:
    """å†³å®šä¸‹ä¸€æ­¥"""
    # å¦‚æœè¿­ä»£æ¬¡æ•°è¶…è¿‡ 3 æ¬¡ï¼Œå¼ºåˆ¶ç»“æŸï¼ˆé˜²æ­¢æ­»å¾ªç¯ï¼‰
    if state["iteration"] >= 3:
        return "end"

    # å¦‚æœæ¶ˆæ¯ä¸­åŒ…å«"æœç´¢"ï¼Œå°±å»è°ƒç”¨å·¥å…·
    last_message = state["messages"][-1]
    if "æœç´¢" in last_message.content:
        return "tools"

    # å¦åˆ™ç›´æ¥ç»“æŸ
    return "end"

# 4. æ„å»ºå›¾
# ğŸ¯ å°ç™½è§£è¯»ï¼š
# è¿™ä¸€æ­¥æ˜¯æŠŠå‰é¢å®šä¹‰çš„èŠ‚ç‚¹å’Œè·¯ç”±"ç»„è£…"æˆä¸€ä¸ªå®Œæ•´çš„æµç¨‹å›¾

def create_agent_graph():
    """åˆ›å»º Agent å›¾"""
    # åˆ›å»ºä¸€ä¸ªç©ºçš„æµç¨‹å›¾ï¼Œå‘Šè¯‰å®ƒç”¨ä»€ä¹ˆçŠ¶æ€ç»“æ„
    workflow = StateGraph(AgentState)

    # æ·»åŠ èŠ‚ç‚¹ï¼ˆç»™æ¯ä¸ªèŠ‚ç‚¹èµ·ä¸ªåå­—ï¼‰
    workflow.add_node("agent", agent_node)  # ä¸»å¤„ç†èŠ‚ç‚¹
    workflow.add_node("tools", tool_node)   # å·¥å…·è°ƒç”¨èŠ‚ç‚¹

    # è®¾ç½®å…¥å£ç‚¹ï¼ˆä»å“ªä¸ªèŠ‚ç‚¹å¼€å§‹ï¼‰
    workflow.set_entry_point("agent")

    # æ·»åŠ æ¡ä»¶è¾¹ï¼ˆæ ¹æ® should_continue çš„è¿”å›å€¼å†³å®šèµ°å“ªæ¡è·¯ï¼‰
    # ğŸ¯ è¿™å°±åƒåœ°é“çº¿è·¯å›¾ï¼šä» agent ç«™å‡ºå‘ï¼Œæ ¹æ®æ¡ä»¶å»ä¸åŒç«™
    workflow.add_conditional_edges(
        "agent",           # ä» agent èŠ‚ç‚¹å‡ºå‘
        should_continue,   # ç”¨è¿™ä¸ªå‡½æ•°åˆ¤æ–­èµ°å“ªæ¡è·¯
        {
            "tools": "tools",  # è¿”å› "tools" å°±å» tools èŠ‚ç‚¹
            "end": END         # è¿”å› "end" å°±ç»“æŸ
        }
    )

    # å·¥å…·èŠ‚ç‚¹æ‰§è¡Œå®Œåï¼Œå›åˆ° agent èŠ‚ç‚¹ï¼ˆå½¢æˆå¾ªç¯ï¼‰
    workflow.add_edge("tools", "agent")

    # ç¼–è¯‘å›¾ï¼ˆè®©å®ƒå¯ä»¥è¿è¡Œï¼‰
    # ğŸ¯ memory æ˜¯"è®°å¿†å­˜å‚¨"ï¼Œç”¨äºä¿å­˜å¯¹è¯å†å²ï¼ˆè¿™é‡Œç”¨å†…å­˜ä¸´æ—¶å­˜å‚¨ï¼‰
    memory = SqliteSaver.from_conn_string(":memory:")
    app = workflow.compile(checkpointer=memory)

    return app

# 5. ä½¿ç”¨
# ğŸ¯ å°ç™½è§£è¯»ï¼š
# è¿™éƒ¨åˆ†å±•ç¤ºå¦‚ä½•å¯åŠ¨å’Œè¿è¡Œè¿™ä¸ª Agent

def main():
    # åˆ›å»º Agent å›¾
    app = create_agent_graph()

    # å‡†å¤‡åˆå§‹çŠ¶æ€ï¼ˆå‘Šè¯‰ Agent ç”¨æˆ·è¯´äº†ä»€ä¹ˆï¼Œåˆå§‹å€¼æ˜¯å¤šå°‘ï¼‰
    initial_state = {
        "messages": [HumanMessage(content="å¸®æˆ‘æœç´¢Pythonæ•™ç¨‹")],  # ç”¨æˆ·çš„æ¶ˆæ¯
        "current_step": "init",   # åˆå§‹æ­¥éª¤
        "iteration": 0,           # è¿­ä»£æ¬¡æ•°ä» 0 å¼€å§‹
        "tools_used": [],         # è¿˜æ²¡ç”¨è¿‡ä»»ä½•å·¥å…·
        "context": {}             # æ²¡æœ‰é¢å¤–ä¸Šä¸‹æ–‡
    }

    # é…ç½®ï¼ˆthread_id ç”¨äºåŒºåˆ†ä¸åŒçš„å¯¹è¯ï¼‰
    config = {"configurable": {"thread_id": "1"}}

    # ğŸ¯ è¿è¡Œï¼Agent ä¼šè‡ªåŠ¨æ‰§è¡Œæµç¨‹å›¾ï¼Œç›´åˆ°ç»“æŸ
    result = app.invoke(initial_state, config)

    # æŸ¥çœ‹æœ€ç»ˆçŠ¶æ€
    print("æœ€ç»ˆçŠ¶æ€:")
    print(f"è¿­ä»£æ¬¡æ•°: {result['iteration']}")    # æ‰§è¡Œäº†å‡ è½®
    print(f"ä½¿ç”¨å·¥å…·: {result['tools_used']}")   # ç”¨äº†å“ªäº›å·¥å…·
    print(f"æ¶ˆæ¯æ•°: {len(result['messages'])}")  # äº§ç”Ÿäº†å‡ æ¡æ¶ˆæ¯

if __name__ == "__main__":
    main()
```

---

**ä¸‹ä¸€èŠ‚ï¼š[2.6 å°ç»“å’Œå¤ä¹ ](2.6-å°ç»“å’Œå¤ä¹ .md)**
