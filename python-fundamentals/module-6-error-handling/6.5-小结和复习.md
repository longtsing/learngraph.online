# 5.4 小结和复习

## 本章核心概念

### 1. 异常处理
- **try/except/finally**：捕获和处理异常
- **自定义异常**：创建特定的错误类型
- **异常链**：使用 `raise ... from ...`
- **最佳实践**：具体的异常优先于通用异常

### 2. 日志系统
- **logging 模块**：Python 标准日志库
- **日志级别**：DEBUG < INFO < WARNING < ERROR < CRITICAL
- **处理器**：FileHandler, StreamHandler, RotatingFileHandler
- **格式化**：自定义日志输出格式

### 3. 调试技巧
- **print 调试**：快速简单的调试方法
- **pdb/breakpoint()**：交互式调试器
- **装饰器**：创建可复用的调试工具
- **性能分析**：cProfile, tracemalloc

## 知识自测

### 选择题

1. 下面哪种异常处理方式最好？
   - A. `except Exception:`
   - B. `except ValueError:`
   - C. `except:`
   - D. 不处理异常

2. 日志级别从低到高的顺序是？
   - A. INFO < DEBUG < WARNING < ERROR
   - B. DEBUG < INFO < WARNING < ERROR
   - C. WARNING < DEBUG < INFO < ERROR
   - D. DEBUG < WARNING < INFO < ERROR

3. breakpoint() 函数的作用是？
   - A. 抛出异常
   - B. 暂停程序进入调试器
   - C. 设置断点但不停止
   - D. 打印调试信息

<details>
<summary>查看答案</summary>

1. **B** - 应该捕获具体的异常类型，避免捕获所有异常
2. **B** - DEBUG < INFO < WARNING < ERROR < CRITICAL
3. **B** - breakpoint() 会暂停程序并进入交互式调试器

</details>

---

## 高难度编程挑战

### 挑战：智能错误恢复系统（难度：⭐⭐⭐⭐⭐）

**需求**：
设计一个智能错误恢复系统，能够自动从各种错误中恢复并继续执行。

**核心功能**：
1. **错误分类**：将错误分为可恢复和不可恢复
2. **自动重试**：对可恢复错误自动重试
3. **降级策略**：主方法失败时使用备用方法
4. **错误聚合**：收集和分析错误模式
5. **智能决策**：根据错误历史调整重试策略
6. **监控告警**：错误率超过阈值时告警

**代码框架**：

```python
from typing import Callable, Any, Optional, Dict, List, Type
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import time
import statistics
from collections import deque, defaultdict

class ErrorSeverity(Enum):
    """错误严重程度"""
    LOW = "low"          # 可忽略
    MEDIUM = "medium"    # 可重试
    HIGH = "high"        # 需要降级
    CRITICAL = "critical"  # 不可恢复

@dataclass
class ErrorRecord:
    """错误记录"""
    timestamp: datetime
    exception_type: str
    exception_message: str
    severity: ErrorSeverity
    context: Dict[str, Any]
    recovered: bool = False
    retry_count: int = 0

class ErrorClassifier:
    """错误分类器"""
    
    def __init__(self):
        # 定义错误分类规则
        self.rules: Dict[Type[Exception], ErrorSeverity] = {
            ConnectionError: ErrorSeverity.MEDIUM,
            TimeoutError: ErrorSeverity.MEDIUM,
            ValueError: ErrorSeverity.HIGH,
            KeyError: ErrorSeverity.HIGH,
            MemoryError: ErrorSeverity.CRITICAL,
            KeyboardInterrupt: ErrorSeverity.CRITICAL,
        }
    
    def classify(self, exception: Exception) -> ErrorSeverity:
        """分类异常"""
        # TODO: 实现错误分类逻辑
        # - 检查异常类型
        # - 检查异常消息
        # - 返回严重程度
        pass

class RecoveryStrategy:
    """恢复策略"""
    
    def __init__(self):
        self.strategies: Dict[ErrorSeverity, Callable] = {}
    
    def register(
        self,
        severity: ErrorSeverity,
        strategy: Callable[[Exception, Dict[str, Any]], Any]
    ):
        """注册恢复策略"""
        self.strategies[severity] = strategy
    
    def recover(
        self,
        severity: ErrorSeverity,
        exception: Exception,
        context: Dict[str, Any]
    ) -> Any:
        """执行恢复"""
        # TODO: 实现恢复逻辑
        pass

class ErrorAnalyzer:
    """错误分析器"""
    
    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.recent_errors: deque = deque(maxlen=window_size)
        self.error_patterns: Dict[str, List[ErrorRecord]] = defaultdict(list)
    
    def record(self, error: ErrorRecord):
        """记录错误"""
        # TODO: 实现错误记录
        pass
    
    def analyze_pattern(self) -> Dict[str, Any]:
        """分析错误模式"""
        # TODO: 实现模式分析
        # - 错误频率
        # - 错误分布
        # - 恢复成功率
        # - 建议的重试参数
        pass
    
    def get_error_rate(self, time_window: timedelta) -> float:
        """计算错误率"""
        # TODO: 计算指定时间窗口内的错误率
        pass
    
    def should_alert(self) -> bool:
        """是否应该告警"""
        # TODO: 检查是否满足告警条件
        pass

class SmartRecovery:
    """智能错误恢复系统"""
    
    def __init__(
        self,
        max_retries: int = 3,
        initial_delay: float = 1.0,
        backoff_factor: float = 2.0,
        alert_threshold: float = 0.1  # 10% 错误率
    ):
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self.backoff_factor = backoff_factor
        self.alert_threshold = alert_threshold
        
        self.classifier = ErrorClassifier()
        self.recovery = RecoveryStrategy()
        self.analyzer = ErrorAnalyzer()
        
        self._setup_default_strategies()
    
    def _setup_default_strategies(self):
        """设置默认恢复策略"""
        # TODO: 注册各个严重程度的恢复策略
        pass
    
    def execute_with_recovery(
        self,
        func: Callable,
        *args,
        fallback: Optional[Callable] = None,
        context: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> Any:
        """带恢复的执行"""
        # TODO: 实现以下逻辑
        # 1. 尝试执行函数
        # 2. 捕获异常并分类
        # 3. 根据严重程度决定恢复策略
        # 4. 记录错误
        # 5. 分析错误模式
        # 6. 检查是否需要告警
        # 7. 返回结果或执行降级
        pass
    
    def retry_with_backoff(
        self,
        func: Callable,
        *args,
        **kwargs
    ) -> Any:
        """带退避的重试"""
        # TODO: 实现智能重试
        # - 根据历史数据调整重试参数
        # - 实现指数退避
        # - 记录重试次数
        pass
    
    def get_stats(self) -> Dict[str, Any]:
        """获取统计信息"""
        # TODO: 返回错误和恢复统计
        pass

# 使用示例
recovery_system = SmartRecovery()

# 定义可能失败的函数
def unstable_api_call(param: str) -> str:
    """不稳定的 API 调用"""
    import random
    if random.random() < 0.3:  # 30% 失败率
        raise ConnectionError("API 连接失败")
    return f"成功: {param}"

# 定义降级函数
def fallback_method(param: str) -> str:
    """降级方法"""
    return f"降级结果: {param}"

# 执行带恢复的调用
try:
    result = recovery_system.execute_with_recovery(
        unstable_api_call,
        "test_param",
        fallback=fallback_method,
        context={"user_id": "123"}
    )
    print(f"结果: {result}")
except Exception as e:
    print(f"最终失败: {e}")

# 查看统计
stats = recovery_system.get_stats()
print(f"\n统计信息: {stats}")

# 检查是否需要告警
if recovery_system.analyzer.should_alert():
    print("⚠️ 错误率过高，需要人工介入!")
```

**评分标准**：
- 错误分类系统（15分）
- 重试机制和退避策略（20分）
- 降级策略（20分）
- 错误分析和模式识别（25分）
- 告警系统（20分）

---

## 参考解决方案

<details>
<summary>点击查看部分参考实现</summary>

```python
from typing import Callable, Any, Optional, Dict
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import time
from collections import deque

class ErrorSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class ErrorRecord:
    timestamp: datetime
    exception_type: str
    exception_message: str
    severity: ErrorSeverity
    context: Dict[str, Any]
    recovered: bool = False
    retry_count: int = 0

class ErrorClassifier:
    def __init__(self):
        self.rules = {
            ConnectionError: ErrorSeverity.MEDIUM,
            TimeoutError: ErrorSeverity.MEDIUM,
            ValueError: ErrorSeverity.HIGH,
            MemoryError: ErrorSeverity.CRITICAL,
        }
    
    def classify(self, exception: Exception) -> ErrorSeverity:
        exc_type = type(exception)
        
        # 检查精确匹配
        if exc_type in self.rules:
            return self.rules[exc_type]
        
        # 检查父类
        for exc_class, severity in self.rules.items():
            if isinstance(exception, exc_class):
                return severity
        
        # 默认为 HIGH
        return ErrorSeverity.HIGH

class RecoveryStrategy:
    def __init__(self):
        self.strategies = {}
    
    def register(self, severity: ErrorSeverity, strategy: Callable):
        self.strategies[severity] = strategy
    
    def recover(
        self,
        severity: ErrorSeverity,
        exception: Exception,
        context: Dict[str, Any]
    ) -> Any:
        if severity in self.strategies:
            return self.strategies[severity](exception, context)
        raise exception

class SmartRecovery:
    def __init__(
        self,
        max_retries: int = 3,
        initial_delay: float = 1.0,
        backoff_factor: float = 2.0
    ):
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self.backoff_factor = backoff_factor
        
        self.classifier = ErrorClassifier()
        self.recovery = RecoveryStrategy()
        self.error_history: deque = deque(maxlen=100)
        
        self._setup_strategies()
    
    def _setup_strategies(self):
        # MEDIUM: 重试
        self.recovery.register(
            ErrorSeverity.MEDIUM,
            lambda exc, ctx: self._retry_strategy(exc, ctx)
        )
        
        # HIGH: 降级
        self.recovery.register(
            ErrorSeverity.HIGH,
            lambda exc, ctx: self._fallback_strategy(exc, ctx)
        )
    
    def _retry_strategy(self, exception: Exception, context: Dict[str, Any]):
        print(f"使用重试策略: {exception}")
        return "RETRY"
    
    def _fallback_strategy(self, exception: Exception, context: Dict[str, Any]):
        print(f"使用降级策略: {exception}")
        if "fallback" in context:
            return context["fallback"]()
        raise exception
    
    def execute_with_recovery(
        self,
        func: Callable,
        *args,
        fallback: Optional[Callable] = None,
        context: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> Any:
        context = context or {}
        if fallback:
            context["fallback"] = lambda: fallback(*args, **kwargs)
        
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                result = func(*args, **kwargs)
                
                # 记录成功
                if last_exception:
                    self.error_history.append(ErrorRecord(
                        timestamp=datetime.now(),
                        exception_type=type(last_exception).__name__,
                        exception_message=str(last_exception),
                        severity=self.classifier.classify(last_exception),
                        context=context,
                        recovered=True,
                        retry_count=attempt
                    ))
                
                return result
            
            except Exception as e:
                last_exception = e
                severity = self.classifier.classify(e)
                
                print(f"尝试 {attempt + 1}/{self.max_retries} 失败: {e}")
                
                if severity == ErrorSeverity.CRITICAL:
                    raise
                
                if attempt < self.max_retries - 1:
                    delay = self.initial_delay * (self.backoff_factor ** attempt)
                    print(f"等待 {delay:.2f} 秒后重试...")
                    time.sleep(delay)
        
        # 所有重试失败，尝试恢复
        severity = self.classifier.classify(last_exception)
        
        # 记录错误
        self.error_history.append(ErrorRecord(
            timestamp=datetime.now(),
            exception_type=type(last_exception).__name__,
            exception_message=str(last_exception),
            severity=severity,
            context=context,
            recovered=False,
            retry_count=self.max_retries
        ))
        
        return self.recovery.recover(severity, last_exception, context)
    
    def get_stats(self) -> Dict[str, Any]:
        total = len(self.error_history)
        if total == 0:
            return {"total_errors": 0}
        
        recovered = sum(1 for e in self.error_history if e.recovered)
        
        return {
            "total_errors": total,
            "recovered": recovered,
            "recovery_rate": recovered / total if total > 0 else 0.0,
            "recent_errors": total
        }
```

</details>

---

## 学习资源

### 推荐阅读
- [Python 异常处理官方文档](https://docs.python.org/3/tutorial/errors.html)
- [logging 官方文档](https://docs.python.org/3/library/logging.html)
- [pdb 调试器文档](https://docs.python.org/3/library/pdb.html)

### 进阶主题
- 分布式追踪（OpenTelemetry）
- 错误监控（Sentry）
- 性能监控（Prometheus）
- 日志聚合（ELK Stack）

---

**下一章：[Module 6 - 异步编程基础](../module-6-async-programming/6.0-本章介绍.md)**
