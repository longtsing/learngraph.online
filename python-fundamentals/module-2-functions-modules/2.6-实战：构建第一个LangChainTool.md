# 1.5 å®æˆ˜ï¼šæ„å»ºç¬¬ä¸€ä¸ª LangChain Tool

## å¼•è¨€ï¼šä»ç†è®ºåˆ°å®è·µ

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä½ å·²ç»å­¦ä¹ äº†å‡½æ•°ã€è£…é¥°å™¨ã€æ¨¡å—åŒ–â€”â€”ç°åœ¨æ˜¯æ—¶å€™å°†è¿™äº›çŸ¥è¯†ç»¼åˆè¿ç”¨ï¼Œæ„å»ºä¸€ä¸ª**çœŸå®å¯ç”¨çš„ LangChain Tool**ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
1. ç†è§£ LangChain Tool çš„ç»“æ„
2. ä½¿ç”¨ `@tool` è£…é¥°å™¨åˆ›å»ºè‡ªå®šä¹‰å·¥å…·
3. å®ç°é”™è¯¯å¤„ç†å’Œç±»å‹éªŒè¯
4. å°† Tool é›†æˆåˆ° Agent ä¸­
5. å®Œæ•´ç¤ºä¾‹ï¼šå¤©æ°”æŸ¥è¯¢ Tool

## å­¦ä¹ ç›®æ ‡

- âœ… ç†è§£ LangChain Tool çš„åŸºæœ¬ç»“æ„
- âœ… æŒæ¡ `@tool` è£…é¥°å™¨çš„ä½¿ç”¨
- âœ… å®ç°å¥å£®çš„é”™è¯¯å¤„ç†
- âœ… é›†æˆ Tool åˆ° ReAct Agent
- âœ… æµ‹è¯•å’Œè°ƒè¯• Tool

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šLangChain Tool çš„è§£å‰–

### Tool çš„æ ¸å¿ƒè¦ç´ 

ä¸€ä¸ª LangChain Tool éœ€è¦ï¼š

1. **åç§°ï¼ˆnameï¼‰**ï¼šTool çš„å”¯ä¸€æ ‡è¯†ç¬¦
2. **æè¿°ï¼ˆdescriptionï¼‰**ï¼šå‘Šè¯‰ LLM è¿™ä¸ª Tool åšä»€ä¹ˆ
3. **å‚æ•°ï¼ˆargs_schemaï¼‰**ï¼šTool æ¥å—çš„å‚æ•°
4. **æ‰§è¡Œå‡½æ•°ï¼ˆfuncï¼‰**ï¼šTool çš„å®é™…é€»è¾‘

### æœ€ç®€å•çš„ Tool

```python
from langchain.tools import tool

@tool
def get_current_time() -> str:
    """è·å–å½“å‰æ—¶é—´"""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Tool çš„å±æ€§
print(get_current_time.name)         # get_current_time
print(get_current_time.description)  # è·å–å½“å‰æ—¶é—´
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šåˆ›å»ºå¸¦å‚æ•°çš„ Tool

### åŸºç¡€ç¤ºä¾‹

```python
from langchain.tools import tool

@tool
def search_wikipedia(query: str) -> str:
    """
    åœ¨ç»´åŸºç™¾ç§‘ä¸Šæœç´¢ä¿¡æ¯
    
    Args:
        query: æœç´¢å…³é”®è¯
    
    Returns:
        æœç´¢ç»“æœæ‘˜è¦
    """
    # å®é™…å®ç°ä¼šè°ƒç”¨ Wikipedia API
    return f"ç»´åŸºç™¾ç§‘æœç´¢ç»“æœï¼š{query}..."

# è°ƒç”¨
result = search_wikipedia.invoke({"query": "Python programming"})
print(result)
```

### ä½¿ç”¨ Pydantic å®šä¹‰å‚æ•°ç»“æ„

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class CalculatorInput(BaseModel):
    """è®¡ç®—å™¨è¾“å…¥å‚æ•°"""
    expression: str = Field(description="è¦è®¡ç®—çš„æ•°å­¦è¡¨è¾¾å¼")

@tool(args_schema=CalculatorInput)
def calculator(expression: str) -> str:
    """
    è®¡ç®—æ•°å­¦è¡¨è¾¾å¼
    
    Args:
        expression: æ•°å­¦è¡¨è¾¾å¼ï¼ˆå¦‚ "2 + 3 * 4"ï¼‰
    
    Returns:
        è®¡ç®—ç»“æœ
    """
    try:
        result = eval(expression)
        return f"ç»“æœ: {result}"
    except Exception as e:
        return f"è®¡ç®—é”™è¯¯: {str(e)}"
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®ç°çœŸå®çš„ Tool

### å®Œæ•´ç¤ºä¾‹ï¼šå¤©æ°”æŸ¥è¯¢ Tool

```python
"""
å¤©æ°”æŸ¥è¯¢ Tool
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºä¸€ä¸ªçœŸå®å¯ç”¨çš„ LangChain Tool
"""

from langchain.tools import tool
from pydantic import BaseModel, Field
from typing import Optional
import json


class WeatherInput(BaseModel):
    """å¤©æ°”æŸ¥è¯¢è¾“å…¥å‚æ•°"""
    location: str = Field(description="åŸå¸‚åç§°ï¼Œå¦‚ 'åŒ—äº¬' æˆ– 'Beijing'")
    unit: str = Field(
        default="celsius",
        description="æ¸©åº¦å•ä½ï¼š'celsius' æˆ– 'fahrenheit'"
    )


@tool(args_schema=WeatherInput)
def get_weather(location: str, unit: str = "celsius") -> str:
    """
    è·å–æŒ‡å®šåŸå¸‚çš„å¤©æ°”ä¿¡æ¯
    
    è¿™ä¸ªå·¥å…·å¯ä»¥æŸ¥è¯¢ä»»ä½•åŸå¸‚çš„å®æ—¶å¤©æ°”ï¼ŒåŒ…æ‹¬ï¼š
    - å½“å‰æ¸©åº¦
    - å¤©æ°”çŠ¶å†µï¼ˆæ™´ã€é›¨ã€é›ªç­‰ï¼‰
    - æ¹¿åº¦
    - é£é€Ÿ
    
    Args:
        location: åŸå¸‚åç§°
        unit: æ¸©åº¦å•ä½
    
    Returns:
        JSON æ ¼å¼çš„å¤©æ°”ä¿¡æ¯
    """
    # å‚æ•°éªŒè¯
    if not location:
        return json.dumps({"error": "åŸå¸‚åç§°ä¸èƒ½ä¸ºç©º"})
    
    if unit not in ["celsius", "fahrenheit"]:
        return json.dumps({"error": "å•ä½å¿…é¡»æ˜¯ celsius æˆ– fahrenheit"})
    
    # æ¨¡æ‹Ÿ API è°ƒç”¨
    # å®é™…åº”ç”¨ä¸­ä¼šè°ƒç”¨ OpenWeatherMap ç­‰ API
    weather_data = {
        "location": location,
        "temperature": 25 if unit == "celsius" else 77,
        "unit": "Â°C" if unit == "celsius" else "Â°F",
        "condition": "æ™´å¤©",
        "humidity": "60%",
        "wind_speed": "15 km/h",
        "forecast": "æœªæ¥ä¸‰å¤©å¤©æ°”æ™´æœ—"
    }
    
    return json.dumps(weather_data, ensure_ascii=False, indent=2)


# æµ‹è¯• Tool
if __name__ == "__main__":
    result = get_weather.invoke({
        "location": "åŒ—äº¬",
        "unit": "celsius"
    })
    print(result)
```

### å¸¦é”™è¯¯å¤„ç†å’Œé‡è¯•çš„ Tool

```python
from langchain.tools import tool
from pydantic import BaseModel, Field
import time
from typing import Optional


class WebSearchInput(BaseModel):
    """ç½‘ç»œæœç´¢è¾“å…¥å‚æ•°"""
    query: str = Field(description="æœç´¢æŸ¥è¯¢")
    max_results: int = Field(default=5, description="æœ€å¤§ç»“æœæ•°")


@tool(args_schema=WebSearchInput)
def search_web(query: str, max_results: int = 5) -> str:
    """
    æœç´¢ç½‘ç»œå¹¶è¿”å›ç»“æœ
    
    Args:
        query: æœç´¢æŸ¥è¯¢
        max_results: è¿”å›çš„æœ€å¤§ç»“æœæ•°
    
    Returns:
        æœç´¢ç»“æœåˆ—è¡¨ï¼ˆJSON æ ¼å¼ï¼‰
    """
    # å‚æ•°éªŒè¯
    if not query or len(query.strip()) == 0:
        return json.dumps({"error": "æœç´¢æŸ¥è¯¢ä¸èƒ½ä¸ºç©º"})
    
    if max_results < 1 or max_results > 10:
        return json.dumps({"error": "max_results å¿…é¡»åœ¨ 1-10 ä¹‹é—´"})
    
    # é‡è¯•é€»è¾‘
    max_retries = 3
    for attempt in range(max_retries):
        try:
            # æ¨¡æ‹Ÿ API è°ƒç”¨
            results = [
                {
                    "title": f"æœç´¢ç»“æœ {i+1}: {query}",
                    "url": f"https://example.com/result{i+1}",
                    "snippet": f"å…³äº {query} çš„ç›¸å…³ä¿¡æ¯..."
                }
                for i in range(max_results)
            ]
            
            return json.dumps({
                "query": query,
                "results": results,
                "total": len(results)
            }, ensure_ascii=False, indent=2)
            
        except Exception as e:
            if attempt < max_retries - 1:
                time.sleep(1)
                continue
            return json.dumps({
                "error": f"æœç´¢å¤±è´¥: {str(e)}"
            })
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šé›†æˆåˆ° Agent

### åˆ›å»º ReAct Agent

```python
"""
å®Œæ•´çš„ Agent + Tools ç¤ºä¾‹
"""

from langchain.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import create_react_agent
from pydantic import BaseModel, Field
import json


# Tool 1: å¤©æ°”æŸ¥è¯¢
class WeatherInput(BaseModel):
    location: str = Field(description="åŸå¸‚åç§°")


@tool(args_schema=WeatherInput)
def get_weather(location: str) -> str:
    """è·å–åŸå¸‚å¤©æ°”"""
    return json.dumps({
        "location": location,
        "temperature": "25Â°C",
        "condition": "æ™´å¤©"
    }, ensure_ascii=False)


# Tool 2: è®¡ç®—å™¨
class CalculatorInput(BaseModel):
    expression: str = Field(description="æ•°å­¦è¡¨è¾¾å¼")


@tool(args_schema=CalculatorInput)
def calculator(expression: str) -> str:
    """è®¡ç®—æ•°å­¦è¡¨è¾¾å¼"""
    try:
        result = eval(expression)
        return f"ç»“æœ: {result}"
    except Exception as e:
        return f"é”™è¯¯: {str(e)}"


# Tool 3: ç½‘ç»œæœç´¢
class SearchInput(BaseModel):
    query: str = Field(description="æœç´¢æŸ¥è¯¢")


@tool(args_schema=SearchInput)
def search_web(query: str) -> str:
    """æœç´¢ç½‘ç»œ"""
    return json.dumps({
        "query": query,
        "results": [
            {"title": "ç»“æœ1", "url": "http://example.com"}
        ]
    }, ensure_ascii=False)


def create_my_agent():
    """åˆ›å»ºé…ç½®å¥½çš„ Agent"""
    # åˆå§‹åŒ– LLM
    llm = ChatOpenAI(
        model="gpt-3.5-turbo",
        temperature=0
    )
    
    # å·¥å…·åˆ—è¡¨
    tools = [get_weather, calculator, search_web]
    
    # åˆ›å»º Agent
    agent = create_react_agent(
        model=llm,
        tools=tools
    )
    
    return agent


def main():
    """æ¼”ç¤º Agent ä½¿ç”¨"""
    agent = create_my_agent()
    
    # æµ‹è¯•æŸ¥è¯¢
    queries = [
        "åŒ—äº¬çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ",
        "è®¡ç®— 123 * 456",
        "æœç´¢ Python æ•™ç¨‹"
    ]
    
    for query in queries:
        print(f"\nç”¨æˆ·: {query}")
        response = agent.invoke({"messages": [("user", query)]})
        print(f"Agent: {response['messages'][-1].content}")


if __name__ == "__main__":
    # æ³¨æ„ï¼šéœ€è¦è®¾ç½® OPENAI_API_KEY ç¯å¢ƒå˜é‡
    # import os
    # os.environ["OPENAI_API_KEY"] = "your-api-key"
    
    # æ¼”ç¤ºå•ä¸ª Tool
    result = get_weather.invoke({"location": "ä¸Šæµ·"})
    print(result)
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šTool å¼€å‘æœ€ä½³å®è·µ

### 1. è¯¦ç»†çš„æè¿°ï¼ˆDescriptionï¼‰

```python
@tool
def search_database(query: str) -> str:
    """
    åœ¨æ•°æ®åº“ä¸­æœç´¢ä¿¡æ¯
    
    è¿™ä¸ªå·¥å…·å¯ä»¥æœç´¢å…¬å¸å†…éƒ¨æ•°æ®åº“ï¼ŒåŒ…æ‹¬ï¼š
    - äº§å“ä¿¡æ¯
    - å®¢æˆ·è®°å½•  
    - è®¢å•å†å²
    
    ä½¿ç”¨åœºæ™¯ï¼š
    - å½“ç”¨æˆ·è¯¢é—®äº§å“è¯¦æƒ…æ—¶
    - å½“ç”¨æˆ·æŸ¥è¯¢è®¢å•çŠ¶æ€æ—¶
    - å½“éœ€è¦æŸ¥æ‰¾å®¢æˆ·ä¿¡æ¯æ—¶
    
    æ³¨æ„äº‹é¡¹ï¼š
    - æŸ¥è¯¢å¿…é¡»å…·ä½“æ˜ç¡®
    - æ”¯æŒæ¨¡ç³Šæœç´¢
    - æœ€å¤šè¿”å› 20 æ¡ç»“æœ
    
    Args:
        query: æœç´¢æŸ¥è¯¢å­—ç¬¦ä¸²
        
    Returns:
        JSON æ ¼å¼çš„æœç´¢ç»“æœ
    """
    pass
```

> **ğŸ’¡ ä¸ºä»€ä¹ˆæè¿°é‡è¦ï¼Ÿ**  
> LLM é€šè¿‡æè¿°æ¥å†³å®šä½•æ—¶ä½¿ç”¨è¿™ä¸ª Toolã€‚æè¿°è¶Šè¯¦ç»†ï¼ŒTool è¢«æ­£ç¡®ä½¿ç”¨çš„æ¦‚ç‡è¶Šé«˜ã€‚

### 2. å‚æ•°éªŒè¯

```python
from pydantic import BaseModel, Field, validator

class EmailInput(BaseModel):
    """é‚®ä»¶å‘é€å‚æ•°"""
    to: str = Field(description="æ”¶ä»¶äººé‚®ç®±")
    subject: str = Field(description="é‚®ä»¶ä¸»é¢˜")
    body: str = Field(description="é‚®ä»¶æ­£æ–‡")
    
    @validator("to")
    def validate_email(cls, v):
        """éªŒè¯é‚®ç®±æ ¼å¼"""
        if "@" not in v:
            raise ValueError("æ— æ•ˆçš„é‚®ç®±åœ°å€")
        return v
    
    @validator("subject")
    def validate_subject(cls, v):
        """éªŒè¯ä¸»é¢˜ä¸ä¸ºç©º"""
        if not v.strip():
            raise ValueError("é‚®ä»¶ä¸»é¢˜ä¸èƒ½ä¸ºç©º")
        return v
```

### 3. é”™è¯¯å¤„ç†

```python
@tool
def risky_operation(param: str) -> str:
    """å¯èƒ½å¤±è´¥çš„æ“ä½œ"""
    try:
        # å®é™…æ“ä½œ
        result = perform_operation(param)
        return json.dumps({"success": True, "data": result})
    
    except ValueError as e:
        return json.dumps({"success": False, "error": f"å‚æ•°é”™è¯¯: {e}"})
    
    except ConnectionError as e:
        return json.dumps({"success": False, "error": f"ç½‘ç»œé”™è¯¯: {e}"})
    
    except Exception as e:
        return json.dumps({
            "success": False,
            "error": f"æœªçŸ¥é”™è¯¯: {e}",
            "type": type(e).__name__
        })
```

### 4. ç»“æ„åŒ–è¾“å‡º

```python
@tool
def get_user_info(user_id: str) -> str:
    """è·å–ç”¨æˆ·ä¿¡æ¯"""
    # âœ… æ¨èï¼šè¿”å› JSON
    return json.dumps({
        "user_id": user_id,
        "name": "å¼ ä¸‰",
        "email": "zhang@example.com",
        "status": "active"
    }, ensure_ascii=False)
    
    # âŒ ä¸æ¨èï¼šè¿”å›çº¯æ–‡æœ¬
    # return "ç”¨æˆ·ID: 123, å§“å: å¼ ä¸‰, é‚®ç®±: zhang@example.com"
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæµ‹è¯•å’Œè°ƒè¯•

### å•å…ƒæµ‹è¯•

```python
import pytest
from your_tools import get_weather, calculator

def test_get_weather():
    """æµ‹è¯•å¤©æ°”æŸ¥è¯¢"""
    result = get_weather.invoke({"location": "åŒ—äº¬"})
    assert "åŒ—äº¬" in result
    assert "temperature" in result

def test_calculator_valid():
    """æµ‹è¯•è®¡ç®—å™¨ï¼šæœ‰æ•ˆè¾“å…¥"""
    result = calculator.invoke({"expression": "2 + 3"})
    assert "5" in result

def test_calculator_invalid():
    """æµ‹è¯•è®¡ç®—å™¨ï¼šæ— æ•ˆè¾“å…¥"""
    result = calculator.invoke({"expression": "invalid"})
    assert "é”™è¯¯" in result
```

### è°ƒè¯•æŠ€å·§

```python
@tool
def debug_tool(param: str) -> str:
    """å¸¦è°ƒè¯•çš„ Tool"""
    import logging
    logging.basicConfig(level=logging.DEBUG)
    
    logger = logging.getLogger(__name__)
    logger.debug(f"Tool è¢«è°ƒç”¨ï¼Œå‚æ•°: {param}")
    
    try:
        result = process(param)
        logger.debug(f"å¤„ç†æˆåŠŸï¼Œç»“æœ: {result}")
        return result
    except Exception as e:
        logger.error(f"å¤„ç†å¤±è´¥: {e}", exc_info=True)
        raise
```

---

## å®Œæ•´é¡¹ç›®ç¤ºä¾‹

```python
"""
å®Œæ•´çš„ Tool åº“ç¤ºä¾‹
å±•ç¤ºå¦‚ä½•ç»„ç»‡å¤šä¸ª Tools
"""

from langchain.tools import tool
from pydantic import BaseModel, Field
import json
from typing import Optional


# ============= å·¥å…·å®šä¹‰ =============

class WeatherInput(BaseModel):
    location: str = Field(description="åŸå¸‚åç§°")
    unit: str = Field(default="celsius", description="æ¸©åº¦å•ä½")


@tool(args_schema=WeatherInput)
def get_weather(location: str, unit: str = "celsius") -> str:
    """è·å–å¤©æ°”ä¿¡æ¯"""
    return json.dumps({
        "location": location,
        "temperature": 25,
        "unit": unit,
        "condition": "æ™´å¤©"
    }, ensure_ascii=False)


class CalculatorInput(BaseModel):
    expression: str = Field(description="æ•°å­¦è¡¨è¾¾å¼")


@tool(args_schema=CalculatorInput)
def calculator(expression: str) -> str:
    """è®¡ç®—æ•°å­¦è¡¨è¾¾å¼"""
    try:
        result = eval(expression)
        return f"ç»“æœ: {result}"
    except Exception as e:
        return f"é”™è¯¯: {str(e)}"


class SearchInput(BaseModel):
    query: str = Field(description="æœç´¢æŸ¥è¯¢")
    max_results: int = Field(default=5, description="æœ€å¤§ç»“æœæ•°")


@tool(args_schema=SearchInput)
def search_web(query: str, max_results: int = 5) -> str:
    """æœç´¢ç½‘ç»œ"""
    results = [
        {"title": f"ç»“æœ {i+1}", "snippet": f"å…³äº {query}..."}
        for i in range(max_results)
    ]
    return json.dumps(results, ensure_ascii=False)


# ============= å·¥å…·æ³¨å†Œè¡¨ =============

ALL_TOOLS = [get_weather, calculator, search_web]


def get_tools_by_category(category: str) -> list:
    """æŒ‰ç±»åˆ«è·å–å·¥å…·"""
    categories = {
        "weather": [get_weather],
        "math": [calculator],
        "search": [search_web],
        "all": ALL_TOOLS
    }
    return categories.get(category, [])


# ============= ä½¿ç”¨ç¤ºä¾‹ =============

if __name__ == "__main__":
    # æµ‹è¯•æ‰€æœ‰å·¥å…·
    print("=== æµ‹è¯•å¤©æ°”å·¥å…· ===")
    print(get_weather.invoke({"location": "åŒ—äº¬"}))
    
    print("\n=== æµ‹è¯•è®¡ç®—å™¨ ===")
    print(calculator.invoke({"expression": "123 + 456"}))
    
    print("\n=== æµ‹è¯•æœç´¢ ===")
    print(search_web.invoke({"query": "Python", "max_results": 3}))
```

---

## æœ¬èŠ‚æ€»ç»“

### ä½ å­¦åˆ°äº†ä»€ä¹ˆ

1. âœ… LangChain Tool çš„åŸºæœ¬ç»“æ„
2. âœ… ä½¿ç”¨ `@tool` è£…é¥°å™¨åˆ›å»º Tool
3. âœ… ä½¿ç”¨ Pydantic å®šä¹‰å‚æ•°ç»“æ„
4. âœ… å®ç°é”™è¯¯å¤„ç†å’ŒéªŒè¯
5. âœ… é›†æˆ Tool åˆ° Agent
6. âœ… Tool å¼€å‘æœ€ä½³å®è·µ

### å…³é”®è¦ç‚¹

- **è¯¦ç»†çš„æè¿°**ï¼šè®© LLM çŸ¥é“ä½•æ—¶ä½¿ç”¨
- **å‚æ•°éªŒè¯**ï¼šPydantic schema
- **é”™è¯¯å¤„ç†**ï¼šè¿”å›ç»“æ„åŒ–é”™è¯¯ä¿¡æ¯
- **JSON è¾“å‡º**ï¼šä¾¿äºè§£æ
- **æµ‹è¯•**ï¼šç¡®ä¿ Tool æ­£ç¡®å·¥ä½œ

### ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº†åˆ›å»º LangChain Tool çš„æŠ€èƒ½ï¼åœ¨ä¸‹ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†å›é¡¾æœ¬ç« çš„æ‰€æœ‰å†…å®¹ï¼Œå¹¶å®Œæˆé«˜éš¾åº¦çš„ç¼–ç æŒ‘æˆ˜ã€‚

---

**ä¸‹ä¸€èŠ‚ï¼š[1.6 å°ç»“å’Œå¤ä¹ ](1.6-å°ç»“å’Œå¤ä¹ .md)**
