# 1.3 è£…é¥°å™¨ï¼šLangChain çš„æ ¸å¿ƒæ¨¡å¼

## å¼•è¨€ï¼šç»™å‡½æ•°"ç©¿ä¸Šç›”ç”²"

> **å°ç™½ç†è§£**ï¼šè£…é¥°å™¨æ˜¯ Python æœ€"ç¥å¥‡"çš„ç‰¹æ€§ä¹‹ä¸€ï¼Œä½†å…¶å®åŸç†å¾ˆç®€å•ï¼
>
> æƒ³è±¡ä½ æœ‰ä¸€ä¸ª**æ™®é€šå£«å…µ**ï¼ˆå‡½æ•°ï¼‰ï¼Œä½ æƒ³è®©ä»–å˜å¾—æ›´å¼ºï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š
> 1. **æ”¹é€ å£«å…µæœ¬èº«**ï¼šç»™ä»–åšæ‰‹æœ¯ã€æ¢å™¨å®˜ï¼ˆä¿®æ”¹åŸå‡½æ•°ä»£ç ï¼‰
> 2. **ç»™å£«å…µç©¿è£…å¤‡**ï¼šç©¿ç›”ç”²ã€æ‹¿æ­¦å™¨ï¼ˆä½¿ç”¨è£…é¥°å™¨ï¼‰
>
> è£…é¥°å™¨å°±æ˜¯ç¬¬äºŒç§æ–¹æ³•â€”â€”**ä¸æ”¹å˜å£«å…µæœ¬èº«ï¼Œåªæ˜¯ç»™ä»–ç©¿ä¸Šè£…å¤‡**ï¼

å¦‚æœä½ é˜…è¯»è¿‡ LangChain çš„æºç ï¼Œä½ ä¼šå‘ç°è£…é¥°å™¨**æ— å¤„ä¸åœ¨**ï¼š

```python
@tool
def search_web(query: str) -> str:
    """æœç´¢ç½‘ç»œ"""
    pass

@chain
def my_chain(input: dict) -> dict:
    """è‡ªå®šä¹‰é“¾"""
    pass

@retry(max_attempts=3)
def call_api():
    """è°ƒç”¨ API"""
    pass
```

è£…é¥°å™¨æ˜¯ Python ä¸­æœ€ä¼˜é›…ã€æœ€å¼ºå¤§çš„ç‰¹æ€§ä¹‹ä¸€ã€‚å®ƒèƒ½è®©ä½ åœ¨**ä¸ä¿®æ”¹åŸå‡½æ•°ä»£ç **çš„æƒ…å†µä¸‹ï¼Œä¸ºå‡½æ•°æ·»åŠ æ–°åŠŸèƒ½ã€‚è¿™å°±åƒç»™å‡½æ•°"ç©¿ä¸Šç›”ç”²"ï¼Œè®©å®ƒå…·å¤‡é¢å¤–çš„èƒ½åŠ›ã€‚

## å­¦ä¹ ç›®æ ‡

- âœ… ç†è§£è£…é¥°å™¨çš„æœ¬è´¨ï¼šå‡½æ•°çš„åŒ…è£…å™¨
- âœ… ç¼–å†™è‡ªå®šä¹‰è£…é¥°å™¨
- âœ… ä½¿ç”¨ functools.wraps ä¿ç•™å…ƒæ•°æ®
- âœ… å®ç°å¸¦å‚æ•°çš„è£…é¥°å™¨
- âœ… ç†è§£ LangChain çš„ @tool è£…é¥°å™¨
- âœ… å®æˆ˜ï¼šå®ç° @retry å’Œ @log è£…é¥°å™¨

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè£…é¥°å™¨çš„æœ¬è´¨

### ä¸ºä»€ä¹ˆéœ€è¦è£…é¥°å™¨ï¼Ÿ

> **å°ç™½è§£è¯»**ï¼šå‡è®¾ä½ æœ‰ 100 ä¸ªå‡½æ•°ï¼Œç°åœ¨è€æ¿è¯´"æ¯ä¸ªå‡½æ•°æ‰§è¡Œå‰éƒ½è¦æ‰“å°æ—¥å¿—"ã€‚
>
> **ç¬¨æ–¹æ³•**ï¼šæ‰“å¼€æ¯ä¸ªå‡½æ•°ï¼Œåœ¨å¼€å¤´åŠ ä¸€è¡Œ `print("å¼€å§‹æ‰§è¡Œ")`
> - è¦æ”¹ 100 ä¸ªåœ°æ–¹ï¼
> - å¦‚æœä»¥åè¦æ”¹ï¼Œåˆè¦æ”¹ 100 ä¸ªåœ°æ–¹ï¼
>
> **èªæ˜æ–¹æ³•**ï¼šå†™ä¸€ä¸ªè£…é¥°å™¨ï¼Œå¾€æ¯ä¸ªå‡½æ•°ä¸Šä¸€è´´å°±è¡Œ
> ```python
> @log_execution  # è´´ä¸Šè¿™ä¸ªæ ‡ç­¾
> def my_function():
>     ...
> ```
>
> **è£…é¥°å™¨ = æ‰¹é‡ç»™å‡½æ•°åŠ åŠŸèƒ½çš„ç¥å™¨ï¼**

### è£…é¥°å™¨å°±æ˜¯é«˜é˜¶å‡½æ•°

```python
def my_decorator(func):
    """æœ€ç®€å•çš„è£…é¥°å™¨"""
    def wrapper():
        print("å‡½æ•°æ‰§è¡Œå‰")
        func()
        print("å‡½æ•°æ‰§è¡Œå")
    return wrapper

# æ‰‹åŠ¨è£…é¥°
def say_hello():
    print("Hello!")

say_hello = my_decorator(say_hello)
say_hello()

# è¾“å‡º:
# å‡½æ•°æ‰§è¡Œå‰
# Hello!
# å‡½æ•°æ‰§è¡Œå
```

> **å›¾è§£è£…é¥°å™¨åŸç†**ï¼š
> ```
> åŸå§‹çš„ say_hello å‡½æ•°ï¼š
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
> â”‚  print("Hello!")â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
>
> ç»è¿‡ my_decorator åŒ…è£…åï¼š
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
> â”‚  print("å‡½æ•°æ‰§è¡Œå‰")         â”‚ â† æ–°å¢çš„åŠŸèƒ½
> â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
> â”‚  â”‚  print("Hello!")â”‚        â”‚ â† åŸå‡½æ•°
> â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
> â”‚  print("å‡½æ•°æ‰§è¡Œå")         â”‚ â† æ–°å¢çš„åŠŸèƒ½
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
> ```
>
> **å…³é”®**ï¼šåŸå‡½æ•°ä»£ç **ä¸€è¡Œæ²¡æ”¹**ï¼Œä½†ç°åœ¨æœ‰äº†æ–°åŠŸèƒ½ï¼

### ä½¿ç”¨ @ è¯­æ³•

```python
@my_decorator
def say_hello():
    print("Hello!")

# ç­‰ä»·äº: say_hello = my_decorator(say_hello)

say_hello()
```

> **ğŸ’¡ å…³é”®æ¦‚å¿µ**ï¼š`@decorator` åªæ˜¯è¯­æ³•ç³–ï¼Œæœ¬è´¨æ˜¯å‡½æ•°è°ƒç”¨ã€‚

> **å°ç™½ç†è§£ - @ è¯­æ³•çš„ç§˜å¯†**ï¼š
>
> å½“ä½ å†™ï¼š
> ```python
> @my_decorator
> def say_hello():
>     print("Hello!")
> ```
>
> Python å®é™…ä¸Šæ‰§è¡Œçš„æ˜¯ï¼š
> ```python
> def say_hello():
>     print("Hello!")
> say_hello = my_decorator(say_hello)  # æŠŠå‡½æ•°"å–‚"ç»™è£…é¥°å™¨ï¼Œæ‹¿å›å¢å¼ºç‰ˆ
> ```
>
> **@ ç¬¦å·åªæ˜¯ä¸€ä¸ª"å¿«æ·æ–¹å¼"ï¼** è®©ä»£ç æ›´ç®€æ´ã€‚

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šå¤„ç†å‚æ•°å’Œè¿”å›å€¼

### å¤„ç†ä»»æ„å‚æ•°

```python
def timer_decorator(func):
    """è®¡æ—¶è£…é¥°å™¨"""
    import time
    
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} æ‰§è¡Œæ—¶é—´: {end - start:.4f}ç§’")
        return result
    
    return wrapper

@timer_decorator
def calculate_sum(n: int) -> int:
    """è®¡ç®— 1 åˆ° n çš„å’Œ"""
    total = sum(range(1, n + 1))
    return total

result = calculate_sum(1000000)
print(f"ç»“æœ: {result}")
# calculate_sum æ‰§è¡Œæ—¶é—´: 0.0234ç§’
# ç»“æœ: 500000500000
```

### ä¿ç•™å‡½æ•°å…ƒæ•°æ®

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # å…³é”®ï¼ä¿ç•™åŸå‡½æ•°çš„å…ƒæ•°æ®
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """è¿™æ˜¯ç¤ºä¾‹å‡½æ•°"""
    pass

print(example.__name__)  # exampleï¼ˆè€Œä¸æ˜¯ wrapperï¼‰
print(example.__doc__)   # è¿™æ˜¯ç¤ºä¾‹å‡½æ•°
```

> **âš ï¸ é‡è¦**ï¼šå§‹ç»ˆä½¿ç”¨ `@wraps(func)`ï¼Œå¦åˆ™ä¼šä¸¢å¤±å‡½æ•°çš„åç§°ã€æ–‡æ¡£ç­‰ä¿¡æ¯ã€‚

> **å°ç™½ç†è§£ - ä¸ºä»€ä¹ˆéœ€è¦ @wrapsï¼Ÿ**
>
> é—®é¢˜ï¼šè£…é¥°åçš„å‡½æ•°"å¿˜è®°"äº†è‡ªå·±æ˜¯è°
> ```python
> @my_decorator
> def example():
>     """è¿™æ˜¯ç¤ºä¾‹å‡½æ•°"""
>     pass
>
> print(example.__name__)  # è¾“å‡º "wrapper"ï¼ä¸æ˜¯ "example"ï¼
> print(example.__doc__)   # è¾“å‡º Noneï¼æ–‡æ¡£ä¸¢äº†ï¼
> ```
>
> è§£å†³ï¼šç”¨ `@wraps(func)` ä¿ç•™èº«ä»½ä¿¡æ¯
> ```python
> from functools import wraps
>
> def my_decorator(func):
>     @wraps(func)  # å‘Šè¯‰ wrapperï¼š"ä½ è¦ä¼ªè£…æˆ func"
>     def wrapper(*args, **kwargs):
>         return func(*args, **kwargs)
>     return wrapper
> ```
>
> è¿™æ · `example.__name__` å°±æ˜¯ "example"ï¼Œæ–‡æ¡£ä¹Ÿä¿ç•™äº†ï¼

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®ç”¨è£…é¥°å™¨å®ç°

### 1. æ—¥å¿—è£…é¥°å™¨

```python
from functools import wraps
from typing import Callable
import logging

logging.basicConfig(level=logging.INFO)

def log_execution(func: Callable) -> Callable:
    """
    è®°å½•å‡½æ•°æ‰§è¡Œçš„è£…é¥°å™¨
    
    Args:
        func: è¦è£…é¥°çš„å‡½æ•°
    
    Returns:
        åŒ…è£…åçš„å‡½æ•°
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        logging.info(f"è°ƒç”¨å‡½æ•°: {func.__name__}")
        logging.info(f"å‚æ•°: args={args}, kwargs={kwargs}")
        
        try:
            result = func(*args, **kwargs)
            logging.info(f"è¿”å›å€¼: {result}")
            return result
        except Exception as e:
            logging.error(f"å¼‚å¸¸: {e}")
            raise
    
    return wrapper

@log_execution
def call_llm(prompt: str, model: str = "gpt-3.5-turbo") -> str:
    """è°ƒç”¨ LLM API"""
    return f"[æ¨¡æ‹Ÿå“åº”] {prompt[:20]}..."

result = call_llm("What is AI?", model="gpt-4")
```

### 2. é‡è¯•è£…é¥°å™¨

```python
import time
from functools import wraps
from typing import Callable

def retry(
    max_attempts: int = 3,
    delay: float = 1.0,
    backoff: float = 2.0
) -> Callable:
    """
    å¸¦æŒ‡æ•°é€€é¿çš„é‡è¯•è£…é¥°å™¨
    
    Args:
        max_attempts: æœ€å¤§å°è¯•æ¬¡æ•°
        delay: åˆå§‹å»¶è¿Ÿï¼ˆç§’ï¼‰
        backoff: é€€é¿å› å­
    
    Returns:
        è£…é¥°å™¨å‡½æ•°
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            current_delay = delay
            
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    
                    print(f"å°è¯• {attempt + 1} å¤±è´¥: {e}")
                    print(f"ç­‰å¾… {current_delay:.2f}ç§’åé‡è¯•...")
                    time.sleep(current_delay)
                    current_delay *= backoff
        
        return wrapper
    return decorator

@retry(max_attempts=3, delay=1.0, backoff=2.0)
def unstable_api_call():
    """æ¨¡æ‹Ÿä¸ç¨³å®šçš„ API è°ƒç”¨"""
    import random
    if random.random() < 0.7:
        raise ConnectionError("API è°ƒç”¨å¤±è´¥")
    return "æˆåŠŸ"

# æµ‹è¯•
try:
    result = unstable_api_call()
    print(f"æœ€ç»ˆç»“æœ: {result}")
except Exception as e:
    print(f"æ‰€æœ‰é‡è¯•å‡å¤±è´¥: {e}")
```

### 3. ç¼“å­˜è£…é¥°å™¨

```python
from functools import wraps, lru_cache
from typing import Callable

def cache_result(func: Callable) -> Callable:
    """
    ç®€å•çš„ç»“æœç¼“å­˜è£…é¥°å™¨
    
    Args:
        func: è¦è£…é¥°çš„å‡½æ•°
    
    Returns:
        å¸¦ç¼“å­˜çš„å‡½æ•°
    """
    cache = {}
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        # åˆ›å»ºç¼“å­˜é”®
        key = str(args) + str(kwargs)
        
        if key in cache:
            print(f"ä»ç¼“å­˜è¿”å›: {func.__name__}")
            return cache[key]
        
        result = func(*args, **kwargs)
        cache[key] = result
        return result
    
    return wrapper

@cache_result
def expensive_computation(n: int) -> int:
    """æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—"""
    print(f"è®¡ç®— fibonacci({n})...")
    if n <= 1:
        return n
    return expensive_computation(n-1) + expensive_computation(n-2)

# Python å†…ç½®çš„ç¼“å­˜è£…é¥°å™¨ï¼ˆæ›´é«˜æ•ˆï¼‰
@lru_cache(maxsize=128)
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šLangChain çš„ @tool è£…é¥°å™¨

### ç†è§£ @tool çš„å·¥ä½œåŸç†

```python
# LangChain ä¸­çš„ Tool è£…é¥°å™¨ç®€åŒ–å®ç°
from functools import wraps
from typing import Callable, Any

def tool(name: str = None, description: str = None):
    """
    æ¨¡æ‹Ÿ LangChain çš„ @tool è£…é¥°å™¨
    
    Args:
        name: å·¥å…·åç§°
        description: å·¥å…·æè¿°
    
    Returns:
        è£…é¥°å™¨å‡½æ•°
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            # è¿™é‡Œå¯ä»¥æ·»åŠ éªŒè¯ã€æ—¥å¿—ç­‰
            result = func(*args, **kwargs)
            return result
        
        # æ·»åŠ å…ƒæ•°æ®
        wrapper.tool_name = name or func.__name__
        wrapper.tool_description = description or func.__doc__ or ""
        wrapper.is_tool = True
        
        return wrapper
    
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@tool(name="web_search", description="æœç´¢ç½‘ç»œå¹¶è¿”å›ç»“æœ")
def search_web(query: str) -> str:
    """
    æœç´¢ç½‘ç»œ
    
    Args:
        query: æœç´¢æŸ¥è¯¢
    
    Returns:
        æœç´¢ç»“æœ
    """
    return f"æœç´¢ç»“æœ: {query}"

# è®¿é—®å…ƒæ•°æ®
print(f"å·¥å…·å: {search_web.tool_name}")
print(f"å·¥å…·æè¿°: {search_web.tool_description}")
print(f"æ˜¯å¦ä¸ºå·¥å…·: {search_web.is_tool}")
```

### çœŸå®çš„ LangChain Tool ç¤ºä¾‹

```python
from langchain.tools import tool

@tool
def get_weather(location: str) -> str:
    """
    è·å–æŒ‡å®šåœ°ç‚¹çš„å¤©æ°”ä¿¡æ¯
    
    Args:
        location: åœ°ç‚¹åç§°
    
    Returns:
        å¤©æ°”ä¿¡æ¯
    """
    # å®é™…åº”ç”¨ä¸­ä¼šè°ƒç”¨å¤©æ°” API
    return f"{location} çš„å¤©æ°”ï¼šæ™´å¤©ï¼Œ25Â°C"

@tool
def calculate(expression: str) -> str:
    """
    è®¡ç®—æ•°å­¦è¡¨è¾¾å¼
    
    Args:
        expression: æ•°å­¦è¡¨è¾¾å¼
    
    Returns:
        è®¡ç®—ç»“æœ
    """
    try:
        result = eval(expression)
        return f"ç»“æœ: {result}"
    except Exception as e:
        return f"è®¡ç®—é”™è¯¯: {e}"

# åœ¨ Agent ä¸­ä½¿ç”¨
# from langgraph.prebuilt import create_react_agent
# agent = create_react_agent(
#     model=llm,
#     tools=[get_weather, calculate]
# )
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šç»„åˆå¤šä¸ªè£…é¥°å™¨

### è£…é¥°å™¨å †å 

```python
@log_execution
@retry(max_attempts=3)
@cache_result
def critical_api_call(param: str) -> str:
    """å…³é”®çš„ API è°ƒç”¨"""
    return f"Result for {param}"

# ç­‰ä»·äº:
# critical_api_call = log_execution(retry(cache_result(critical_api_call)))

# æ‰§è¡Œé¡ºåºï¼š
# 1. å…ˆåº”ç”¨ cache_result
# 2. ç„¶ååº”ç”¨ retry
# 3. æœ€ååº”ç”¨ log_execution
```

> **âš ï¸ æ³¨æ„é¡ºåº**ï¼šè£…é¥°å™¨ä»ä¸‹å¾€ä¸Šåº”ç”¨ï¼

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå®æˆ˜ - å®Œæ•´çš„è£…é¥°å™¨åº“

```python
"""
Agent è£…é¥°å™¨åº“
ä¸º AI Agent å‡½æ•°æä¾›å¸¸ç”¨è£…é¥°å™¨
"""

import time
import functools
import logging
from typing import Callable, Any

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def measure_time(func: Callable) -> Callable:
    """æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        start = time.perf_counter()
        result = func(*args, **kwargs)
        end = time.perf_counter()
        logger.info(f"{func.__name__} æ‰§è¡Œæ—¶é—´: {end - start:.4f}ç§’")
        return result
    return wrapper


def log_calls(func: Callable) -> Callable:
    """è®°å½•å‡½æ•°è°ƒç”¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        logger.info(f"è°ƒç”¨ {func.__name__}")
        logger.debug(f"å‚æ•°: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        logger.debug(f"è¿”å›: {result}")
        return result
    return wrapper


def validate_args(*validators):
    """
    å‚æ•°éªŒè¯è£…é¥°å™¨
    
    Args:
        *validators: éªŒè¯å‡½æ•°åˆ—è¡¨
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            for validator in validators:
                if not validator(*args, **kwargs):
                    raise ValueError(f"å‚æ•°éªŒè¯å¤±è´¥: {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    return decorator


def rate_limit(calls: int, period: int):
    """
    é€Ÿç‡é™åˆ¶è£…é¥°å™¨
    
    Args:
        calls: å…è®¸çš„è°ƒç”¨æ¬¡æ•°
        period: æ—¶é—´å‘¨æœŸï¼ˆç§’ï¼‰
    """
    from collections import deque
    
    def decorator(func: Callable) -> Callable:
        timestamps = deque(maxlen=calls)
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            now = time.time()
            
            if len(timestamps) == calls:
                time_since_oldest = now - timestamps[0]
                if time_since_oldest < period:
                    sleep_time = period - time_since_oldest
                    logger.warning(f"é€Ÿç‡é™åˆ¶: ç­‰å¾… {sleep_time:.2f}ç§’")
                    time.sleep(sleep_time)
            
            timestamps.append(now)
            return func(*args, **kwargs)
        
        return wrapper
    return decorator


# ä½¿ç”¨ç¤ºä¾‹
@measure_time
@log_calls
@rate_limit(calls=3, period=10)
def call_llm_api(prompt: str) -> str:
    """è°ƒç”¨ LLM API"""
    logger.info(f"å¤„ç†æç¤º: {prompt}")
    time.sleep(0.5)  # æ¨¡æ‹Ÿ API å»¶è¿Ÿ
    return f"å“åº”: {prompt}"


def main():
    """æ¼”ç¤ºè£…é¥°å™¨ä½¿ç”¨"""
    for i in range(5):
        result = call_llm_api(f"è¯·æ±‚ #{i+1}")
        print(result)


if __name__ == "__main__":
    main()
```

---

## æœ¬èŠ‚æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ

1. **è£…é¥°å™¨ = é«˜é˜¶å‡½æ•°** - æ¥å—å‡½æ•°ï¼Œè¿”å›å¢å¼ºçš„å‡½æ•°
2. **@wraps å¿…ä¸å¯å°‘** - ä¿ç•™åŸå‡½æ•°å…ƒæ•°æ®
3. **è£…é¥°å™¨å¯ä»¥å¸¦å‚æ•°** - è¿”å›è£…é¥°å™¨çš„å‡½æ•°
4. **è£…é¥°å™¨å¯ä»¥å †å ** - ä»ä¸‹å¾€ä¸Šåº”ç”¨
5. **LangChain å¤§é‡ä½¿ç”¨è£…é¥°å™¨** - @tool, @chain ç­‰

### æ ¸å¿ƒæ¦‚å¿µä¸€è§ˆè¡¨

| æ¦‚å¿µ | ä¸€å¥è¯è§£é‡Š | ç”Ÿæ´»æ¯”å–» |
|------|----------|---------|
| **è£…é¥°å™¨** | ä¸ä¿®æ”¹åŸå‡½æ•°ï¼Œæ·»åŠ æ–°åŠŸèƒ½ | ç»™å£«å…µç©¿ç›”ç”² |
| **@è¯­æ³•** | è£…é¥°å™¨çš„ç®€å†™å½¢å¼ | å¿«æ·é”® |
| **wrapper** | åŒ…è£…å‡½æ•°ï¼Œæ‰§è¡Œé¢å¤–é€»è¾‘ | ç›”ç”²æœ¬èº« |
| **@wraps** | ä¿ç•™åŸå‡½æ•°èº«ä»½ä¿¡æ¯ | ç›”ç”²ä¸Šå†™ç€å£«å…µçš„åå­— |
| **å¸¦å‚æ•°è£…é¥°å™¨** | å¯é…ç½®çš„è£…é¥°å™¨ | å¯è°ƒèŠ‚çš„ç›”ç”² |
| **å †å è£…é¥°å™¨** | å¤šä¸ªè£…é¥°å™¨å åŠ  | ç©¿å¤šå±‚è£…å¤‡ |

### æ–°æ‰‹å¸¸è§é—®é¢˜

**Q1ï¼šä¸ºä»€ä¹ˆæˆ‘çš„è£…é¥°å™¨å‡½æ•°åå˜æˆäº† wrapperï¼Ÿ**
- å¿˜è®°åŠ  `@wraps(func)`ï¼ŒåŠ ä¸Šå°±å¥½äº†

**Q2ï¼šå¸¦å‚æ•°çš„è£…é¥°å™¨ä¸ºä»€ä¹ˆè¦ä¸‰å±‚åµŒå¥—ï¼Ÿ**
- å¤–å±‚æ¥æ”¶è£…é¥°å™¨å‚æ•°
- ä¸­å±‚æ¥æ”¶è¢«è£…é¥°çš„å‡½æ•°
- å†…å±‚æ˜¯å®é™…æ‰§è¡Œçš„ wrapper

**Q3ï¼šè£…é¥°å™¨å †å çš„é¡ºåºé‡è¦å—ï¼Ÿ**
- é‡è¦ï¼ä»ä¸‹å¾€ä¸Šåº”ç”¨ã€‚æœ€ä¸‹é¢çš„è£…é¥°å™¨æœ€å…ˆåŒ…è£…å‡½æ•°

### å¸¸ç”¨è£…é¥°å™¨æ¨¡å¼

| è£…é¥°å™¨ | ç”¨é€” | åº”ç”¨åœºæ™¯ |
|-------|------|----------|
| `@log_execution` | è®°å½•è°ƒç”¨ | è°ƒè¯•ã€å®¡è®¡ |
| `@retry` | è‡ªåŠ¨é‡è¯• | API è°ƒç”¨ |
| `@cache_result` | ç»“æœç¼“å­˜ | æ˜‚è´µè®¡ç®— |
| `@measure_time` | æ€§èƒ½åˆ†æ | ä¼˜åŒ– |
| `@rate_limit` | é€Ÿç‡é™åˆ¶ | API é™æµ |
| `@tool` | Tool æ³¨å†Œ | LangChain Agent |

---

**ä¸‹ä¸€èŠ‚ï¼š[1.4 æ¨¡å—ä¸åŒ…ç®¡ç†](1.4-æ¨¡å—ä¸åŒ…ç®¡ç†.md)**
