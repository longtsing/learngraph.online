# 1.0 本章介绍

## 从基础到架构：函数式思维

在 Module 0 中，你学会了 Python 的基本语法——变量、数据类型、控制流。这些是"原子"级别的知识。现在，是时候学习如何将这些原子组合成"分子"——**函数**，并进一步构建成"有机体"——**模块化系统**。

想象一下，如果你要构建一个复杂的 AI Agent，它需要：
- 调用 LLM API
- 解析用户输入
- 管理对话历史
- 调用外部工具
- 处理错误和重试
- 记录日志

如果所有代码都写在一个文件的一个函数里，那将是**不可维护的噩梦**。这就是为什么我们需要学习**函数式编程**和**模块化设计**。

## 为什么函数对 AI Agent 如此重要？

在 LangChain 和 LangGraph 的世界里，**一切皆函数**：

```python
# LangChain Tool 本质上就是函数
@tool
def search_web(query: str) -> str:
    """搜索网络并返回结果"""
    return search_api.search(query)

# LangGraph 节点也是函数
def agent_node(state: AgentState) -> AgentState:
    """Agent 节点：处理状态并返回新状态"""
    response = llm.invoke(state["messages"])
    return {"messages": state["messages"] + [response]}

# 装饰器让函数具有超能力
@retry(max_attempts=3)
@log_execution
def call_api(endpoint: str) -> dict:
    """带重试和日志的 API 调用"""
    return requests.get(endpoint).json()
```

如果你不理解函数、装饰器、模块化，你就无法真正理解 LangChain 的源码，也无法构建可维护的 Agent 系统。

## 本章学习目标

通过本章的学习，你将：

### 1. 掌握函数的核心概念
- ✅ 定义和调用函数
- ✅ 参数传递（位置参数、关键字参数、默认值）
- ✅ 返回值与多返回值
- ✅ 函数文档字符串（Docstrings）
- ✅ 类型注解：让函数像 API 文档一样清晰

### 2. 理解高阶函数
- ✅ 函数作为一等公民
- ✅ 函数作为参数（回调函数）
- ✅ 函数作为返回值（工厂函数）
- ✅ Lambda 表达式：匿名函数的艺术

### 3. 掌握装饰器（Decorators）
- ✅ 装饰器的本质：函数的包装器
- ✅ 内置装饰器：@staticmethod, @property
- ✅ 自定义装饰器：日志、计时、重试
- ✅ LangChain 中的装饰器：@tool, @chain

### 4. 模块化设计
- ✅ 模块（Module）与包（Package）
- ✅ import 语句的多种形式
- ✅ \_\_name\_\_ 和 \_\_main\_\_ 的魔法
- ✅ 构建可复用的 Agent 组件库

### 5. 实战：构建 LangChain Tool
- ✅ 从零开始实现一个自定义 Tool
- ✅ 理解 LangChain Tool 的内部机制
- ✅ 集成到 Agent 工作流

## 本章内容导航

```
Module 1: 函数与模块化
│
├── 1.0 本章介绍 (你在这里)
│
├── 1.1 函数基础：打造可复用的 Agent 组件
│   ├── 函数定义与调用
│   ├── 参数传递机制
│   ├── 返回值处理
│   ├── 类型注解与文档字符串
│   └── 实战：封装 LLM 调用函数
│
├── 1.2 高阶函数与函数式编程
│   ├── 函数作为一等公民
│   ├── map(), filter(), reduce()
│   ├── Lambda 表达式
│   ├── 闭包（Closure）
│   └── 实战：构建可配置的 Agent 工厂
│
├── 1.3 装饰器：LangChain 的核心模式
│   ├── 装饰器的本质
│   ├── 编写自定义装饰器
│   ├── 装饰器的参数
│   ├── functools.wraps 的重要性
│   └── 实战：实现 @retry 和 @log 装饰器
│
├── 1.4 模块与包管理
│   ├── 模块的导入机制
│   ├── 相对导入 vs 绝对导入
│   ├── \_\_init\_\_.py 的作用
│   ├── 构建项目结构
│   └── 实战：组织 Agent 项目代码
│
├── 1.5 实战：构建第一个 LangChain Tool
│   ├── Tool 的基本结构
│   ├── 使用 @tool 装饰器
│   ├── 集成到 Agent
│   ├── 错误处理
│   └── 完整示例：天气查询 Tool
│
└── 1.6 小结和复习
    ├── 核心概念回顾
    ├── 高难度编码挑战
    └── 通往 Module 2 的桥梁
```

## 学习方法建议

### 🎯 函数式思维的培养

从现在开始，当你写代码时，要不断问自己：

1. **这段代码是否可以封装成函数？**
2. **这个函数是否做了太多事情？**（单一职责原则）
3. **这个函数是否容易测试？**
4. **这个函数的命名是否清晰表达了其作用？**

### 💡 从 LangChain 源码学习

本章会大量参考 LangChain 和 LangGraph 的源码设计模式。建议你：

1. 阅读 [LangChain GitHub](https://github.com/langchain-ai/langchain)
2. 关注 `@tool` 装饰器的实现
3. 观察 LangChain 如何组织模块结构

### 🔧 实践建议

- 每学一个概念，立即在你的项目中应用
- 重构 Module 0 的代码，使用函数封装
- 尝试阅读并理解 LangChain Tool 的源码
- 完成每节末尾的实战练习

## 与 AI Agent 开发的联系

| 函数概念 | 在 AI Agent 中的应用 |
|---------|---------------------|
| **函数封装** | 将 API 调用、数据处理封装成可复用函数 |
| **高阶函数** | 创建可配置的 Agent 工厂函数 |
| **装饰器** | 为 Agent 添加重试、日志、性能监控 |
| **Lambda** | LangGraph 的条件路由函数 |
| **闭包** | 保持 Agent 的私有状态 |
| **模块化** | 组织大型 Agent 系统的代码结构 |

## 预期学习时间

- **快速阅读**：3-4 小时
- **深度学习（含实践）**：12-16 小时
- **完成所有挑战题**：额外 6-8 小时

## 前置要求

开始本章前，确保你已经：
- ✅ 完成 Module 0 的所有内容
- ✅ 理解变量、数据类型、控制流
- ✅ 能够独立编写简单的 Python 程序
- ✅ 配置好开发环境

## 本章关键概念预览

### 函数签名
```python
def function_name(param: type) -> return_type:
    """Docstring"""
    # 函数体
    return value
```

### 装饰器模式
```python
@decorator
def function():
    pass

# 等价于
function = decorator(function)
```

### 模块导入
```python
from package.module import function
from langchain.tools import tool
from langgraph.prebuilt import create_react_agent
```

## 准备好了吗？

函数式编程是构建优雅、可维护 Agent 系统的关键。这一章可能会有一些挑战性，特别是装饰器部分，但请相信我——一旦你掌握了这些概念，你将能够：

- 阅读并理解 LangChain 的源码
- 构建自己的自定义 Tools
- 写出像专业开发者一样的代码

让我们开始这段激动人心的旅程！

---

## 本章关键词

`函数` `高阶函数` `装饰器` `模块化` `LangChain Tool` `闭包` `Lambda` `DRY原则`

---

**下一节：[1.1 函数基础：打造可复用的 Agent 组件](1.1-函数基础：打造可复用的Agent组件.md)**
