# 5.6 小结和复习

## 本章核心概念

### 1. 文件读写基础
- **pathlib.Path**：现代文件路径操作
- **上下文管理器**：使用 `with` 自动管理资源
- **编码处理**：始终指定 `encoding="utf-8"`
- **文件模式**：r, w, a, r+, w+, a+

### 2. JSON 与 YAML
- **JSON**：`json.dumps()` 和 `json.loads()`
- **YAML**：`yaml.dump()` 和 `yaml.safe_load()`
- **数据序列化**：将 Python 对象转换为文件格式
- **应用场景**：配置文件、数据存储

### 3. 配置管理系统
- **结构化配置**：使用 dataclass 定义配置
- **配置验证**：确保配置的正确性
- **模板系统**：快速创建标准配置
- **版本控制**：跟踪配置变更

### 4. 数据分析和可视化
- **NumPy**：高效数值计算和多维数组
- **Pandas**：DataFrame 数据结构和数据处理
- **Matplotlib**：基础绑图，高度可定制
- **Seaborn**：美观的统计可视化
- **Plotly**：交互式动态图表

## 知识自测

### 选择题

1. 使用 pathlib 时，如何检查文件是否存在？
   - A. `path.exists()`
   - B. `path.is_file()`
   - C. `path.check()`
   - D. A 和 B 都可以

2. JSON 和 YAML 的主要区别是？
   - A. JSON 更快
   - B. YAML 更易读
   - C. JSON 是 Python 内置的
   - D. B 和 C 都对

3. 为什么要使用 with 语句？
   - A. 语法更简洁
   - B. 自动关闭文件
   - C. 更快
   - D. A 和 B 都对

4. NumPy 比 Python 列表快的原因是？
   - A. 向量化运算
   - B. 连续内存存储
   - C. C 语言实现
   - D. 以上全部

5. 创建交互式图表应使用哪个库？
   - A. Matplotlib
   - B. Seaborn
   - C. Plotly
   - D. NumPy

<details>
<summary>查看答案</summary>

1. **D** - `exists()` 检查路径存在，`is_file()` 检查是文件
2. **D** - YAML 更易读，JSON 是 Python 内置模块
3. **D** - with 语句既简洁又能自动管理资源
4. **D** - NumPy 通过向量化、连续内存和 C 实现来提升性能
5. **C** - Plotly 专门用于创建交互式图表

</details>

---

## 高难度编程挑战

### 挑战：智能配置热重载系统（难度：⭐⭐⭐⭐）

**需求**：
实现一个配置热重载系统，当配置文件发生变化时自动重新加载，无需重启程序。

**核心功能**：
1. **文件监控**：监控配置文件的变化
2. **自动重载**：检测到变化时自动加载新配置
3. **回调通知**：配置更新时通知监听器
4. **配置缓存**：避免频繁读取文件
5. **错误处理**：新配置无效时保持旧配置

**代码框架**：

```python
from typing import Callable, Dict, Any, Optional, List
from pathlib import Path
import json
import yaml
import time
import threading
from dataclasses import dataclass, asdict
from datetime import datetime

@dataclass
class ConfigChange:
    """配置变更"""
    old_value: Any
    new_value: Any
    changed_at: datetime
    field_path: str  # 例如: "model.temperature"

class ConfigHotReloader:
    """配置热重载系统"""

    def __init__(
        self,
        config_path: Path,
        check_interval: float = 1.0
    ):
        self.config_path = config_path
        self.check_interval = check_interval

        self.current_config: Optional[Dict[str, Any]] = None
        self.last_modified: Optional[float] = None

        self.listeners: List[Callable[[Dict[str, Any]], None]] = []
        self.change_listeners: List[Callable[[List[ConfigChange]], None]] = []

        self._stop_flag = False
        self._thread: Optional[threading.Thread] = None

        # 加载初始配置
        self._load_config()

    def _load_config(self) -> Dict[str, Any]:
        """加载配置文件"""
        # TODO: 实现配置加载逻辑
        # - 根据文件扩展名选择 JSON 或 YAML
        # - 验证配置
        # - 更新 last_modified
        pass

    def _detect_changes(
        self,
        old_config: Dict[str, Any],
        new_config: Dict[str, Any],
        path: str = ""
    ) -> List[ConfigChange]:
        """检测配置变更"""
        # TODO: 实现变更检测逻辑（递归比较）
        pass

    def _check_file_modified(self) -> bool:
        """检查文件是否被修改"""
        # TODO: 比较文件修改时间
        pass

    def _watch_loop(self):
        """监控循环"""
        # TODO: 实现文件监控循环
        # 1. 检查文件是否修改
        # 2. 如果修改，重新加载
        # 3. 检测变更
        # 4. 通知监听器
        # 5. 休眠一段时间
        pass

    def start(self):
        """启动监控"""
        # TODO: 启动后台监控线程
        pass

    def stop(self):
        """停止监控"""
        # TODO: 停止监控线程
        pass

    def add_listener(self, callback: Callable[[Dict[str, Any]], None]):
        """添加配置更新监听器"""
        self.listeners.append(callback)

    def add_change_listener(self, callback: Callable[[List[ConfigChange]], None]):
        """添加变更监听器"""
        self.change_listeners.append(callback)

    def get_config(self) -> Dict[str, Any]:
        """获取当前配置"""
        return self.current_config.copy()

# 使用示例
def on_config_update(new_config: Dict[str, Any]):
    """配置更新回调"""
    print(f"配置已更新: {new_config}")

def on_config_change(changes: List[ConfigChange]):
    """配置变更回调"""
    print("检测到以下变更:")
    for change in changes:
        print(f"  {change.field_path}: {change.old_value} -> {change.new_value}")

# 创建热重载器
reloader = ConfigHotReloader(
    config_path=Path("agent_config.yaml"),
    check_interval=2.0
)

# 添加监听器
reloader.add_listener(on_config_update)
reloader.add_change_listener(on_config_change)

# 启动监控
reloader.start()

try:
    # 程序继续运行
    while True:
        time.sleep(1)
        # 使用当前配置
        config = reloader.get_config()
        # ...
except KeyboardInterrupt:
    reloader.stop()
```

**评分标准**：
- 文件监控实现（20分）
- 配置加载和验证（20分）
- 变更检测（25分）
- 回调通知机制（20分）
- 错误处理和线程安全（15分）

---

## 参考解决方案

<details>
<summary>点击查看参考实现</summary>

```python
from typing import Callable, Dict, Any, Optional, List
from pathlib import Path
import json
import yaml
import time
import threading
from dataclasses import dataclass
from datetime import datetime
from copy import deepcopy

@dataclass
class ConfigChange:
    old_value: Any
    new_value: Any
    changed_at: datetime
    field_path: str

class ConfigHotReloader:
    def __init__(self, config_path: Path, check_interval: float = 1.0):
        self.config_path = Path(config_path)
        self.check_interval = check_interval
        self.current_config: Optional[Dict[str, Any]] = None
        self.last_modified: Optional[float] = None
        self.listeners: List[Callable[[Dict[str, Any]], None]] = []
        self.change_listeners: List[Callable[[List[ConfigChange]], None]] = []
        self._stop_flag = False
        self._thread: Optional[threading.Thread] = None
        self._lock = threading.Lock()

        self._load_config()

    def _load_config(self) -> Dict[str, Any]:
        """加载配置文件"""
        if not self.config_path.exists():
            raise FileNotFoundError(f"配置文件不存在: {self.config_path}")

        with self.config_path.open("r", encoding="utf-8") as f:
            if self.config_path.suffix == ".json":
                config = json.load(f)
            elif self.config_path.suffix in [".yaml", ".yml"]:
                config = yaml.safe_load(f)
            else:
                raise ValueError(f"不支持的文件格式: {self.config_path.suffix}")

        with self._lock:
            self.current_config = config
            self.last_modified = self.config_path.stat().st_mtime

        return config

    def _detect_changes(
        self,
        old_config: Dict[str, Any],
        new_config: Dict[str, Any],
        path: str = ""
    ) -> List[ConfigChange]:
        """检测配置变更（递归）"""
        changes = []

        # 检查新增和修改的键
        for key, new_value in new_config.items():
            field_path = f"{path}.{key}" if path else key

            if key not in old_config:
                # 新增
                changes.append(ConfigChange(
                    old_value=None,
                    new_value=new_value,
                    changed_at=datetime.now(),
                    field_path=field_path
                ))
            elif old_config[key] != new_value:
                # 修改
                if isinstance(new_value, dict) and isinstance(old_config[key], dict):
                    # 递归检查嵌套字典
                    changes.extend(
                        self._detect_changes(old_config[key], new_value, field_path)
                    )
                else:
                    changes.append(ConfigChange(
                        old_value=old_config[key],
                        new_value=new_value,
                        changed_at=datetime.now(),
                        field_path=field_path
                    ))

        # 检查删除的键
        for key in old_config:
            if key not in new_config:
                field_path = f"{path}.{key}" if path else key
                changes.append(ConfigChange(
                    old_value=old_config[key],
                    new_value=None,
                    changed_at=datetime.now(),
                    field_path=field_path
                ))

        return changes

    def _check_file_modified(self) -> bool:
        """检查文件是否被修改"""
        current_mtime = self.config_path.stat().st_mtime
        return current_mtime != self.last_modified

    def _watch_loop(self):
        """监控循环"""
        while not self._stop_flag:
            try:
                if self._check_file_modified():
                    print("检测到配置文件变化，重新加载...")

                    # 保存旧配置
                    with self._lock:
                        old_config = deepcopy(self.current_config)

                    # 加载新配置
                    try:
                        new_config = self._load_config()

                        # 检测变更
                        changes = self._detect_changes(old_config, new_config)

                        if changes:
                            # 通知变更监听器
                            for listener in self.change_listeners:
                                try:
                                    listener(changes)
                                except Exception as e:
                                    print(f"变更监听器错误: {e}")

                        # 通知配置更新监听器
                        for listener in self.listeners:
                            try:
                                listener(new_config)
                            except Exception as e:
                                print(f"配置监听器错误: {e}")

                    except Exception as e:
                        print(f"加载配置失败，保持旧配置: {e}")
                        # 恢复 last_modified
                        with self._lock:
                            self.last_modified = self.config_path.stat().st_mtime

            except Exception as e:
                print(f"监控循环错误: {e}")

            time.sleep(self.check_interval)

    def start(self):
        """启动监控"""
        if self._thread is None or not self._thread.is_alive():
            self._stop_flag = False
            self._thread = threading.Thread(target=self._watch_loop, daemon=True)
            self._thread.start()
            print("配置热重载已启动")

    def stop(self):
        """停止监控"""
        self._stop_flag = True
        if self._thread:
            self._thread.join(timeout=5)
        print("配置热重载已停止")

    def add_listener(self, callback: Callable[[Dict[str, Any]], None]):
        self.listeners.append(callback)

    def add_change_listener(self, callback: Callable[[List[ConfigChange]], None]):
        self.change_listeners.append(callback)

    def get_config(self) -> Dict[str, Any]:
        with self._lock:
            return deepcopy(self.current_config)
```

</details>

---

## 学习资源

### 推荐阅读
- [pathlib 官方文档](https://docs.python.org/3/library/pathlib.html)
- [JSON 官方文档](https://docs.python.org/3/library/json.html)
- [PyYAML 文档](https://pyyaml.org/wiki/PyYAMLDocumentation)
- [NumPy 官方教程](https://numpy.org/doc/stable/user/quickstart.html)
- [Pandas 官方教程](https://pandas.pydata.org/docs/getting_started/intro_tutorials/)
- [Matplotlib 官方教程](https://matplotlib.org/stable/tutorials/index.html)
- [Seaborn 官方教程](https://seaborn.pydata.org/tutorial.html)
- [Plotly 官方文档](https://plotly.com/python/)

### 进阶主题
- 文件锁和并发访问
- 二进制文件处理
- 大文件流式处理
- 配置加密和安全
- 数据清洗和预处理
- 高级可视化技术

---

**下一章：[Module 6 - 异常处理与调试](../module-6-error-handling/6.0-本章介绍.md)**
