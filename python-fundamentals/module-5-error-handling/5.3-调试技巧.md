# 5.3 调试技巧

## print 调试

```python
def process_agent_response(response: dict) -> str:
    """处理 Agent 响应"""
    print(f"[DEBUG] 收到响应: {response}")
    
    if "choices" in response:
        choices = response["choices"]
        print(f"[DEBUG] choices 数量: {len(choices)}")
        
        if choices:
            message = choices[0].get("message", {})
            content = message.get("content", "")
            print(f"[DEBUG] 内容长度: {len(content)}")
            return content
    
    print("[DEBUG] 响应格式错误")
    return ""

# 使用
response = {
    "choices": [
        {"message": {"content": "你好!"}}
    ]
}

result = process_agent_response(response)
```

## pdb 调试器

```python
import pdb

def calculate_cost(tokens: int, price_per_1k: float) -> float:
    """计算 API 调用成本"""
    # 设置断点
    pdb.set_trace()
    
    cost = (tokens / 1000) * price_per_1k
    return cost

# 运行时会在 set_trace() 处暂停
# 常用命令:
# - n (next): 执行下一行
# - s (step): 进入函数
# - c (continue): 继续执行
# - p variable: 打印变量
# - l (list): 显示代码
# - q (quit): 退出调试

result = calculate_cost(1000, 0.002)
```

## breakpoint() 函数（Python 3.7+）

```python
def complex_calculation(data: list) -> float:
    """复杂计算"""
    result = 0.0
    
    for item in data:
        # 使用 breakpoint() 代替 pdb.set_trace()
        breakpoint()
        
        if isinstance(item, (int, float)):
            result += item
        elif isinstance(item, str):
            result += len(item)
    
    return result

# 使用
data = [1, 2, "hello", 3.5]
total = complex_calculation(data)
```

## 装饰器调试工具

```python
import functools
from typing import Callable, Any
import time

def debug(func: Callable) -> Callable:
    """调试装饰器：打印函数调用信息"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 格式化参数
        args_repr = [repr(a) for a in args]
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
        signature = ", ".join(args_repr + kwargs_repr)
        
        print(f"调用 {func.__name__}({signature})")
        
        # 执行函数
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        
        print(f"  返回 {result!r}")
        print(f"  耗时 {end - start:.4f}秒")
        
        return result
    
    return wrapper

@debug
def call_llm(prompt: str, model: str = "gpt-4") -> str:
    """调用 LLM"""
    time.sleep(0.5)  # 模拟 API 调用
    return f"来自 {model} 的响应"

# 使用
result = call_llm("你好", model="gpt-3.5-turbo")
```

## 性能分析

```python
import cProfile
import pstats
from io import StringIO

def profile_function(func: Callable) -> Callable:
    """性能分析装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()
        
        result = func(*args, **kwargs)
        
        profiler.disable()
        
        # 生成报告
        stream = StringIO()
        ps = pstats.Stats(profiler, stream=stream)
        ps.sort_stats('cumulative')
        ps.print_stats(10)  # 显示前 10 个最慢的函数
        
        print(stream.getvalue())
        
        return result
    
    return wrapper

@profile_function
def process_large_dataset(data: list) -> list:
    """处理大数据集"""
    result = []
    for item in data:
        # 一些复杂处理
        processed = item ** 2
        result.append(processed)
    return result

# 使用
data = list(range(10000))
result = process_large_dataset(data)
```

## 内存分析

```python
import tracemalloc
from typing import Callable

def memory_profile(func: Callable) -> Callable:
    """内存分析装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 开始追踪
        tracemalloc.start()
        
        result = func(*args, **kwargs)
        
        # 获取内存使用情况
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        
        print(f"{func.__name__} 内存使用:")
        print(f"  当前: {current / 1024 / 1024:.2f} MB")
        print(f"  峰值: {peak / 1024 / 1024:.2f} MB")
        
        return result
    
    return wrapper

@memory_profile
def create_large_list(size: int) -> list:
    """创建大列表"""
    return [i for i in range(size)]

# 使用
large_list = create_large_list(1000000)
```

## 自定义调试上下文管理器

```python
from contextlib import contextmanager
from typing import Any
import sys

@contextmanager
def debug_context(name: str, verbose: bool = True):
    """调试上下文"""
    if verbose:
        print(f"[进入] {name}")
    
    try:
        yield
    except Exception as e:
        print(f"[错误] {name}: {e}")
        print(f"  类型: {type(e).__name__}")
        print(f"  位置: {sys.exc_info()[2].tb_frame.f_code.co_filename}")
        raise
    finally:
        if verbose:
            print(f"[退出] {name}")

# 使用
with debug_context("API 调用"):
    # 你的代码
    response = {"status": "success"}
    print(f"响应: {response}")
```

## 断言和验证

```python
from typing import Dict, Any, List

def validate_agent_config(config: Dict[str, Any]):
    """验证 Agent 配置"""
    # 使用断言进行快速检查
    assert "model" in config, "缺少 model 配置"
    assert "temperature" in config, "缺少 temperature 配置"
    
    # 详细验证
    temperature = config["temperature"]
    assert 0 <= temperature <= 2, \
        f"temperature 必须在 0-2 之间，当前值: {temperature}"
    
    assert isinstance(config.get("tools", []), list), \
        "tools 必须是列表"
    
    print("配置验证通过")

# 使用
try:
    config = {
        "model": "gpt-4",
        "temperature": 0.7,
        "tools": ["search", "calculator"]
    }
    validate_agent_config(config)
except AssertionError as e:
    print(f"配置错误: {e}")
```

## 日志调试技巧

```python
import logging
from typing import Any

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class DebugAgent:
    """带调试日志的 Agent"""
    
    def __init__(self, name: str):
        self.name = name
        logger.info(f"初始化 Agent: {name}")
    
    def process(self, input: str) -> str:
        """处理输入"""
        logger.debug(f"收到输入: {input}")
        
        try:
            # 处理逻辑
            result = self._internal_process(input)
            logger.debug(f"处理结果: {result}")
            return result
        
        except Exception as e:
            logger.error(f"处理失败: {e}", exc_info=True)
            raise
    
    def _internal_process(self, input: str) -> str:
        """内部处理"""
        logger.debug("开始内部处理")
        
        # 模拟处理
        if not input:
            raise ValueError("输入不能为空")
        
        return f"处理结果: {input.upper()}"

# 使用
agent = DebugAgent("TestBot")

try:
    result = agent.process("hello")
    print(result)
    
    # 触发错误
    result = agent.process("")
except Exception as e:
    print(f"错误: {e}")
```

## VS Code 调试配置

创建 `.vscode/launch.json`:

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Current File",
            "type": "python",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            "justMyCode": false
        },
        {
            "name": "Python: Agent Script",
            "type": "python",
            "request": "launch",
            "program": "${workspaceFolder}/agent_main.py",
            "args": ["--verbose", "--debug"],
            "console": "integratedTerminal",
            "env": {
                "DEBUG": "true"
            }
        },
        {
            "name": "Python: Attach",
            "type": "python",
            "request": "attach",
            "connect": {
                "host": "localhost",
                "port": 5678
            }
        }
    ]
}
```

## 远程调试（debugpy）

```python
# 安装: pip install debugpy
import debugpy

# 启动调试服务器
debugpy.listen(("0.0.0.0", 5678))
print("等待调试器连接...")
debugpy.wait_for_client()  # 可选：等待调试器连接

# 你的代码
def main():
    print("程序开始运行")
    # ...

if __name__ == "__main__":
    main()
```

## 单元测试中的调试

```python
import unittest

class TestAgentLogic(unittest.TestCase):
    """Agent 逻辑测试"""
    
    def setUp(self):
        """测试前准备"""
        self.agent = DebugAgent("TestAgent")
    
    def test_process_valid_input(self):
        """测试有效输入"""
        result = self.agent.process("hello")
        self.assertEqual(result, "处理结果: HELLO")
    
    def test_process_empty_input(self):
        """测试空输入"""
        with self.assertRaises(ValueError) as context:
            self.agent.process("")
        
        self.assertIn("输入不能为空", str(context.exception))
    
    def test_with_debug(self):
        """带调试的测试"""
        # 在测试中使用 breakpoint()
        input_value = "test"
        breakpoint()  # 调试器会在这里停止
        result = self.agent.process(input_value)
        self.assertIsNotNone(result)

# 运行测试
if __name__ == '__main__':
    unittest.main()
```

## 最佳实践

### 1. 日志级别使用
```python
# DEBUG: 详细的诊断信息
logger.debug(f"变量值: x={x}, y={y}")

# INFO: 一般信息
logger.info("Agent 启动成功")

# WARNING: 警告信息
logger.warning("API 响应较慢")

# ERROR: 错误信息
logger.error("API 调用失败", exc_info=True)

# CRITICAL: 严重错误
logger.critical("系统崩溃")
```

### 2. 临时调试技巧
```python
# 使用环境变量控制调试输出
import os

DEBUG = os.getenv("DEBUG", "false").lower() == "true"

def debug_print(*args, **kwargs):
    """条件打印"""
    if DEBUG:
        print("[DEBUG]", *args, **kwargs)

# 使用
debug_print("这只在 DEBUG=true 时显示")
```

### 3. 异常追踪
```python
import traceback

try:
    # 可能出错的代码
    risky_operation()
except Exception as e:
    # 打印完整的异常追踪
    traceback.print_exc()
    
    # 或者记录到日志
    logger.error("异常详情:", exc_info=True)
```

## 关键要点

1. **选择合适的工具**：print 快速、pdb 深入、日志持久
2. **断点策略**：在关键位置设置断点
3. **日志级别**：合理使用不同级别的日志
4. **性能分析**：找出性能瓶颈
5. **单元测试**：编写测试帮助调试

---

**下一节：[5.4 小结和复习](5.4-小结和复习.md)**
